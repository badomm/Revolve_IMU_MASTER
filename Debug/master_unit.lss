
master_unit.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004750  00400000  00400000  00008000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000438  20000000  00404750  00010000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000c060  20000438  00404b88  00010438  2**2
                  ALLOC
  3 .stack        00000400  2000c498  00410be8  00010438  2**0
                  ALLOC
  4 .heap         00000200  2000c898  00410fe8  00010438  2**0
                  ALLOC
  5 .ARM.attributes 0000002e  00000000  00000000  00010438  2**0
                  CONTENTS, READONLY
  6 .comment      0000005b  00000000  00000000  00010466  2**0
                  CONTENTS, READONLY
  7 .debug_info   0000a01d  00000000  00000000  000104c1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001960  00000000  00000000  0001a4de  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    000032f5  00000000  00000000  0001be3e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000920  00000000  00000000  0001f133  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000820  00000000  00000000  0001fa53  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00012c05  00000000  00000000  00020273  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00008a60  00000000  00000000  00032e78  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00059971  00000000  00000000  0003b8d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00001eac  00000000  00000000  0009524c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <_sfixed>:
  400000:	2000c898 	.word	0x2000c898
  400004:	0040014d 	.word	0x0040014d
  400008:	004001d1 	.word	0x004001d1
  40000c:	004001d1 	.word	0x004001d1
  400010:	004001d1 	.word	0x004001d1
  400014:	004001d1 	.word	0x004001d1
  400018:	004001d1 	.word	0x004001d1
	...
  40002c:	004007bd 	.word	0x004007bd
  400030:	004001d1 	.word	0x004001d1
  400034:	00000000 	.word	0x00000000
  400038:	00400979 	.word	0x00400979
  40003c:	004009d9 	.word	0x004009d9
  400040:	004001d1 	.word	0x004001d1
  400044:	004001d1 	.word	0x004001d1
  400048:	004001d1 	.word	0x004001d1
  40004c:	004001d1 	.word	0x004001d1
  400050:	004001d1 	.word	0x004001d1
  400054:	004001d1 	.word	0x004001d1
  400058:	004001d1 	.word	0x004001d1
  40005c:	004001d1 	.word	0x004001d1
  400060:	00000000 	.word	0x00000000
  400064:	00403b05 	.word	0x00403b05
  400068:	00403b55 	.word	0x00403b55
  40006c:	00403ba5 	.word	0x00403ba5
  400070:	00403bf5 	.word	0x00403bf5
  400074:	00403c45 	.word	0x00403c45
  400078:	004001d1 	.word	0x004001d1
  40007c:	004001d1 	.word	0x004001d1
  400080:	004001d1 	.word	0x004001d1
  400084:	004001d1 	.word	0x004001d1
  400088:	004001d1 	.word	0x004001d1
  40008c:	0040411d 	.word	0x0040411d
  400090:	004001d1 	.word	0x004001d1
  400094:	004001d1 	.word	0x004001d1
  400098:	004001d1 	.word	0x004001d1
  40009c:	004001d1 	.word	0x004001d1
  4000a0:	004001d1 	.word	0x004001d1
  4000a4:	004001d1 	.word	0x004001d1
  4000a8:	004001d1 	.word	0x004001d1
  4000ac:	004001d1 	.word	0x004001d1
  4000b0:	004001d1 	.word	0x004001d1
  4000b4:	004001d1 	.word	0x004001d1
  4000b8:	004001d1 	.word	0x004001d1
  4000bc:	004001d1 	.word	0x004001d1
  4000c0:	004001d1 	.word	0x004001d1
  4000c4:	004001d1 	.word	0x004001d1
  4000c8:	004001d1 	.word	0x004001d1
  4000cc:	004001d1 	.word	0x004001d1
  4000d0:	004001d1 	.word	0x004001d1
  4000d4:	004001d1 	.word	0x004001d1
  4000d8:	004001d1 	.word	0x004001d1
  4000dc:	004001d1 	.word	0x004001d1
	...
  4000f0:	004001d1 	.word	0x004001d1
  4000f4:	004001d1 	.word	0x004001d1

004000f8 <__do_global_dtors_aux>:
  4000f8:	b510      	push	{r4, lr}
  4000fa:	4c05      	ldr	r4, [pc, #20]	; (400110 <__do_global_dtors_aux+0x18>)
  4000fc:	7823      	ldrb	r3, [r4, #0]
  4000fe:	b933      	cbnz	r3, 40010e <__do_global_dtors_aux+0x16>
  400100:	4b04      	ldr	r3, [pc, #16]	; (400114 <__do_global_dtors_aux+0x1c>)
  400102:	b113      	cbz	r3, 40010a <__do_global_dtors_aux+0x12>
  400104:	4804      	ldr	r0, [pc, #16]	; (400118 <__do_global_dtors_aux+0x20>)
  400106:	f3af 8000 	nop.w
  40010a:	2301      	movs	r3, #1
  40010c:	7023      	strb	r3, [r4, #0]
  40010e:	bd10      	pop	{r4, pc}
  400110:	20000438 	.word	0x20000438
  400114:	00000000 	.word	0x00000000
  400118:	00404750 	.word	0x00404750

0040011c <frame_dummy>:
  40011c:	b508      	push	{r3, lr}
  40011e:	4b06      	ldr	r3, [pc, #24]	; (400138 <frame_dummy+0x1c>)
  400120:	b11b      	cbz	r3, 40012a <frame_dummy+0xe>
  400122:	4806      	ldr	r0, [pc, #24]	; (40013c <frame_dummy+0x20>)
  400124:	4906      	ldr	r1, [pc, #24]	; (400140 <frame_dummy+0x24>)
  400126:	f3af 8000 	nop.w
  40012a:	4806      	ldr	r0, [pc, #24]	; (400144 <frame_dummy+0x28>)
  40012c:	6803      	ldr	r3, [r0, #0]
  40012e:	b113      	cbz	r3, 400136 <frame_dummy+0x1a>
  400130:	4b05      	ldr	r3, [pc, #20]	; (400148 <frame_dummy+0x2c>)
  400132:	b103      	cbz	r3, 400136 <frame_dummy+0x1a>
  400134:	4798      	blx	r3
  400136:	bd08      	pop	{r3, pc}
  400138:	00000000 	.word	0x00000000
  40013c:	00404750 	.word	0x00404750
  400140:	2000043c 	.word	0x2000043c
  400144:	00404750 	.word	0x00404750
  400148:	00000000 	.word	0x00000000

0040014c <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  40014c:	b580      	push	{r7, lr}
  40014e:	b082      	sub	sp, #8
  400150:	af00      	add	r7, sp, #0
        uint32_t *pSrc, *pDest;

        /* Initialize the relocate segment */
        pSrc = &_etext;
  400152:	4b16      	ldr	r3, [pc, #88]	; (4001ac <Reset_Handler+0x60>)
  400154:	607b      	str	r3, [r7, #4]
        pDest = &_srelocate;
  400156:	4b16      	ldr	r3, [pc, #88]	; (4001b0 <Reset_Handler+0x64>)
  400158:	603b      	str	r3, [r7, #0]

        if (pSrc != pDest) {
  40015a:	687a      	ldr	r2, [r7, #4]
  40015c:	683b      	ldr	r3, [r7, #0]
  40015e:	429a      	cmp	r2, r3
  400160:	d00c      	beq.n	40017c <Reset_Handler+0x30>
                for (; pDest < &_erelocate;) {
  400162:	e007      	b.n	400174 <Reset_Handler+0x28>
                        *pDest++ = *pSrc++;
  400164:	683b      	ldr	r3, [r7, #0]
  400166:	1d1a      	adds	r2, r3, #4
  400168:	603a      	str	r2, [r7, #0]
  40016a:	687a      	ldr	r2, [r7, #4]
  40016c:	1d11      	adds	r1, r2, #4
  40016e:	6079      	str	r1, [r7, #4]
  400170:	6812      	ldr	r2, [r2, #0]
  400172:	601a      	str	r2, [r3, #0]
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
  400174:	683a      	ldr	r2, [r7, #0]
  400176:	4b0f      	ldr	r3, [pc, #60]	; (4001b4 <Reset_Handler+0x68>)
  400178:	429a      	cmp	r2, r3
  40017a:	d3f3      	bcc.n	400164 <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
  40017c:	4b0e      	ldr	r3, [pc, #56]	; (4001b8 <Reset_Handler+0x6c>)
  40017e:	603b      	str	r3, [r7, #0]
  400180:	e004      	b.n	40018c <Reset_Handler+0x40>
                *pDest++ = 0;
  400182:	683b      	ldr	r3, [r7, #0]
  400184:	1d1a      	adds	r2, r3, #4
  400186:	603a      	str	r2, [r7, #0]
  400188:	2200      	movs	r2, #0
  40018a:	601a      	str	r2, [r3, #0]
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
  40018c:	683a      	ldr	r2, [r7, #0]
  40018e:	4b0b      	ldr	r3, [pc, #44]	; (4001bc <Reset_Handler+0x70>)
  400190:	429a      	cmp	r2, r3
  400192:	d3f6      	bcc.n	400182 <Reset_Handler+0x36>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
  400194:	4b0a      	ldr	r3, [pc, #40]	; (4001c0 <Reset_Handler+0x74>)
  400196:	607b      	str	r3, [r7, #4]
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  400198:	4b0a      	ldr	r3, [pc, #40]	; (4001c4 <Reset_Handler+0x78>)
  40019a:	687a      	ldr	r2, [r7, #4]
  40019c:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
  4001a0:	609a      	str	r2, [r3, #8]

        /* Initialize the C library */
        __libc_init_array();
  4001a2:	4b09      	ldr	r3, [pc, #36]	; (4001c8 <Reset_Handler+0x7c>)
  4001a4:	4798      	blx	r3

        /* Branch to main function */
        main();
  4001a6:	4b09      	ldr	r3, [pc, #36]	; (4001cc <Reset_Handler+0x80>)
  4001a8:	4798      	blx	r3

        /* Infinite loop */
        while (1);
  4001aa:	e7fe      	b.n	4001aa <Reset_Handler+0x5e>
  4001ac:	00404750 	.word	0x00404750
  4001b0:	20000000 	.word	0x20000000
  4001b4:	20000438 	.word	0x20000438
  4001b8:	20000438 	.word	0x20000438
  4001bc:	2000c498 	.word	0x2000c498
  4001c0:	00400000 	.word	0x00400000
  4001c4:	e000ed00 	.word	0xe000ed00
  4001c8:	00404181 	.word	0x00404181
  4001cc:	0040039d 	.word	0x0040039d

004001d0 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  4001d0:	b480      	push	{r7}
  4001d2:	af00      	add	r7, sp, #0
        while (1) {
        }
  4001d4:	e7fe      	b.n	4001d4 <Dummy_Handler+0x4>
  4001d6:	bf00      	nop

004001d8 <led_init>:
 * Created: 3/23/2015 13:02:14
 *  Author: Jimmy Chau
 */ 
#include "output_led.h"

void led_init(){
  4001d8:	b580      	push	{r7, lr}
  4001da:	af00      	add	r7, sp, #0
	pio_init();
  4001dc:	4b09      	ldr	r3, [pc, #36]	; (400204 <led_init+0x2c>)
  4001de:	4798      	blx	r3
	pio_enableOutput(PIOC, 4);
  4001e0:	4809      	ldr	r0, [pc, #36]	; (400208 <led_init+0x30>)
  4001e2:	2104      	movs	r1, #4
  4001e4:	4b09      	ldr	r3, [pc, #36]	; (40020c <led_init+0x34>)
  4001e6:	4798      	blx	r3
	pio_enableOutput(PIOC, 5);
  4001e8:	4807      	ldr	r0, [pc, #28]	; (400208 <led_init+0x30>)
  4001ea:	2105      	movs	r1, #5
  4001ec:	4b07      	ldr	r3, [pc, #28]	; (40020c <led_init+0x34>)
  4001ee:	4798      	blx	r3
	pio_enableOutput(PIOC, 6);
  4001f0:	4805      	ldr	r0, [pc, #20]	; (400208 <led_init+0x30>)
  4001f2:	2106      	movs	r1, #6
  4001f4:	4b05      	ldr	r3, [pc, #20]	; (40020c <led_init+0x34>)
  4001f6:	4798      	blx	r3
	pio_enableOutput(PIOC, 7);
  4001f8:	4803      	ldr	r0, [pc, #12]	; (400208 <led_init+0x30>)
  4001fa:	2107      	movs	r1, #7
  4001fc:	4b03      	ldr	r3, [pc, #12]	; (40020c <led_init+0x34>)
  4001fe:	4798      	blx	r3
}
  400200:	bd80      	pop	{r7, pc}
  400202:	bf00      	nop
  400204:	00403899 	.word	0x00403899
  400208:	400e1200 	.word	0x400e1200
  40020c:	004038e5 	.word	0x004038e5

00400210 <led_toggle>:

void led_toggle(Pio * pio, int pin){
  400210:	b580      	push	{r7, lr}
  400212:	b082      	sub	sp, #8
  400214:	af00      	add	r7, sp, #0
  400216:	6078      	str	r0, [r7, #4]
  400218:	6039      	str	r1, [r7, #0]
	if (pio_readPin(pio, pin)){
  40021a:	683b      	ldr	r3, [r7, #0]
  40021c:	b2db      	uxtb	r3, r3
  40021e:	6878      	ldr	r0, [r7, #4]
  400220:	4619      	mov	r1, r3
  400222:	4b0b      	ldr	r3, [pc, #44]	; (400250 <led_toggle+0x40>)
  400224:	4798      	blx	r3
  400226:	4603      	mov	r3, r0
  400228:	2b00      	cmp	r3, #0
  40022a:	d007      	beq.n	40023c <led_toggle+0x2c>
		pio_setOutput(pio, pin, LOW);
  40022c:	683b      	ldr	r3, [r7, #0]
  40022e:	b2db      	uxtb	r3, r3
  400230:	6878      	ldr	r0, [r7, #4]
  400232:	4619      	mov	r1, r3
  400234:	2200      	movs	r2, #0
  400236:	4b07      	ldr	r3, [pc, #28]	; (400254 <led_toggle+0x44>)
  400238:	4798      	blx	r3
  40023a:	e006      	b.n	40024a <led_toggle+0x3a>
	}else{
		pio_setOutput(pio, pin, HIGH);
  40023c:	683b      	ldr	r3, [r7, #0]
  40023e:	b2db      	uxtb	r3, r3
  400240:	6878      	ldr	r0, [r7, #4]
  400242:	4619      	mov	r1, r3
  400244:	2201      	movs	r2, #1
  400246:	4b03      	ldr	r3, [pc, #12]	; (400254 <led_toggle+0x44>)
  400248:	4798      	blx	r3
	}
}
  40024a:	3708      	adds	r7, #8
  40024c:	46bd      	mov	sp, r7
  40024e:	bd80      	pop	{r7, pc}
  400250:	00403a95 	.word	0x00403a95
  400254:	00403919 	.word	0x00403919

00400258 <queue_init>:
#define CAN_IMU_TX_QUEUE_LENGTH 10

static QueueHandle_t  Queue_CAN_CAR = NULL;
static QueueHandle_t  Queue_CAN_IMU = NULL;

void queue_init(){
  400258:	b580      	push	{r7, lr}
  40025a:	af00      	add	r7, sp, #0
	Queue_CAN_CAR = xQueueCreate(CAN_CAR_TX_QUEUE_LENGTH, sizeof(struct CanMessage));
  40025c:	200a      	movs	r0, #10
  40025e:	2110      	movs	r1, #16
  400260:	2200      	movs	r2, #0
  400262:	4b07      	ldr	r3, [pc, #28]	; (400280 <queue_init+0x28>)
  400264:	4798      	blx	r3
  400266:	4602      	mov	r2, r0
  400268:	4b06      	ldr	r3, [pc, #24]	; (400284 <queue_init+0x2c>)
  40026a:	601a      	str	r2, [r3, #0]
	Queue_CAN_IMU = xQueueCreate(CAN_IMU_TX_QUEUE_LENGTH, sizeof(struct CanMessage));
  40026c:	200a      	movs	r0, #10
  40026e:	2110      	movs	r1, #16
  400270:	2200      	movs	r2, #0
  400272:	4b03      	ldr	r3, [pc, #12]	; (400280 <queue_init+0x28>)
  400274:	4798      	blx	r3
  400276:	4602      	mov	r2, r0
  400278:	4b03      	ldr	r3, [pc, #12]	; (400288 <queue_init+0x30>)
  40027a:	601a      	str	r2, [r3, #0]
}
  40027c:	bd80      	pop	{r7, pc}
  40027e:	bf00      	nop
  400280:	00401115 	.word	0x00401115
  400284:	20000454 	.word	0x20000454
  400288:	20000458 	.word	0x20000458

0040028c <blinkIamAliveTask>:


/*-----------------------------------------------------------*/

static void blinkIamAliveTask()
{
  40028c:	b580      	push	{r7, lr}
  40028e:	b082      	sub	sp, #8
  400290:	af00      	add	r7, sp, #0
	TickType_t xLastWakeTime;
	const TickType_t xFrequency = 10000;
  400292:	f242 7310 	movw	r3, #10000	; 0x2710
  400296:	607b      	str	r3, [r7, #4]
	// Initialise the xLastWakeTime variable with the current time.
	xLastWakeTime = xTaskGetTickCount();
  400298:	4b06      	ldr	r3, [pc, #24]	; (4002b4 <blinkIamAliveTask+0x28>)
  40029a:	4798      	blx	r3
  40029c:	4603      	mov	r3, r0
  40029e:	603b      	str	r3, [r7, #0]

	while(true) {
		toggle_LED3();
  4002a0:	4805      	ldr	r0, [pc, #20]	; (4002b8 <blinkIamAliveTask+0x2c>)
  4002a2:	2107      	movs	r1, #7
  4002a4:	4b05      	ldr	r3, [pc, #20]	; (4002bc <blinkIamAliveTask+0x30>)
  4002a6:	4798      	blx	r3
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
  4002a8:	463b      	mov	r3, r7
  4002aa:	4618      	mov	r0, r3
  4002ac:	6879      	ldr	r1, [r7, #4]
  4002ae:	4b04      	ldr	r3, [pc, #16]	; (4002c0 <blinkIamAliveTask+0x34>)
  4002b0:	4798      	blx	r3
	}
  4002b2:	e7f5      	b.n	4002a0 <blinkIamAliveTask+0x14>
  4002b4:	004020fd 	.word	0x004020fd
  4002b8:	400e1200 	.word	0x400e1200
  4002bc:	00400211 	.word	0x00400211
  4002c0:	00401da5 	.word	0x00401da5

004002c4 <CAN_CAR_sendTask>:
}


//Block until element in queue, try to send message
static void CAN_CAR_sendTask( ){
  4002c4:	b590      	push	{r4, r7, lr}
  4002c6:	b089      	sub	sp, #36	; 0x24
  4002c8:	af02      	add	r7, sp, #8
	TickType_t xLastWakeTime;
	const TickType_t xFrequency = 10;
  4002ca:	230a      	movs	r3, #10
  4002cc:	617b      	str	r3, [r7, #20]
	// Initialise the xLastWakeTime variable with the current time.
	xLastWakeTime = xTaskGetTickCount();
  4002ce:	4b14      	ldr	r3, [pc, #80]	; (400320 <CAN_CAR_sendTask+0x5c>)
  4002d0:	4798      	blx	r3
  4002d2:	4603      	mov	r3, r0
  4002d4:	613b      	str	r3, [r7, #16]
	struct CanMessage message ;
	while(true){
		if(Queue_CAN_CAR != NULL){
  4002d6:	4b13      	ldr	r3, [pc, #76]	; (400324 <CAN_CAR_sendTask+0x60>)
  4002d8:	681b      	ldr	r3, [r3, #0]
  4002da:	2b00      	cmp	r3, #0
  4002dc:	d01f      	beq.n	40031e <CAN_CAR_sendTask+0x5a>
			xQueueReceive(Queue_CAN_CAR, &message, portMAX_DELAY);
  4002de:	4b11      	ldr	r3, [pc, #68]	; (400324 <CAN_CAR_sendTask+0x60>)
  4002e0:	681a      	ldr	r2, [r3, #0]
  4002e2:	463b      	mov	r3, r7
  4002e4:	4610      	mov	r0, r2
  4002e6:	4619      	mov	r1, r3
  4002e8:	f04f 32ff 	mov.w	r2, #4294967295
  4002ec:	2300      	movs	r3, #0
  4002ee:	4c0e      	ldr	r4, [pc, #56]	; (400328 <CAN_CAR_sendTask+0x64>)
  4002f0:	47a0      	blx	r4
			
			while(can_sendMessage(CAN1, message) == TRANSFER_BUSY){
  4002f2:	e005      	b.n	400300 <CAN_CAR_sendTask+0x3c>
				vTaskDelayUntil(&xLastWakeTime,xFrequency);
  4002f4:	f107 0310 	add.w	r3, r7, #16
  4002f8:	4618      	mov	r0, r3
  4002fa:	6979      	ldr	r1, [r7, #20]
  4002fc:	4b0b      	ldr	r3, [pc, #44]	; (40032c <CAN_CAR_sendTask+0x68>)
  4002fe:	4798      	blx	r3
	struct CanMessage message ;
	while(true){
		if(Queue_CAN_CAR != NULL){
			xQueueReceive(Queue_CAN_CAR, &message, portMAX_DELAY);
			
			while(can_sendMessage(CAN1, message) == TRANSFER_BUSY){
  400300:	466b      	mov	r3, sp
  400302:	f107 0208 	add.w	r2, r7, #8
  400306:	e892 0003 	ldmia.w	r2, {r0, r1}
  40030a:	e883 0003 	stmia.w	r3, {r0, r1}
  40030e:	463b      	mov	r3, r7
  400310:	cb0c      	ldmia	r3, {r2, r3}
  400312:	4807      	ldr	r0, [pc, #28]	; (400330 <CAN_CAR_sendTask+0x6c>)
  400314:	4907      	ldr	r1, [pc, #28]	; (400334 <CAN_CAR_sendTask+0x70>)
  400316:	4788      	blx	r1
  400318:	4603      	mov	r3, r0
  40031a:	2b01      	cmp	r3, #1
  40031c:	d0ea      	beq.n	4002f4 <CAN_CAR_sendTask+0x30>
				vTaskDelayUntil(&xLastWakeTime,xFrequency);
			}
		}
	}
  40031e:	e7da      	b.n	4002d6 <CAN_CAR_sendTask+0x12>
  400320:	004020fd 	.word	0x004020fd
  400324:	20000454 	.word	0x20000454
  400328:	00401625 	.word	0x00401625
  40032c:	00401da5 	.word	0x00401da5
  400330:	40014000 	.word	0x40014000
  400334:	004037c9 	.word	0x004037c9

00400338 <canTestTask>:
}

/*-----------------------------------------------------------*/

static void canTestTask(void *pvParameters ){
  400338:	b590      	push	{r4, r7, lr}
  40033a:	b089      	sub	sp, #36	; 0x24
  40033c:	af00      	add	r7, sp, #0
  40033e:	6078      	str	r0, [r7, #4]
	TickType_t xLastWakeTime;
	const TickType_t xFrequency = 1000;	
  400340:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  400344:	61fb      	str	r3, [r7, #28]
	xLastWakeTime = xTaskGetTickCount();
  400346:	4b10      	ldr	r3, [pc, #64]	; (400388 <canTestTask+0x50>)
  400348:	4798      	blx	r3
  40034a:	4603      	mov	r3, r0
  40034c:	61bb      	str	r3, [r7, #24]
	while(true){
		struct CanMessage message ={
  40034e:	4b0f      	ldr	r3, [pc, #60]	; (40038c <canTestTask+0x54>)
  400350:	f107 0408 	add.w	r4, r7, #8
  400354:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  400356:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
			.data = 15,
			.dataLength = 1,
			.messageID = 0x44,
		};
		if(Queue_CAN_CAR != NULL){
  40035a:	4b0d      	ldr	r3, [pc, #52]	; (400390 <canTestTask+0x58>)
  40035c:	681b      	ldr	r3, [r3, #0]
  40035e:	2b00      	cmp	r3, #0
  400360:	d010      	beq.n	400384 <canTestTask+0x4c>
			xQueueSend(Queue_CAN_CAR, &message, 0);
  400362:	4b0b      	ldr	r3, [pc, #44]	; (400390 <canTestTask+0x58>)
  400364:	681a      	ldr	r2, [r3, #0]
  400366:	f107 0308 	add.w	r3, r7, #8
  40036a:	4610      	mov	r0, r2
  40036c:	4619      	mov	r1, r3
  40036e:	2200      	movs	r2, #0
  400370:	2300      	movs	r3, #0
  400372:	4c08      	ldr	r4, [pc, #32]	; (400394 <canTestTask+0x5c>)
  400374:	47a0      	blx	r4
			vTaskDelayUntil(&xLastWakeTime,xFrequency);
  400376:	f107 0318 	add.w	r3, r7, #24
  40037a:	4618      	mov	r0, r3
  40037c:	69f9      	ldr	r1, [r7, #28]
  40037e:	4b06      	ldr	r3, [pc, #24]	; (400398 <canTestTask+0x60>)
  400380:	4798      	blx	r3
		}
	}
  400382:	e7e4      	b.n	40034e <canTestTask+0x16>
  400384:	e7e3      	b.n	40034e <canTestTask+0x16>
  400386:	bf00      	nop
  400388:	004020fd 	.word	0x004020fd
  40038c:	004044f8 	.word	0x004044f8
  400390:	20000454 	.word	0x20000454
  400394:	004011cd 	.word	0x004011cd
  400398:	00401da5 	.word	0x00401da5

0040039c <main>:
}


int main( void )
{
  40039c:	b590      	push	{r4, r7, lr}
  40039e:	b08b      	sub	sp, #44	; 0x2c
  4003a0:	af04      	add	r7, sp, #16
	WDT->WDT_MR &= ~(1<<13); // fjerne WDT plz
  4003a2:	4b30      	ldr	r3, [pc, #192]	; (400464 <main+0xc8>)
  4003a4:	4a2f      	ldr	r2, [pc, #188]	; (400464 <main+0xc8>)
  4003a6:	6852      	ldr	r2, [r2, #4]
  4003a8:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
  4003ac:	605a      	str	r2, [r3, #4]
	
	
	init_flash();
  4003ae:	4b2e      	ldr	r3, [pc, #184]	; (400468 <main+0xcc>)
  4003b0:	4798      	blx	r3
	struct PmcInit pmcInit = {
  4003b2:	4a2e      	ldr	r2, [pc, #184]	; (40046c <main+0xd0>)
  4003b4:	f107 0310 	add.w	r3, r7, #16
  4003b8:	6810      	ldr	r0, [r2, #0]
  4003ba:	6018      	str	r0, [r3, #0]
  4003bc:	7912      	ldrb	r2, [r2, #4]
  4003be:	711a      	strb	r2, [r3, #4]
		.pres = CLK_2,
		.divide = 1,
		.multiply = 14
		};

	pmc_init(pmcInit);
  4003c0:	f107 0310 	add.w	r3, r7, #16
  4003c4:	e893 0003 	ldmia.w	r3, {r0, r1}
  4003c8:	4b29      	ldr	r3, [pc, #164]	; (400470 <main+0xd4>)
  4003ca:	4798      	blx	r3
	led_init();
  4003cc:	4b29      	ldr	r3, [pc, #164]	; (400474 <main+0xd8>)
  4003ce:	4798      	blx	r3


	can_init(CAN1, CLOCK_SPEED_120MHZ, CAN_BPS_1000K);
  4003d0:	4829      	ldr	r0, [pc, #164]	; (400478 <main+0xdc>)
  4003d2:	492a      	ldr	r1, [pc, #168]	; (40047c <main+0xe0>)
  4003d4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  4003d8:	4b29      	ldr	r3, [pc, #164]	; (400480 <main+0xe4>)
  4003da:	4798      	blx	r3
		struct CanMessage message ={
  4003dc:	4b29      	ldr	r3, [pc, #164]	; (400484 <main+0xe8>)
  4003de:	463c      	mov	r4, r7
  4003e0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  4003e2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
			.data = 2,
			.dataLength = 1,
			.messageID = 0x44,
		};

 can_sendMessage(CAN1, message);
  4003e6:	466b      	mov	r3, sp
  4003e8:	f107 0208 	add.w	r2, r7, #8
  4003ec:	e892 0003 	ldmia.w	r2, {r0, r1}
  4003f0:	e883 0003 	stmia.w	r3, {r0, r1}
  4003f4:	463b      	mov	r3, r7
  4003f6:	cb0c      	ldmia	r3, {r2, r3}
  4003f8:	481f      	ldr	r0, [pc, #124]	; (400478 <main+0xdc>)
  4003fa:	4923      	ldr	r1, [pc, #140]	; (400488 <main+0xec>)
  4003fc:	4788      	blx	r1

	queue_init();
  4003fe:	4b23      	ldr	r3, [pc, #140]	; (40048c <main+0xf0>)
  400400:	4798      	blx	r3
	//
	xTaskCreate(blinkIamAliveTask, "blinkIamAliveTask", configMINIMAL_STACK_SIZE, NULL,  tskIDLE_PRIORITY + 1, NULL);
  400402:	2301      	movs	r3, #1
  400404:	9300      	str	r3, [sp, #0]
  400406:	2300      	movs	r3, #0
  400408:	9301      	str	r3, [sp, #4]
  40040a:	2300      	movs	r3, #0
  40040c:	9302      	str	r3, [sp, #8]
  40040e:	2300      	movs	r3, #0
  400410:	9303      	str	r3, [sp, #12]
  400412:	481f      	ldr	r0, [pc, #124]	; (400490 <main+0xf4>)
  400414:	491f      	ldr	r1, [pc, #124]	; (400494 <main+0xf8>)
  400416:	2278      	movs	r2, #120	; 0x78
  400418:	2300      	movs	r3, #0
  40041a:	4c1f      	ldr	r4, [pc, #124]	; (400498 <main+0xfc>)
  40041c:	47a0      	blx	r4
	//xTaskCreate(spiTestTask, "spiTestTask", 10000, NULL,  tskIDLE_PRIORITY + 2, NULL);
	xTaskCreate(CAN_CAR_sendTask, "CAN_CAR_sendTask", configMINIMAL_STACK_SIZE, NULL,  tskIDLE_PRIORITY + 3, NULL);
  40041e:	2303      	movs	r3, #3
  400420:	9300      	str	r3, [sp, #0]
  400422:	2300      	movs	r3, #0
  400424:	9301      	str	r3, [sp, #4]
  400426:	2300      	movs	r3, #0
  400428:	9302      	str	r3, [sp, #8]
  40042a:	2300      	movs	r3, #0
  40042c:	9303      	str	r3, [sp, #12]
  40042e:	481b      	ldr	r0, [pc, #108]	; (40049c <main+0x100>)
  400430:	491b      	ldr	r1, [pc, #108]	; (4004a0 <main+0x104>)
  400432:	2278      	movs	r2, #120	; 0x78
  400434:	2300      	movs	r3, #0
  400436:	4c18      	ldr	r4, [pc, #96]	; (400498 <main+0xfc>)
  400438:	47a0      	blx	r4
	xTaskCreate(canTestTask, "canTestTask", configMINIMAL_STACK_SIZE, NULL,  tskIDLE_PRIORITY + 2, NULL);
  40043a:	2302      	movs	r3, #2
  40043c:	9300      	str	r3, [sp, #0]
  40043e:	2300      	movs	r3, #0
  400440:	9301      	str	r3, [sp, #4]
  400442:	2300      	movs	r3, #0
  400444:	9302      	str	r3, [sp, #8]
  400446:	2300      	movs	r3, #0
  400448:	9303      	str	r3, [sp, #12]
  40044a:	4816      	ldr	r0, [pc, #88]	; (4004a4 <main+0x108>)
  40044c:	4916      	ldr	r1, [pc, #88]	; (4004a8 <main+0x10c>)
  40044e:	2278      	movs	r2, #120	; 0x78
  400450:	2300      	movs	r3, #0
  400452:	4c11      	ldr	r4, [pc, #68]	; (400498 <main+0xfc>)
  400454:	47a0      	blx	r4
	vTaskStartScheduler();
  400456:	4b15      	ldr	r3, [pc, #84]	; (4004ac <main+0x110>)
  400458:	4798      	blx	r3


	return 0;
  40045a:	2300      	movs	r3, #0
}
  40045c:	4618      	mov	r0, r3
  40045e:	371c      	adds	r7, #28
  400460:	46bd      	mov	sp, r7
  400462:	bd90      	pop	{r4, r7, pc}
  400464:	400e1850 	.word	0x400e1850
  400468:	0040384d 	.word	0x0040384d
  40046c:	0040453c 	.word	0x0040453c
  400470:	004040c5 	.word	0x004040c5
  400474:	004001d9 	.word	0x004001d9
  400478:	40014000 	.word	0x40014000
  40047c:	07270e00 	.word	0x07270e00
  400480:	00403725 	.word	0x00403725
  400484:	00404548 	.word	0x00404548
  400488:	004037c9 	.word	0x004037c9
  40048c:	00400259 	.word	0x00400259
  400490:	0040028d 	.word	0x0040028d
  400494:	00404508 	.word	0x00404508
  400498:	00401c01 	.word	0x00401c01
  40049c:	004002c5 	.word	0x004002c5
  4004a0:	0040451c 	.word	0x0040451c
  4004a4:	00400339 	.word	0x00400339
  4004a8:	00404530 	.word	0x00404530
  4004ac:	00401ebd 	.word	0x00401ebd

004004b0 <vApplicationStackOverflowHook>:
/*-----------------------------------------------------------*/


void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName )
{
  4004b0:	b580      	push	{r7, lr}
  4004b2:	b082      	sub	sp, #8
  4004b4:	af00      	add	r7, sp, #0
  4004b6:	6078      	str	r0, [r7, #4]
  4004b8:	6039      	str	r1, [r7, #0]
	( void ) pxTask;

	/* Run time stack overflow checking is performed if
	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook	function is
	called if a stack overflow is detected. */
	vAssertCalled( __LINE__, __FILE__ );
  4004ba:	2098      	movs	r0, #152	; 0x98
  4004bc:	4902      	ldr	r1, [pc, #8]	; (4004c8 <vApplicationStackOverflowHook+0x18>)
  4004be:	4b03      	ldr	r3, [pc, #12]	; (4004cc <vApplicationStackOverflowHook+0x1c>)
  4004c0:	4798      	blx	r3
}
  4004c2:	3708      	adds	r7, #8
  4004c4:	46bd      	mov	sp, r7
  4004c6:	bd80      	pop	{r7, pc}
  4004c8:	00404558 	.word	0x00404558
  4004cc:	004004d1 	.word	0x004004d1

004004d0 <vAssertCalled>:
/*-----------------------------------------------------------*/

void vAssertCalled( uint32_t ulLine, const char *pcFile )
{
  4004d0:	b580      	push	{r7, lr}
  4004d2:	b086      	sub	sp, #24
  4004d4:	af00      	add	r7, sp, #0
  4004d6:	6078      	str	r0, [r7, #4]
  4004d8:	6039      	str	r1, [r7, #0]
/* The following two variables are just to ensure the parameters are not
optimised away and therefore unavailable when viewed in the debugger. */
volatile uint32_t ulLineNumber = ulLine, ulSetNonZeroInDebuggerToReturn = 0;
  4004da:	687b      	ldr	r3, [r7, #4]
  4004dc:	613b      	str	r3, [r7, #16]
  4004de:	2300      	movs	r3, #0
  4004e0:	60fb      	str	r3, [r7, #12]
volatile const char * const pcFileName = pcFile;
  4004e2:	683b      	ldr	r3, [r7, #0]
  4004e4:	617b      	str	r3, [r7, #20]

	taskENTER_CRITICAL();
  4004e6:	4b06      	ldr	r3, [pc, #24]	; (400500 <vAssertCalled+0x30>)
  4004e8:	4798      	blx	r3
	while( ulSetNonZeroInDebuggerToReturn == 0 )
  4004ea:	bf00      	nop
  4004ec:	68fb      	ldr	r3, [r7, #12]
  4004ee:	2b00      	cmp	r3, #0
  4004f0:	d0fc      	beq.n	4004ec <vAssertCalled+0x1c>
	{
		/* If you want to set out of this function in the debugger to see the
		assert() location then set ulSetNonZeroInDebuggerToReturn to a non-zero
		value. */
	}
	taskEXIT_CRITICAL();
  4004f2:	4b04      	ldr	r3, [pc, #16]	; (400504 <vAssertCalled+0x34>)
  4004f4:	4798      	blx	r3

	( void ) pcFileName;
	( void ) ulLineNumber;
  4004f6:	693b      	ldr	r3, [r7, #16]
}
  4004f8:	3718      	adds	r7, #24
  4004fa:	46bd      	mov	sp, r7
  4004fc:	bd80      	pop	{r7, pc}
  4004fe:	bf00      	nop
  400500:	004008dd 	.word	0x004008dd
  400504:	00400931 	.word	0x00400931

00400508 <vConfigureTimerForRunTimeStats>:
#define runtimeOVERFLOW_BIT_14		( 1UL << ( 32UL - runtimeSHIFT_14 ) )

/*-----------------------------------------------------------*/

void vConfigureTimerForRunTimeStats( void )
{
  400508:	b480      	push	{r7}
  40050a:	af00      	add	r7, sp, #0
	/* Enable TRCENA. */
	rtsSCB_DEMCR = rtsSCB_DEMCR | rtsTRCENA_BIT;
  40050c:	4b09      	ldr	r3, [pc, #36]	; (400534 <vConfigureTimerForRunTimeStats+0x2c>)
  40050e:	4a09      	ldr	r2, [pc, #36]	; (400534 <vConfigureTimerForRunTimeStats+0x2c>)
  400510:	6812      	ldr	r2, [r2, #0]
  400512:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
  400516:	601a      	str	r2, [r3, #0]

	/* Reset counter. */
	rtsDWT_CYCCNT = 0;
  400518:	4b07      	ldr	r3, [pc, #28]	; (400538 <vConfigureTimerForRunTimeStats+0x30>)
  40051a:	2200      	movs	r2, #0
  40051c:	601a      	str	r2, [r3, #0]

	/* Enable counter. */
	rtsDWT_CONTROL = rtsDWT_CONTROL | rtsCOUNTER_ENABLE_BIT;
  40051e:	4b07      	ldr	r3, [pc, #28]	; (40053c <vConfigureTimerForRunTimeStats+0x34>)
  400520:	4a06      	ldr	r2, [pc, #24]	; (40053c <vConfigureTimerForRunTimeStats+0x34>)
  400522:	6812      	ldr	r2, [r2, #0]
  400524:	f042 0201 	orr.w	r2, r2, #1
  400528:	601a      	str	r2, [r3, #0]
}
  40052a:	46bd      	mov	sp, r7
  40052c:	f85d 7b04 	ldr.w	r7, [sp], #4
  400530:	4770      	bx	lr
  400532:	bf00      	nop
  400534:	e000edfc 	.word	0xe000edfc
  400538:	e0001004 	.word	0xe0001004
  40053c:	e0001000 	.word	0xe0001000

00400540 <ulGetRunTimeCounterValue>:
/*-----------------------------------------------------------*/

uint32_t ulGetRunTimeCounterValue( void )
{
  400540:	b480      	push	{r7}
  400542:	b083      	sub	sp, #12
  400544:	af00      	add	r7, sp, #0
static unsigned long ulLastCounterValue = 0UL, ulOverflows = 0;
unsigned long ulValueNow;

	ulValueNow = rtsDWT_CYCCNT;
  400546:	4b17      	ldr	r3, [pc, #92]	; (4005a4 <ulGetRunTimeCounterValue+0x64>)
  400548:	681b      	ldr	r3, [r3, #0]
  40054a:	607b      	str	r3, [r7, #4]

	/* Has the value overflowed since it was last read. */
	if( ulValueNow < ulLastCounterValue )
  40054c:	4b16      	ldr	r3, [pc, #88]	; (4005a8 <ulGetRunTimeCounterValue+0x68>)
  40054e:	681b      	ldr	r3, [r3, #0]
  400550:	687a      	ldr	r2, [r7, #4]
  400552:	429a      	cmp	r2, r3
  400554:	d204      	bcs.n	400560 <ulGetRunTimeCounterValue+0x20>
	{
		ulOverflows++;
  400556:	4b15      	ldr	r3, [pc, #84]	; (4005ac <ulGetRunTimeCounterValue+0x6c>)
  400558:	681b      	ldr	r3, [r3, #0]
  40055a:	1c5a      	adds	r2, r3, #1
  40055c:	4b13      	ldr	r3, [pc, #76]	; (4005ac <ulGetRunTimeCounterValue+0x6c>)
  40055e:	601a      	str	r2, [r3, #0]
	}
	ulLastCounterValue = ulValueNow;
  400560:	4b11      	ldr	r3, [pc, #68]	; (4005a8 <ulGetRunTimeCounterValue+0x68>)
  400562:	687a      	ldr	r2, [r7, #4]
  400564:	601a      	str	r2, [r3, #0]

	/* Cannot use configCPU_CLOCK_HZ directly as it may itself not be a constant
	but instead map to a variable that holds the clock speed. */

	/* There is no prescale on the counter, so simulate in software. */
	if( configCPU_CLOCK_HZ < runtimeSLOWER_CLOCK_SPEEDS )
  400566:	4b12      	ldr	r3, [pc, #72]	; (4005b0 <ulGetRunTimeCounterValue+0x70>)
  400568:	681a      	ldr	r2, [r3, #0]
  40056a:	4b12      	ldr	r3, [pc, #72]	; (4005b4 <ulGetRunTimeCounterValue+0x74>)
  40056c:	429a      	cmp	r2, r3
  40056e:	d809      	bhi.n	400584 <ulGetRunTimeCounterValue+0x44>
	{
		ulValueNow >>= runtimeSHIFT_13;
  400570:	687b      	ldr	r3, [r7, #4]
  400572:	0b5b      	lsrs	r3, r3, #13
  400574:	607b      	str	r3, [r7, #4]
		ulValueNow += ( runtimeOVERFLOW_BIT_13 * ulOverflows );
  400576:	4b0d      	ldr	r3, [pc, #52]	; (4005ac <ulGetRunTimeCounterValue+0x6c>)
  400578:	681b      	ldr	r3, [r3, #0]
  40057a:	04db      	lsls	r3, r3, #19
  40057c:	687a      	ldr	r2, [r7, #4]
  40057e:	4413      	add	r3, r2
  400580:	607b      	str	r3, [r7, #4]
  400582:	e008      	b.n	400596 <ulGetRunTimeCounterValue+0x56>
	}
	else
	{
		ulValueNow >>= runtimeSHIFT_14;
  400584:	687b      	ldr	r3, [r7, #4]
  400586:	0b9b      	lsrs	r3, r3, #14
  400588:	607b      	str	r3, [r7, #4]
		ulValueNow += ( runtimeOVERFLOW_BIT_14 * ulOverflows );
  40058a:	4b08      	ldr	r3, [pc, #32]	; (4005ac <ulGetRunTimeCounterValue+0x6c>)
  40058c:	681b      	ldr	r3, [r3, #0]
  40058e:	049b      	lsls	r3, r3, #18
  400590:	687a      	ldr	r2, [r7, #4]
  400592:	4413      	add	r3, r2
  400594:	607b      	str	r3, [r7, #4]
	}

	return ulValueNow;
  400596:	687b      	ldr	r3, [r7, #4]
}
  400598:	4618      	mov	r0, r3
  40059a:	370c      	adds	r7, #12
  40059c:	46bd      	mov	sp, r7
  40059e:	f85d 7b04 	ldr.w	r7, [sp], #4
  4005a2:	4770      	bx	lr
  4005a4:	e0001004 	.word	0xe0001004
  4005a8:	2000045c 	.word	0x2000045c
  4005ac:	20000460 	.word	0x20000460
  4005b0:	20000000 	.word	0x20000000
  4005b4:	042c1d7f 	.word	0x042c1d7f

004005b8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
  4005b8:	b480      	push	{r7}
  4005ba:	b083      	sub	sp, #12
  4005bc:	af00      	add	r7, sp, #0
  4005be:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  4005c0:	687b      	ldr	r3, [r7, #4]
  4005c2:	f103 0208 	add.w	r2, r3, #8
  4005c6:	687b      	ldr	r3, [r7, #4]
  4005c8:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  4005ca:	687b      	ldr	r3, [r7, #4]
  4005cc:	f04f 32ff 	mov.w	r2, #4294967295
  4005d0:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  4005d2:	687b      	ldr	r3, [r7, #4]
  4005d4:	f103 0208 	add.w	r2, r3, #8
  4005d8:	687b      	ldr	r3, [r7, #4]
  4005da:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  4005dc:	687b      	ldr	r3, [r7, #4]
  4005de:	f103 0208 	add.w	r2, r3, #8
  4005e2:	687b      	ldr	r3, [r7, #4]
  4005e4:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
  4005e6:	687b      	ldr	r3, [r7, #4]
  4005e8:	2200      	movs	r2, #0
  4005ea:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
  4005ec:	370c      	adds	r7, #12
  4005ee:	46bd      	mov	sp, r7
  4005f0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4005f4:	4770      	bx	lr
  4005f6:	bf00      	nop

004005f8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
  4005f8:	b480      	push	{r7}
  4005fa:	b083      	sub	sp, #12
  4005fc:	af00      	add	r7, sp, #0
  4005fe:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
  400600:	687b      	ldr	r3, [r7, #4]
  400602:	2200      	movs	r2, #0
  400604:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
  400606:	370c      	adds	r7, #12
  400608:	46bd      	mov	sp, r7
  40060a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40060e:	4770      	bx	lr

00400610 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
  400610:	b480      	push	{r7}
  400612:	b085      	sub	sp, #20
  400614:	af00      	add	r7, sp, #0
  400616:	6078      	str	r0, [r7, #4]
  400618:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
  40061a:	687b      	ldr	r3, [r7, #4]
  40061c:	685b      	ldr	r3, [r3, #4]
  40061e:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
  400620:	683b      	ldr	r3, [r7, #0]
  400622:	68fa      	ldr	r2, [r7, #12]
  400624:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
  400626:	68fb      	ldr	r3, [r7, #12]
  400628:	689a      	ldr	r2, [r3, #8]
  40062a:	683b      	ldr	r3, [r7, #0]
  40062c:	609a      	str	r2, [r3, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
  40062e:	68fb      	ldr	r3, [r7, #12]
  400630:	689b      	ldr	r3, [r3, #8]
  400632:	683a      	ldr	r2, [r7, #0]
  400634:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
  400636:	68fb      	ldr	r3, [r7, #12]
  400638:	683a      	ldr	r2, [r7, #0]
  40063a:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  40063c:	683b      	ldr	r3, [r7, #0]
  40063e:	687a      	ldr	r2, [r7, #4]
  400640:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
  400642:	687b      	ldr	r3, [r7, #4]
  400644:	681b      	ldr	r3, [r3, #0]
  400646:	1c5a      	adds	r2, r3, #1
  400648:	687b      	ldr	r3, [r7, #4]
  40064a:	601a      	str	r2, [r3, #0]
}
  40064c:	3714      	adds	r7, #20
  40064e:	46bd      	mov	sp, r7
  400650:	f85d 7b04 	ldr.w	r7, [sp], #4
  400654:	4770      	bx	lr
  400656:	bf00      	nop

00400658 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
  400658:	b480      	push	{r7}
  40065a:	b085      	sub	sp, #20
  40065c:	af00      	add	r7, sp, #0
  40065e:	6078      	str	r0, [r7, #4]
  400660:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
  400662:	683b      	ldr	r3, [r7, #0]
  400664:	681b      	ldr	r3, [r3, #0]
  400666:	60bb      	str	r3, [r7, #8]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
  400668:	68bb      	ldr	r3, [r7, #8]
  40066a:	f1b3 3fff 	cmp.w	r3, #4294967295
  40066e:	d103      	bne.n	400678 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
  400670:	687b      	ldr	r3, [r7, #4]
  400672:	691b      	ldr	r3, [r3, #16]
  400674:	60fb      	str	r3, [r7, #12]
  400676:	e00c      	b.n	400692 <vListInsert+0x3a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  400678:	687b      	ldr	r3, [r7, #4]
  40067a:	3308      	adds	r3, #8
  40067c:	60fb      	str	r3, [r7, #12]
  40067e:	e002      	b.n	400686 <vListInsert+0x2e>
  400680:	68fb      	ldr	r3, [r7, #12]
  400682:	685b      	ldr	r3, [r3, #4]
  400684:	60fb      	str	r3, [r7, #12]
  400686:	68fb      	ldr	r3, [r7, #12]
  400688:	685b      	ldr	r3, [r3, #4]
  40068a:	681a      	ldr	r2, [r3, #0]
  40068c:	68bb      	ldr	r3, [r7, #8]
  40068e:	429a      	cmp	r2, r3
  400690:	d9f6      	bls.n	400680 <vListInsert+0x28>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
  400692:	68fb      	ldr	r3, [r7, #12]
  400694:	685a      	ldr	r2, [r3, #4]
  400696:	683b      	ldr	r3, [r7, #0]
  400698:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
  40069a:	683b      	ldr	r3, [r7, #0]
  40069c:	685b      	ldr	r3, [r3, #4]
  40069e:	683a      	ldr	r2, [r7, #0]
  4006a0:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
  4006a2:	683b      	ldr	r3, [r7, #0]
  4006a4:	68fa      	ldr	r2, [r7, #12]
  4006a6:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
  4006a8:	68fb      	ldr	r3, [r7, #12]
  4006aa:	683a      	ldr	r2, [r7, #0]
  4006ac:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  4006ae:	683b      	ldr	r3, [r7, #0]
  4006b0:	687a      	ldr	r2, [r7, #4]
  4006b2:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
  4006b4:	687b      	ldr	r3, [r7, #4]
  4006b6:	681b      	ldr	r3, [r3, #0]
  4006b8:	1c5a      	adds	r2, r3, #1
  4006ba:	687b      	ldr	r3, [r7, #4]
  4006bc:	601a      	str	r2, [r3, #0]
}
  4006be:	3714      	adds	r7, #20
  4006c0:	46bd      	mov	sp, r7
  4006c2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4006c6:	4770      	bx	lr

004006c8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
  4006c8:	b480      	push	{r7}
  4006ca:	b085      	sub	sp, #20
  4006cc:	af00      	add	r7, sp, #0
  4006ce:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
  4006d0:	687b      	ldr	r3, [r7, #4]
  4006d2:	691b      	ldr	r3, [r3, #16]
  4006d4:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  4006d6:	687b      	ldr	r3, [r7, #4]
  4006d8:	685b      	ldr	r3, [r3, #4]
  4006da:	687a      	ldr	r2, [r7, #4]
  4006dc:	6892      	ldr	r2, [r2, #8]
  4006de:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  4006e0:	687b      	ldr	r3, [r7, #4]
  4006e2:	689b      	ldr	r3, [r3, #8]
  4006e4:	687a      	ldr	r2, [r7, #4]
  4006e6:	6852      	ldr	r2, [r2, #4]
  4006e8:	605a      	str	r2, [r3, #4]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  4006ea:	68fb      	ldr	r3, [r7, #12]
  4006ec:	685a      	ldr	r2, [r3, #4]
  4006ee:	687b      	ldr	r3, [r7, #4]
  4006f0:	429a      	cmp	r2, r3
  4006f2:	d103      	bne.n	4006fc <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  4006f4:	687b      	ldr	r3, [r7, #4]
  4006f6:	689a      	ldr	r2, [r3, #8]
  4006f8:	68fb      	ldr	r3, [r7, #12]
  4006fa:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
  4006fc:	687b      	ldr	r3, [r7, #4]
  4006fe:	2200      	movs	r2, #0
  400700:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
  400702:	68fb      	ldr	r3, [r7, #12]
  400704:	681b      	ldr	r3, [r3, #0]
  400706:	1e5a      	subs	r2, r3, #1
  400708:	68fb      	ldr	r3, [r7, #12]
  40070a:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
  40070c:	68fb      	ldr	r3, [r7, #12]
  40070e:	681b      	ldr	r3, [r3, #0]
}
  400710:	4618      	mov	r0, r3
  400712:	3714      	adds	r7, #20
  400714:	46bd      	mov	sp, r7
  400716:	f85d 7b04 	ldr.w	r7, [sp], #4
  40071a:	4770      	bx	lr

0040071c <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
  40071c:	b480      	push	{r7}
  40071e:	b085      	sub	sp, #20
  400720:	af00      	add	r7, sp, #0
  400722:	60f8      	str	r0, [r7, #12]
  400724:	60b9      	str	r1, [r7, #8]
  400726:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;
  400728:	68fb      	ldr	r3, [r7, #12]
  40072a:	3b04      	subs	r3, #4
  40072c:	60fb      	str	r3, [r7, #12]

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
  40072e:	68fb      	ldr	r3, [r7, #12]
  400730:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
  400734:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
  400736:	68fb      	ldr	r3, [r7, #12]
  400738:	3b04      	subs	r3, #4
  40073a:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
  40073c:	68ba      	ldr	r2, [r7, #8]
  40073e:	68fb      	ldr	r3, [r7, #12]
  400740:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
  400742:	68fb      	ldr	r3, [r7, #12]
  400744:	3b04      	subs	r3, #4
  400746:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
  400748:	4a0c      	ldr	r2, [pc, #48]	; (40077c <pxPortInitialiseStack+0x60>)
  40074a:	68fb      	ldr	r3, [r7, #12]
  40074c:	601a      	str	r2, [r3, #0]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
  40074e:	68fb      	ldr	r3, [r7, #12]
  400750:	3b14      	subs	r3, #20
  400752:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
  400754:	687a      	ldr	r2, [r7, #4]
  400756:	68fb      	ldr	r3, [r7, #12]
  400758:	601a      	str	r2, [r3, #0]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
  40075a:	68fb      	ldr	r3, [r7, #12]
  40075c:	3b04      	subs	r3, #4
  40075e:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
  400760:	68fb      	ldr	r3, [r7, #12]
  400762:	f06f 0202 	mvn.w	r2, #2
  400766:	601a      	str	r2, [r3, #0]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
  400768:	68fb      	ldr	r3, [r7, #12]
  40076a:	3b20      	subs	r3, #32
  40076c:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
  40076e:	68fb      	ldr	r3, [r7, #12]
}
  400770:	4618      	mov	r0, r3
  400772:	3714      	adds	r7, #20
  400774:	46bd      	mov	sp, r7
  400776:	f85d 7b04 	ldr.w	r7, [sp], #4
  40077a:	4770      	bx	lr
  40077c:	00400781 	.word	0x00400781

00400780 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
  400780:	b580      	push	{r7, lr}
  400782:	b082      	sub	sp, #8
  400784:	af00      	add	r7, sp, #0
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
  400786:	4b0a      	ldr	r3, [pc, #40]	; (4007b0 <prvTaskExitError+0x30>)
  400788:	681b      	ldr	r3, [r3, #0]
  40078a:	f1b3 3fff 	cmp.w	r3, #4294967295
  40078e:	d004      	beq.n	40079a <prvTaskExitError+0x1a>
  400790:	f240 1001 	movw	r0, #257	; 0x101
  400794:	4907      	ldr	r1, [pc, #28]	; (4007b4 <prvTaskExitError+0x34>)
  400796:	4b08      	ldr	r3, [pc, #32]	; (4007b8 <prvTaskExitError+0x38>)
  400798:	4798      	blx	r3

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
  40079a:	f04f 0350 	mov.w	r3, #80	; 0x50
  40079e:	f383 8811 	msr	BASEPRI, r3
  4007a2:	f3bf 8f6f 	isb	sy
  4007a6:	f3bf 8f4f 	dsb	sy
  4007aa:	607b      	str	r3, [r7, #4]
	portDISABLE_INTERRUPTS();
	for( ;; );
  4007ac:	e7fe      	b.n	4007ac <prvTaskExitError+0x2c>
  4007ae:	bf00      	nop
  4007b0:	20000004 	.word	0x20000004
  4007b4:	00404574 	.word	0x00404574
  4007b8:	004004d1 	.word	0x004004d1

004007bc <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
  4007bc:	4b06      	ldr	r3, [pc, #24]	; (4007d8 <pxCurrentTCBConst2>)
  4007be:	6819      	ldr	r1, [r3, #0]
  4007c0:	6808      	ldr	r0, [r1, #0]
  4007c2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4007c6:	f380 8809 	msr	PSP, r0
  4007ca:	f3bf 8f6f 	isb	sy
  4007ce:	f04f 0000 	mov.w	r0, #0
  4007d2:	f380 8811 	msr	BASEPRI, r0
  4007d6:	4770      	bx	lr

004007d8 <pxCurrentTCBConst2>:
  4007d8:	2000c090 	.word	0x2000c090

004007dc <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
  4007dc:	4806      	ldr	r0, [pc, #24]	; (4007f8 <prvPortStartFirstTask+0x1c>)
  4007de:	6800      	ldr	r0, [r0, #0]
  4007e0:	6800      	ldr	r0, [r0, #0]
  4007e2:	f380 8808 	msr	MSP, r0
  4007e6:	b662      	cpsie	i
  4007e8:	b661      	cpsie	f
  4007ea:	f3bf 8f4f 	dsb	sy
  4007ee:	f3bf 8f6f 	isb	sy
  4007f2:	df00      	svc	0
  4007f4:	bf00      	nop
  4007f6:	0000      	.short	0x0000
  4007f8:	e000ed08 	.word	0xe000ed08

004007fc <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
  4007fc:	b580      	push	{r7, lr}
  4007fe:	b084      	sub	sp, #16
  400800:	af00      	add	r7, sp, #0
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	#if( configASSERT_DEFINED == 1 )
	{
		volatile uint32_t ulOriginalPriority;
		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
  400802:	4b2c      	ldr	r3, [pc, #176]	; (4008b4 <xPortStartScheduler+0xb8>)
  400804:	60fb      	str	r3, [r7, #12]
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
  400806:	68fb      	ldr	r3, [r7, #12]
  400808:	781b      	ldrb	r3, [r3, #0]
  40080a:	b2db      	uxtb	r3, r3
  40080c:	60bb      	str	r3, [r7, #8]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
  40080e:	68fb      	ldr	r3, [r7, #12]
  400810:	22ff      	movs	r2, #255	; 0xff
  400812:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
  400814:	68fb      	ldr	r3, [r7, #12]
  400816:	781b      	ldrb	r3, [r3, #0]
  400818:	b2db      	uxtb	r3, r3
  40081a:	71fb      	strb	r3, [r7, #7]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
  40081c:	79fb      	ldrb	r3, [r7, #7]
  40081e:	b2db      	uxtb	r3, r3
  400820:	f003 0350 	and.w	r3, r3, #80	; 0x50
  400824:	b2da      	uxtb	r2, r3
  400826:	4b24      	ldr	r3, [pc, #144]	; (4008b8 <xPortStartScheduler+0xbc>)
  400828:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
  40082a:	4b24      	ldr	r3, [pc, #144]	; (4008bc <xPortStartScheduler+0xc0>)
  40082c:	2207      	movs	r2, #7
  40082e:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
  400830:	e009      	b.n	400846 <xPortStartScheduler+0x4a>
		{
			ulMaxPRIGROUPValue--;
  400832:	4b22      	ldr	r3, [pc, #136]	; (4008bc <xPortStartScheduler+0xc0>)
  400834:	681b      	ldr	r3, [r3, #0]
  400836:	1e5a      	subs	r2, r3, #1
  400838:	4b20      	ldr	r3, [pc, #128]	; (4008bc <xPortStartScheduler+0xc0>)
  40083a:	601a      	str	r2, [r3, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
  40083c:	79fb      	ldrb	r3, [r7, #7]
  40083e:	b2db      	uxtb	r3, r3
  400840:	005b      	lsls	r3, r3, #1
  400842:	b2db      	uxtb	r3, r3
  400844:	71fb      	strb	r3, [r7, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
  400846:	79fb      	ldrb	r3, [r7, #7]
  400848:	b2db      	uxtb	r3, r3
  40084a:	b2db      	uxtb	r3, r3
  40084c:	b25b      	sxtb	r3, r3
  40084e:	2b00      	cmp	r3, #0
  400850:	dbef      	blt.n	400832 <xPortStartScheduler+0x36>
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
		}

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
  400852:	4b1a      	ldr	r3, [pc, #104]	; (4008bc <xPortStartScheduler+0xc0>)
  400854:	681b      	ldr	r3, [r3, #0]
  400856:	021a      	lsls	r2, r3, #8
  400858:	4b18      	ldr	r3, [pc, #96]	; (4008bc <xPortStartScheduler+0xc0>)
  40085a:	601a      	str	r2, [r3, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
  40085c:	4b17      	ldr	r3, [pc, #92]	; (4008bc <xPortStartScheduler+0xc0>)
  40085e:	681b      	ldr	r3, [r3, #0]
  400860:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
  400864:	4b15      	ldr	r3, [pc, #84]	; (4008bc <xPortStartScheduler+0xc0>)
  400866:	601a      	str	r2, [r3, #0]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
  400868:	68bb      	ldr	r3, [r7, #8]
  40086a:	b2da      	uxtb	r2, r3
  40086c:	68fb      	ldr	r3, [r7, #12]
  40086e:	701a      	strb	r2, [r3, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
  400870:	4b13      	ldr	r3, [pc, #76]	; (4008c0 <xPortStartScheduler+0xc4>)
  400872:	4a13      	ldr	r2, [pc, #76]	; (4008c0 <xPortStartScheduler+0xc4>)
  400874:	6812      	ldr	r2, [r2, #0]
  400876:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
  40087a:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
  40087c:	4b10      	ldr	r3, [pc, #64]	; (4008c0 <xPortStartScheduler+0xc4>)
  40087e:	4a10      	ldr	r2, [pc, #64]	; (4008c0 <xPortStartScheduler+0xc4>)
  400880:	6812      	ldr	r2, [r2, #0]
  400882:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
  400886:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
  400888:	4b0e      	ldr	r3, [pc, #56]	; (4008c4 <xPortStartScheduler+0xc8>)
  40088a:	4798      	blx	r3

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
  40088c:	4b0e      	ldr	r3, [pc, #56]	; (4008c8 <xPortStartScheduler+0xcc>)
  40088e:	2200      	movs	r2, #0
  400890:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
  400892:	4b0e      	ldr	r3, [pc, #56]	; (4008cc <xPortStartScheduler+0xd0>)
  400894:	4798      	blx	r3

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
  400896:	4b0e      	ldr	r3, [pc, #56]	; (4008d0 <xPortStartScheduler+0xd4>)
  400898:	4a0d      	ldr	r2, [pc, #52]	; (4008d0 <xPortStartScheduler+0xd4>)
  40089a:	6812      	ldr	r2, [r2, #0]
  40089c:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
  4008a0:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
  4008a2:	4b0c      	ldr	r3, [pc, #48]	; (4008d4 <xPortStartScheduler+0xd8>)
  4008a4:	4798      	blx	r3

	/* Should never get here as the tasks will now be executing!  Call the task
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS. */
	prvTaskExitError();
  4008a6:	4b0c      	ldr	r3, [pc, #48]	; (4008d8 <xPortStartScheduler+0xdc>)
  4008a8:	4798      	blx	r3

	/* Should not get here! */
	return 0;
  4008aa:	2300      	movs	r3, #0
}
  4008ac:	4618      	mov	r0, r3
  4008ae:	3710      	adds	r7, #16
  4008b0:	46bd      	mov	sp, r7
  4008b2:	bd80      	pop	{r7, pc}
  4008b4:	e000e400 	.word	0xe000e400
  4008b8:	20000470 	.word	0x20000470
  4008bc:	20000474 	.word	0x20000474
  4008c0:	e000ed20 	.word	0xe000ed20
  4008c4:	00400ba9 	.word	0x00400ba9
  4008c8:	20000004 	.word	0x20000004
  4008cc:	00400c21 	.word	0x00400c21
  4008d0:	e000ef34 	.word	0xe000ef34
  4008d4:	004007dd 	.word	0x004007dd
  4008d8:	00400781 	.word	0x00400781

004008dc <vPortEnterCritical>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
  4008dc:	b580      	push	{r7, lr}
  4008de:	b082      	sub	sp, #8
  4008e0:	af00      	add	r7, sp, #0
  4008e2:	f04f 0350 	mov.w	r3, #80	; 0x50
  4008e6:	f383 8811 	msr	BASEPRI, r3
  4008ea:	f3bf 8f6f 	isb	sy
  4008ee:	f3bf 8f4f 	dsb	sy
  4008f2:	607b      	str	r3, [r7, #4]
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
  4008f4:	4b0a      	ldr	r3, [pc, #40]	; (400920 <vPortEnterCritical+0x44>)
  4008f6:	681b      	ldr	r3, [r3, #0]
  4008f8:	1c5a      	adds	r2, r3, #1
  4008fa:	4b09      	ldr	r3, [pc, #36]	; (400920 <vPortEnterCritical+0x44>)
  4008fc:	601a      	str	r2, [r3, #0]
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
  4008fe:	4b08      	ldr	r3, [pc, #32]	; (400920 <vPortEnterCritical+0x44>)
  400900:	681b      	ldr	r3, [r3, #0]
  400902:	2b01      	cmp	r3, #1
  400904:	d109      	bne.n	40091a <vPortEnterCritical+0x3e>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
  400906:	4b07      	ldr	r3, [pc, #28]	; (400924 <vPortEnterCritical+0x48>)
  400908:	681b      	ldr	r3, [r3, #0]
  40090a:	b2db      	uxtb	r3, r3
  40090c:	2b00      	cmp	r3, #0
  40090e:	d004      	beq.n	40091a <vPortEnterCritical+0x3e>
  400910:	f240 1093 	movw	r0, #403	; 0x193
  400914:	4904      	ldr	r1, [pc, #16]	; (400928 <vPortEnterCritical+0x4c>)
  400916:	4b05      	ldr	r3, [pc, #20]	; (40092c <vPortEnterCritical+0x50>)
  400918:	4798      	blx	r3
	}
}
  40091a:	3708      	adds	r7, #8
  40091c:	46bd      	mov	sp, r7
  40091e:	bd80      	pop	{r7, pc}
  400920:	20000004 	.word	0x20000004
  400924:	e000ed04 	.word	0xe000ed04
  400928:	00404574 	.word	0x00404574
  40092c:	004004d1 	.word	0x004004d1

00400930 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
  400930:	b580      	push	{r7, lr}
  400932:	b082      	sub	sp, #8
  400934:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
  400936:	4b0d      	ldr	r3, [pc, #52]	; (40096c <vPortExitCritical+0x3c>)
  400938:	681b      	ldr	r3, [r3, #0]
  40093a:	2b00      	cmp	r3, #0
  40093c:	d104      	bne.n	400948 <vPortExitCritical+0x18>
  40093e:	f44f 70cd 	mov.w	r0, #410	; 0x19a
  400942:	490b      	ldr	r1, [pc, #44]	; (400970 <vPortExitCritical+0x40>)
  400944:	4b0b      	ldr	r3, [pc, #44]	; (400974 <vPortExitCritical+0x44>)
  400946:	4798      	blx	r3
	uxCriticalNesting--;
  400948:	4b08      	ldr	r3, [pc, #32]	; (40096c <vPortExitCritical+0x3c>)
  40094a:	681b      	ldr	r3, [r3, #0]
  40094c:	1e5a      	subs	r2, r3, #1
  40094e:	4b07      	ldr	r3, [pc, #28]	; (40096c <vPortExitCritical+0x3c>)
  400950:	601a      	str	r2, [r3, #0]
	if( uxCriticalNesting == 0 )
  400952:	4b06      	ldr	r3, [pc, #24]	; (40096c <vPortExitCritical+0x3c>)
  400954:	681b      	ldr	r3, [r3, #0]
  400956:	2b00      	cmp	r3, #0
  400958:	d104      	bne.n	400964 <vPortExitCritical+0x34>
  40095a:	2300      	movs	r3, #0
  40095c:	607b      	str	r3, [r7, #4]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
  40095e:	687b      	ldr	r3, [r7, #4]
  400960:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
  400964:	3708      	adds	r7, #8
  400966:	46bd      	mov	sp, r7
  400968:	bd80      	pop	{r7, pc}
  40096a:	bf00      	nop
  40096c:	20000004 	.word	0x20000004
  400970:	00404574 	.word	0x00404574
  400974:	004004d1 	.word	0x004004d1

00400978 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
  400978:	f3ef 8009 	mrs	r0, PSP
  40097c:	f3bf 8f6f 	isb	sy
  400980:	4b14      	ldr	r3, [pc, #80]	; (4009d4 <pxCurrentTCBConst>)
  400982:	681a      	ldr	r2, [r3, #0]
  400984:	f01e 0f10 	tst.w	lr, #16
  400988:	bf08      	it	eq
  40098a:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
  40098e:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  400992:	6010      	str	r0, [r2, #0]
  400994:	f84d 3d04 	str.w	r3, [sp, #-4]!
  400998:	f04f 0050 	mov.w	r0, #80	; 0x50
  40099c:	f380 8811 	msr	BASEPRI, r0
  4009a0:	f3bf 8f4f 	dsb	sy
  4009a4:	f3bf 8f6f 	isb	sy
  4009a8:	f001 fc9c 	bl	4022e4 <vTaskSwitchContext>
  4009ac:	f04f 0000 	mov.w	r0, #0
  4009b0:	f380 8811 	msr	BASEPRI, r0
  4009b4:	bc08      	pop	{r3}
  4009b6:	6819      	ldr	r1, [r3, #0]
  4009b8:	6808      	ldr	r0, [r1, #0]
  4009ba:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4009be:	f01e 0f10 	tst.w	lr, #16
  4009c2:	bf08      	it	eq
  4009c4:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
  4009c8:	f380 8809 	msr	PSP, r0
  4009cc:	f3bf 8f6f 	isb	sy
  4009d0:	4770      	bx	lr
  4009d2:	bf00      	nop

004009d4 <pxCurrentTCBConst>:
  4009d4:	2000c090 	.word	0x2000c090

004009d8 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
  4009d8:	b580      	push	{r7, lr}
  4009da:	b084      	sub	sp, #16
  4009dc:	af00      	add	r7, sp, #0

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
  4009de:	f3ef 8211 	mrs	r2, BASEPRI
  4009e2:	f04f 0350 	mov.w	r3, #80	; 0x50
  4009e6:	f383 8811 	msr	BASEPRI, r3
  4009ea:	f3bf 8f6f 	isb	sy
  4009ee:	f3bf 8f4f 	dsb	sy
  4009f2:	60fa      	str	r2, [r7, #12]
  4009f4:	60bb      	str	r3, [r7, #8]
	save and then restore the interrupt mask value as its value is already
	known. */
	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
  4009f6:	4b08      	ldr	r3, [pc, #32]	; (400a18 <SysTick_Handler+0x40>)
  4009f8:	4798      	blx	r3
  4009fa:	4603      	mov	r3, r0
  4009fc:	2b00      	cmp	r3, #0
  4009fe:	d003      	beq.n	400a08 <SysTick_Handler+0x30>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  400a00:	4b06      	ldr	r3, [pc, #24]	; (400a1c <SysTick_Handler+0x44>)
  400a02:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  400a06:	601a      	str	r2, [r3, #0]
  400a08:	2300      	movs	r3, #0
  400a0a:	607b      	str	r3, [r7, #4]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
  400a0c:	687b      	ldr	r3, [r7, #4]
  400a0e:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
}
  400a12:	3710      	adds	r7, #16
  400a14:	46bd      	mov	sp, r7
  400a16:	bd80      	pop	{r7, pc}
  400a18:	00402161 	.word	0x00402161
  400a1c:	e000ed04 	.word	0xe000ed04

00400a20 <vPortSuppressTicksAndSleep>:
/*-----------------------------------------------------------*/

#if configUSE_TICKLESS_IDLE == 1

	__attribute__((weak)) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
	{
  400a20:	b580      	push	{r7, lr}
  400a22:	b088      	sub	sp, #32
  400a24:	af00      	add	r7, sp, #0
  400a26:	6078      	str	r0, [r7, #4]
	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements, ulSysTickCTRL;
	TickType_t xModifiableIdleTime;

		/* Make sure the SysTick reload value does not overflow the counter. */
		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
  400a28:	4b55      	ldr	r3, [pc, #340]	; (400b80 <vPortSuppressTicksAndSleep+0x160>)
  400a2a:	681b      	ldr	r3, [r3, #0]
  400a2c:	687a      	ldr	r2, [r7, #4]
  400a2e:	429a      	cmp	r2, r3
  400a30:	d902      	bls.n	400a38 <vPortSuppressTicksAndSleep+0x18>
		{
			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
  400a32:	4b53      	ldr	r3, [pc, #332]	; (400b80 <vPortSuppressTicksAndSleep+0x160>)
  400a34:	681b      	ldr	r3, [r3, #0]
  400a36:	607b      	str	r3, [r7, #4]

		/* Stop the SysTick momentarily.  The time the SysTick is stopped for
		is accounted for as best it can be, but using the tickless mode will
		inevitably result in some tiny drift of the time maintained by the
		kernel with respect to calendar time. */
		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
  400a38:	4b52      	ldr	r3, [pc, #328]	; (400b84 <vPortSuppressTicksAndSleep+0x164>)
  400a3a:	4a52      	ldr	r2, [pc, #328]	; (400b84 <vPortSuppressTicksAndSleep+0x164>)
  400a3c:	6812      	ldr	r2, [r2, #0]
  400a3e:	f022 0201 	bic.w	r2, r2, #1
  400a42:	601a      	str	r2, [r3, #0]

		/* Calculate the reload value required to wait xExpectedIdleTime
		tick periods.  -1 is used because this code will execute part way
		through one of the tick periods. */
		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
  400a44:	4b50      	ldr	r3, [pc, #320]	; (400b88 <vPortSuppressTicksAndSleep+0x168>)
  400a46:	681a      	ldr	r2, [r3, #0]
  400a48:	687b      	ldr	r3, [r7, #4]
  400a4a:	3b01      	subs	r3, #1
  400a4c:	494f      	ldr	r1, [pc, #316]	; (400b8c <vPortSuppressTicksAndSleep+0x16c>)
  400a4e:	6809      	ldr	r1, [r1, #0]
  400a50:	fb01 f303 	mul.w	r3, r1, r3
  400a54:	4413      	add	r3, r2
  400a56:	61fb      	str	r3, [r7, #28]
		if( ulReloadValue > ulStoppedTimerCompensation )
  400a58:	4b4d      	ldr	r3, [pc, #308]	; (400b90 <vPortSuppressTicksAndSleep+0x170>)
  400a5a:	681b      	ldr	r3, [r3, #0]
  400a5c:	69fa      	ldr	r2, [r7, #28]
  400a5e:	429a      	cmp	r2, r3
  400a60:	d904      	bls.n	400a6c <vPortSuppressTicksAndSleep+0x4c>
		{
			ulReloadValue -= ulStoppedTimerCompensation;
  400a62:	4b4b      	ldr	r3, [pc, #300]	; (400b90 <vPortSuppressTicksAndSleep+0x170>)
  400a64:	681b      	ldr	r3, [r3, #0]
  400a66:	69fa      	ldr	r2, [r7, #28]
  400a68:	1ad3      	subs	r3, r2, r3
  400a6a:	61fb      	str	r3, [r7, #28]
		}

		/* Enter a critical section but don't use the taskENTER_CRITICAL()
		method as that will mask interrupts that should exit sleep mode. */
		__asm volatile( "cpsid i" );
  400a6c:	b672      	cpsid	i

		/* If a context switch is pending or a task is waiting for the scheduler
		to be unsuspended then abandon the low power entry. */
		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
  400a6e:	4b49      	ldr	r3, [pc, #292]	; (400b94 <vPortSuppressTicksAndSleep+0x174>)
  400a70:	4798      	blx	r3
  400a72:	4603      	mov	r3, r0
  400a74:	2b00      	cmp	r3, #0
  400a76:	d110      	bne.n	400a9a <vPortSuppressTicksAndSleep+0x7a>
		{
			/* Restart from whatever is left in the count register to complete
			this tick period. */
			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
  400a78:	4b47      	ldr	r3, [pc, #284]	; (400b98 <vPortSuppressTicksAndSleep+0x178>)
  400a7a:	4a43      	ldr	r2, [pc, #268]	; (400b88 <vPortSuppressTicksAndSleep+0x168>)
  400a7c:	6812      	ldr	r2, [r2, #0]
  400a7e:	601a      	str	r2, [r3, #0]

			/* Restart SysTick. */
			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
  400a80:	4b40      	ldr	r3, [pc, #256]	; (400b84 <vPortSuppressTicksAndSleep+0x164>)
  400a82:	4a40      	ldr	r2, [pc, #256]	; (400b84 <vPortSuppressTicksAndSleep+0x164>)
  400a84:	6812      	ldr	r2, [r2, #0]
  400a86:	f042 0201 	orr.w	r2, r2, #1
  400a8a:	601a      	str	r2, [r3, #0]

			/* Reset the reload register to the value required for normal tick
			periods. */
			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
  400a8c:	4b42      	ldr	r3, [pc, #264]	; (400b98 <vPortSuppressTicksAndSleep+0x178>)
  400a8e:	4a3f      	ldr	r2, [pc, #252]	; (400b8c <vPortSuppressTicksAndSleep+0x16c>)
  400a90:	6812      	ldr	r2, [r2, #0]
  400a92:	3a01      	subs	r2, #1
  400a94:	601a      	str	r2, [r3, #0]

			/* Re-enable interrupts - see comments above the cpsid instruction()
			above. */
			__asm volatile( "cpsie i" );
  400a96:	b662      	cpsie	i
  400a98:	e06f      	b.n	400b7a <vPortSuppressTicksAndSleep+0x15a>
		}
		else
		{
			/* Set the new reload value. */
			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
  400a9a:	4b3f      	ldr	r3, [pc, #252]	; (400b98 <vPortSuppressTicksAndSleep+0x178>)
  400a9c:	69fa      	ldr	r2, [r7, #28]
  400a9e:	601a      	str	r2, [r3, #0]

			/* Clear the SysTick count flag and set the count value back to
			zero. */
			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
  400aa0:	4b39      	ldr	r3, [pc, #228]	; (400b88 <vPortSuppressTicksAndSleep+0x168>)
  400aa2:	2200      	movs	r2, #0
  400aa4:	601a      	str	r2, [r3, #0]

			/* Restart SysTick. */
			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
  400aa6:	4b37      	ldr	r3, [pc, #220]	; (400b84 <vPortSuppressTicksAndSleep+0x164>)
  400aa8:	4a36      	ldr	r2, [pc, #216]	; (400b84 <vPortSuppressTicksAndSleep+0x164>)
  400aaa:	6812      	ldr	r2, [r2, #0]
  400aac:	f042 0201 	orr.w	r2, r2, #1
  400ab0:	601a      	str	r2, [r3, #0]
			/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
			set its parameter to 0 to indicate that its implementation contains
			its own wait for interrupt or wait for event instruction, and so wfi
			should not be executed again.  However, the original expected idle
			time variable must remain unmodified, so a copy is taken. */
			xModifiableIdleTime = xExpectedIdleTime;
  400ab2:	687b      	ldr	r3, [r7, #4]
  400ab4:	613b      	str	r3, [r7, #16]
			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
			if( xModifiableIdleTime > 0 )
  400ab6:	693b      	ldr	r3, [r7, #16]
  400ab8:	2b00      	cmp	r3, #0
  400aba:	d004      	beq.n	400ac6 <vPortSuppressTicksAndSleep+0xa6>
			{
				__asm volatile( "dsb" );
  400abc:	f3bf 8f4f 	dsb	sy
				__asm volatile( "wfi" );
  400ac0:	bf30      	wfi
				__asm volatile( "isb" );
  400ac2:	f3bf 8f6f 	isb	sy

			/* Stop SysTick.  Again, the time the SysTick is stopped for is
			accounted for as best it can be, but using the tickless mode will
			inevitably result in some tiny drift of the time maintained by the
			kernel with respect to calendar time. */
			ulSysTickCTRL = portNVIC_SYSTICK_CTRL_REG;
  400ac6:	4b2f      	ldr	r3, [pc, #188]	; (400b84 <vPortSuppressTicksAndSleep+0x164>)
  400ac8:	681b      	ldr	r3, [r3, #0]
  400aca:	60fb      	str	r3, [r7, #12]
			portNVIC_SYSTICK_CTRL_REG = ( ulSysTickCTRL & ~portNVIC_SYSTICK_ENABLE_BIT );
  400acc:	4b2d      	ldr	r3, [pc, #180]	; (400b84 <vPortSuppressTicksAndSleep+0x164>)
  400ace:	68fa      	ldr	r2, [r7, #12]
  400ad0:	f022 0201 	bic.w	r2, r2, #1
  400ad4:	601a      	str	r2, [r3, #0]

			/* Re-enable interrupts - see comments above the cpsid instruction()
			above. */
			__asm volatile( "cpsie i" );
  400ad6:	b662      	cpsie	i

			if( ( ulSysTickCTRL & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
  400ad8:	68fb      	ldr	r3, [r7, #12]
  400ada:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  400ade:	2b00      	cmp	r3, #0
  400ae0:	d01d      	beq.n	400b1e <vPortSuppressTicksAndSleep+0xfe>

				/* The tick interrupt has already executed, and the SysTick
				count reloaded with ulReloadValue.  Reset the
				portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
				period. */
				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
  400ae2:	4b2a      	ldr	r3, [pc, #168]	; (400b8c <vPortSuppressTicksAndSleep+0x16c>)
  400ae4:	681a      	ldr	r2, [r3, #0]
  400ae6:	4b28      	ldr	r3, [pc, #160]	; (400b88 <vPortSuppressTicksAndSleep+0x168>)
  400ae8:	6819      	ldr	r1, [r3, #0]
  400aea:	69fb      	ldr	r3, [r7, #28]
  400aec:	1acb      	subs	r3, r1, r3
  400aee:	4413      	add	r3, r2
  400af0:	3b01      	subs	r3, #1
  400af2:	617b      	str	r3, [r7, #20]

				/* Don't allow a tiny value, or values that have somehow
				underflowed because the post sleep hook did something
				that took too long. */
				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
  400af4:	4b26      	ldr	r3, [pc, #152]	; (400b90 <vPortSuppressTicksAndSleep+0x170>)
  400af6:	681b      	ldr	r3, [r3, #0]
  400af8:	697a      	ldr	r2, [r7, #20]
  400afa:	429a      	cmp	r2, r3
  400afc:	d304      	bcc.n	400b08 <vPortSuppressTicksAndSleep+0xe8>
  400afe:	4b23      	ldr	r3, [pc, #140]	; (400b8c <vPortSuppressTicksAndSleep+0x16c>)
  400b00:	681b      	ldr	r3, [r3, #0]
  400b02:	697a      	ldr	r2, [r7, #20]
  400b04:	429a      	cmp	r2, r3
  400b06:	d903      	bls.n	400b10 <vPortSuppressTicksAndSleep+0xf0>
				{
					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
  400b08:	4b20      	ldr	r3, [pc, #128]	; (400b8c <vPortSuppressTicksAndSleep+0x16c>)
  400b0a:	681b      	ldr	r3, [r3, #0]
  400b0c:	3b01      	subs	r3, #1
  400b0e:	617b      	str	r3, [r7, #20]
				}

				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
  400b10:	4b21      	ldr	r3, [pc, #132]	; (400b98 <vPortSuppressTicksAndSleep+0x178>)
  400b12:	697a      	ldr	r2, [r7, #20]
  400b14:	601a      	str	r2, [r3, #0]
				/* The tick interrupt handler will already have pended the tick
				processing in the kernel.  As the pending tick will be
				processed as soon as this function exits, the tick value
				maintained by the tick is stepped forward by one less than the
				time spent waiting. */
				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
  400b16:	687b      	ldr	r3, [r7, #4]
  400b18:	3b01      	subs	r3, #1
  400b1a:	61bb      	str	r3, [r7, #24]
  400b1c:	e018      	b.n	400b50 <vPortSuppressTicksAndSleep+0x130>
			{
				/* Something other than the tick interrupt ended the sleep.
				Work out how long the sleep lasted rounded to complete tick
				periods (not the ulReload value which accounted for part
				ticks). */
				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
  400b1e:	4b1b      	ldr	r3, [pc, #108]	; (400b8c <vPortSuppressTicksAndSleep+0x16c>)
  400b20:	681b      	ldr	r3, [r3, #0]
  400b22:	687a      	ldr	r2, [r7, #4]
  400b24:	fb02 f203 	mul.w	r2, r2, r3
  400b28:	4b17      	ldr	r3, [pc, #92]	; (400b88 <vPortSuppressTicksAndSleep+0x168>)
  400b2a:	681b      	ldr	r3, [r3, #0]
  400b2c:	1ad3      	subs	r3, r2, r3
  400b2e:	60bb      	str	r3, [r7, #8]

				/* How many complete tick periods passed while the processor
				was waiting? */
				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
  400b30:	4b16      	ldr	r3, [pc, #88]	; (400b8c <vPortSuppressTicksAndSleep+0x16c>)
  400b32:	681b      	ldr	r3, [r3, #0]
  400b34:	68ba      	ldr	r2, [r7, #8]
  400b36:	fbb2 f3f3 	udiv	r3, r2, r3
  400b3a:	61bb      	str	r3, [r7, #24]

				/* The reload value is set to whatever fraction of a single tick
				period remains. */
				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1 ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
  400b3c:	4b16      	ldr	r3, [pc, #88]	; (400b98 <vPortSuppressTicksAndSleep+0x178>)
  400b3e:	69ba      	ldr	r2, [r7, #24]
  400b40:	3201      	adds	r2, #1
  400b42:	4912      	ldr	r1, [pc, #72]	; (400b8c <vPortSuppressTicksAndSleep+0x16c>)
  400b44:	6809      	ldr	r1, [r1, #0]
  400b46:	fb01 f102 	mul.w	r1, r1, r2
  400b4a:	68ba      	ldr	r2, [r7, #8]
  400b4c:	1a8a      	subs	r2, r1, r2
  400b4e:	601a      	str	r2, [r3, #0]
			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
			again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
			value.  The critical section is used to ensure the tick interrupt
			can only execute once in the case that the reload register is near
			zero. */
			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
  400b50:	4b0d      	ldr	r3, [pc, #52]	; (400b88 <vPortSuppressTicksAndSleep+0x168>)
  400b52:	2200      	movs	r2, #0
  400b54:	601a      	str	r2, [r3, #0]
			portENTER_CRITICAL();
  400b56:	4b11      	ldr	r3, [pc, #68]	; (400b9c <vPortSuppressTicksAndSleep+0x17c>)
  400b58:	4798      	blx	r3
			{
				portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
  400b5a:	4b0a      	ldr	r3, [pc, #40]	; (400b84 <vPortSuppressTicksAndSleep+0x164>)
  400b5c:	4a09      	ldr	r2, [pc, #36]	; (400b84 <vPortSuppressTicksAndSleep+0x164>)
  400b5e:	6812      	ldr	r2, [r2, #0]
  400b60:	f042 0201 	orr.w	r2, r2, #1
  400b64:	601a      	str	r2, [r3, #0]
				vTaskStepTick( ulCompleteTickPeriods );
  400b66:	69b8      	ldr	r0, [r7, #24]
  400b68:	4b0d      	ldr	r3, [pc, #52]	; (400ba0 <vPortSuppressTicksAndSleep+0x180>)
  400b6a:	4798      	blx	r3
				portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
  400b6c:	4b0a      	ldr	r3, [pc, #40]	; (400b98 <vPortSuppressTicksAndSleep+0x178>)
  400b6e:	4a07      	ldr	r2, [pc, #28]	; (400b8c <vPortSuppressTicksAndSleep+0x16c>)
  400b70:	6812      	ldr	r2, [r2, #0]
  400b72:	3a01      	subs	r2, #1
  400b74:	601a      	str	r2, [r3, #0]
			}
			portEXIT_CRITICAL();
  400b76:	4b0b      	ldr	r3, [pc, #44]	; (400ba4 <vPortSuppressTicksAndSleep+0x184>)
  400b78:	4798      	blx	r3
		}
	}
  400b7a:	3720      	adds	r7, #32
  400b7c:	46bd      	mov	sp, r7
  400b7e:	bd80      	pop	{r7, pc}
  400b80:	20000468 	.word	0x20000468
  400b84:	e000e010 	.word	0xe000e010
  400b88:	e000e018 	.word	0xe000e018
  400b8c:	20000464 	.word	0x20000464
  400b90:	2000046c 	.word	0x2000046c
  400b94:	004027c9 	.word	0x004027c9
  400b98:	e000e014 	.word	0xe000e014
  400b9c:	004008dd 	.word	0x004008dd
  400ba0:	0040211d 	.word	0x0040211d
  400ba4:	00400931 	.word	0x00400931

00400ba8 <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
  400ba8:	b480      	push	{r7}
  400baa:	af00      	add	r7, sp, #0
	/* Calculate the constants required to configure the tick interrupt. */
	#if configUSE_TICKLESS_IDLE == 1
	{
		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
  400bac:	4b15      	ldr	r3, [pc, #84]	; (400c04 <vPortSetupTimerInterrupt+0x5c>)
  400bae:	681a      	ldr	r2, [r3, #0]
  400bb0:	4b15      	ldr	r3, [pc, #84]	; (400c08 <vPortSetupTimerInterrupt+0x60>)
  400bb2:	fba3 0302 	umull	r0, r3, r3, r2
  400bb6:	099a      	lsrs	r2, r3, #6
  400bb8:	4b14      	ldr	r3, [pc, #80]	; (400c0c <vPortSetupTimerInterrupt+0x64>)
  400bba:	601a      	str	r2, [r3, #0]
		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
  400bbc:	4b13      	ldr	r3, [pc, #76]	; (400c0c <vPortSetupTimerInterrupt+0x64>)
  400bbe:	681b      	ldr	r3, [r3, #0]
  400bc0:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
  400bc4:	fbb2 f2f3 	udiv	r2, r2, r3
  400bc8:	4b11      	ldr	r3, [pc, #68]	; (400c10 <vPortSetupTimerInterrupt+0x68>)
  400bca:	601a      	str	r2, [r3, #0]
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
  400bcc:	4b0d      	ldr	r3, [pc, #52]	; (400c04 <vPortSetupTimerInterrupt+0x5c>)
  400bce:	681a      	ldr	r2, [r3, #0]
  400bd0:	4b0c      	ldr	r3, [pc, #48]	; (400c04 <vPortSetupTimerInterrupt+0x5c>)
  400bd2:	681b      	ldr	r3, [r3, #0]
  400bd4:	fbb2 f3f3 	udiv	r3, r2, r3
  400bd8:	222d      	movs	r2, #45	; 0x2d
  400bda:	fbb2 f2f3 	udiv	r2, r2, r3
  400bde:	4b0d      	ldr	r3, [pc, #52]	; (400c14 <vPortSetupTimerInterrupt+0x6c>)
  400be0:	601a      	str	r2, [r3, #0]
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
  400be2:	4b0d      	ldr	r3, [pc, #52]	; (400c18 <vPortSetupTimerInterrupt+0x70>)
  400be4:	4a07      	ldr	r2, [pc, #28]	; (400c04 <vPortSetupTimerInterrupt+0x5c>)
  400be6:	6811      	ldr	r1, [r2, #0]
  400be8:	4a07      	ldr	r2, [pc, #28]	; (400c08 <vPortSetupTimerInterrupt+0x60>)
  400bea:	fba2 0201 	umull	r0, r2, r2, r1
  400bee:	0992      	lsrs	r2, r2, #6
  400bf0:	3a01      	subs	r2, #1
  400bf2:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
  400bf4:	4b09      	ldr	r3, [pc, #36]	; (400c1c <vPortSetupTimerInterrupt+0x74>)
  400bf6:	2207      	movs	r2, #7
  400bf8:	601a      	str	r2, [r3, #0]
}
  400bfa:	46bd      	mov	sp, r7
  400bfc:	f85d 7b04 	ldr.w	r7, [sp], #4
  400c00:	4770      	bx	lr
  400c02:	bf00      	nop
  400c04:	20000000 	.word	0x20000000
  400c08:	10624dd3 	.word	0x10624dd3
  400c0c:	20000464 	.word	0x20000464
  400c10:	20000468 	.word	0x20000468
  400c14:	2000046c 	.word	0x2000046c
  400c18:	e000e014 	.word	0xe000e014
  400c1c:	e000e010 	.word	0xe000e010

00400c20 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
  400c20:	f8df 000c 	ldr.w	r0, [pc, #12]	; 400c30 <vPortEnableVFP+0x10>
  400c24:	6801      	ldr	r1, [r0, #0]
  400c26:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  400c2a:	6001      	str	r1, [r0, #0]
  400c2c:	4770      	bx	lr
  400c2e:	0000      	.short	0x0000
  400c30:	e000ed88 	.word	0xe000ed88

00400c34 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
  400c34:	b580      	push	{r7, lr}
  400c36:	b082      	sub	sp, #8
  400c38:	af00      	add	r7, sp, #0
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
  400c3a:	f3ef 8305 	mrs	r3, IPSR
  400c3e:	607b      	str	r3, [r7, #4]

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
  400c40:	687b      	ldr	r3, [r7, #4]
  400c42:	2b0f      	cmp	r3, #15
  400c44:	d90e      	bls.n	400c64 <vPortValidateInterruptPriority+0x30>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
  400c46:	4a0f      	ldr	r2, [pc, #60]	; (400c84 <vPortValidateInterruptPriority+0x50>)
  400c48:	687b      	ldr	r3, [r7, #4]
  400c4a:	4413      	add	r3, r2
  400c4c:	781b      	ldrb	r3, [r3, #0]
  400c4e:	70fb      	strb	r3, [r7, #3]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
  400c50:	4b0d      	ldr	r3, [pc, #52]	; (400c88 <vPortValidateInterruptPriority+0x54>)
  400c52:	781b      	ldrb	r3, [r3, #0]
  400c54:	78fa      	ldrb	r2, [r7, #3]
  400c56:	429a      	cmp	r2, r3
  400c58:	d204      	bcs.n	400c64 <vPortValidateInterruptPriority+0x30>
  400c5a:	f44f 7035 	mov.w	r0, #724	; 0x2d4
  400c5e:	490b      	ldr	r1, [pc, #44]	; (400c8c <vPortValidateInterruptPriority+0x58>)
  400c60:	4b0b      	ldr	r3, [pc, #44]	; (400c90 <vPortValidateInterruptPriority+0x5c>)
  400c62:	4798      	blx	r3
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
  400c64:	4b0b      	ldr	r3, [pc, #44]	; (400c94 <vPortValidateInterruptPriority+0x60>)
  400c66:	681b      	ldr	r3, [r3, #0]
  400c68:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
  400c6c:	4b0a      	ldr	r3, [pc, #40]	; (400c98 <vPortValidateInterruptPriority+0x64>)
  400c6e:	681b      	ldr	r3, [r3, #0]
  400c70:	429a      	cmp	r2, r3
  400c72:	d904      	bls.n	400c7e <vPortValidateInterruptPriority+0x4a>
  400c74:	f44f 7039 	mov.w	r0, #740	; 0x2e4
  400c78:	4904      	ldr	r1, [pc, #16]	; (400c8c <vPortValidateInterruptPriority+0x58>)
  400c7a:	4b05      	ldr	r3, [pc, #20]	; (400c90 <vPortValidateInterruptPriority+0x5c>)
  400c7c:	4798      	blx	r3
	}
  400c7e:	3708      	adds	r7, #8
  400c80:	46bd      	mov	sp, r7
  400c82:	bd80      	pop	{r7, pc}
  400c84:	e000e3f0 	.word	0xe000e3f0
  400c88:	20000470 	.word	0x20000470
  400c8c:	00404574 	.word	0x00404574
  400c90:	004004d1 	.word	0x004004d1
  400c94:	e000ed0c 	.word	0xe000ed0c
  400c98:	20000474 	.word	0x20000474

00400c9c <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  400c9c:	b580      	push	{r7, lr}
  400c9e:	b086      	sub	sp, #24
  400ca0:	af00      	add	r7, sp, #0
  400ca2:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
  400ca4:	2300      	movs	r3, #0
  400ca6:	60fb      	str	r3, [r7, #12]

	vTaskSuspendAll();
  400ca8:	4b4f      	ldr	r3, [pc, #316]	; (400de8 <pvPortMalloc+0x14c>)
  400caa:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
  400cac:	4b4f      	ldr	r3, [pc, #316]	; (400dec <pvPortMalloc+0x150>)
  400cae:	681b      	ldr	r3, [r3, #0]
  400cb0:	2b00      	cmp	r3, #0
  400cb2:	d101      	bne.n	400cb8 <pvPortMalloc+0x1c>
		{
			prvHeapInit();
  400cb4:	4b4e      	ldr	r3, [pc, #312]	; (400df0 <pvPortMalloc+0x154>)
  400cb6:	4798      	blx	r3

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
  400cb8:	4b4e      	ldr	r3, [pc, #312]	; (400df4 <pvPortMalloc+0x158>)
  400cba:	681a      	ldr	r2, [r3, #0]
  400cbc:	687b      	ldr	r3, [r7, #4]
  400cbe:	4013      	ands	r3, r2
  400cc0:	2b00      	cmp	r3, #0
  400cc2:	d17f      	bne.n	400dc4 <pvPortMalloc+0x128>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
  400cc4:	687b      	ldr	r3, [r7, #4]
  400cc6:	2b00      	cmp	r3, #0
  400cc8:	d016      	beq.n	400cf8 <pvPortMalloc+0x5c>
			{
				xWantedSize += xHeapStructSize;
  400cca:	2308      	movs	r3, #8
  400ccc:	687a      	ldr	r2, [r7, #4]
  400cce:	4413      	add	r3, r2
  400cd0:	607b      	str	r3, [r7, #4]

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
  400cd2:	687b      	ldr	r3, [r7, #4]
  400cd4:	f003 0307 	and.w	r3, r3, #7
  400cd8:	2b00      	cmp	r3, #0
  400cda:	d00d      	beq.n	400cf8 <pvPortMalloc+0x5c>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  400cdc:	687b      	ldr	r3, [r7, #4]
  400cde:	f023 0307 	bic.w	r3, r3, #7
  400ce2:	3308      	adds	r3, #8
  400ce4:	607b      	str	r3, [r7, #4]
					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
  400ce6:	687b      	ldr	r3, [r7, #4]
  400ce8:	f003 0307 	and.w	r3, r3, #7
  400cec:	2b00      	cmp	r3, #0
  400cee:	d003      	beq.n	400cf8 <pvPortMalloc+0x5c>
  400cf0:	20bb      	movs	r0, #187	; 0xbb
  400cf2:	4941      	ldr	r1, [pc, #260]	; (400df8 <pvPortMalloc+0x15c>)
  400cf4:	4b41      	ldr	r3, [pc, #260]	; (400dfc <pvPortMalloc+0x160>)
  400cf6:	4798      	blx	r3
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
  400cf8:	687b      	ldr	r3, [r7, #4]
  400cfa:	2b00      	cmp	r3, #0
  400cfc:	d062      	beq.n	400dc4 <pvPortMalloc+0x128>
  400cfe:	4b40      	ldr	r3, [pc, #256]	; (400e00 <pvPortMalloc+0x164>)
  400d00:	681b      	ldr	r3, [r3, #0]
  400d02:	687a      	ldr	r2, [r7, #4]
  400d04:	429a      	cmp	r2, r3
  400d06:	d85d      	bhi.n	400dc4 <pvPortMalloc+0x128>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
  400d08:	4b3e      	ldr	r3, [pc, #248]	; (400e04 <pvPortMalloc+0x168>)
  400d0a:	613b      	str	r3, [r7, #16]
				pxBlock = xStart.pxNextFreeBlock;
  400d0c:	4b3d      	ldr	r3, [pc, #244]	; (400e04 <pvPortMalloc+0x168>)
  400d0e:	681b      	ldr	r3, [r3, #0]
  400d10:	617b      	str	r3, [r7, #20]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  400d12:	e004      	b.n	400d1e <pvPortMalloc+0x82>
				{
					pxPreviousBlock = pxBlock;
  400d14:	697b      	ldr	r3, [r7, #20]
  400d16:	613b      	str	r3, [r7, #16]
					pxBlock = pxBlock->pxNextFreeBlock;
  400d18:	697b      	ldr	r3, [r7, #20]
  400d1a:	681b      	ldr	r3, [r3, #0]
  400d1c:	617b      	str	r3, [r7, #20]
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  400d1e:	697b      	ldr	r3, [r7, #20]
  400d20:	685a      	ldr	r2, [r3, #4]
  400d22:	687b      	ldr	r3, [r7, #4]
  400d24:	429a      	cmp	r2, r3
  400d26:	d203      	bcs.n	400d30 <pvPortMalloc+0x94>
  400d28:	697b      	ldr	r3, [r7, #20]
  400d2a:	681b      	ldr	r3, [r3, #0]
  400d2c:	2b00      	cmp	r3, #0
  400d2e:	d1f1      	bne.n	400d14 <pvPortMalloc+0x78>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
  400d30:	4b2e      	ldr	r3, [pc, #184]	; (400dec <pvPortMalloc+0x150>)
  400d32:	681b      	ldr	r3, [r3, #0]
  400d34:	697a      	ldr	r2, [r7, #20]
  400d36:	429a      	cmp	r2, r3
  400d38:	d044      	beq.n	400dc4 <pvPortMalloc+0x128>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
  400d3a:	693b      	ldr	r3, [r7, #16]
  400d3c:	681a      	ldr	r2, [r3, #0]
  400d3e:	2308      	movs	r3, #8
  400d40:	4413      	add	r3, r2
  400d42:	60fb      	str	r3, [r7, #12]

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
  400d44:	697b      	ldr	r3, [r7, #20]
  400d46:	681a      	ldr	r2, [r3, #0]
  400d48:	693b      	ldr	r3, [r7, #16]
  400d4a:	601a      	str	r2, [r3, #0]

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
  400d4c:	697b      	ldr	r3, [r7, #20]
  400d4e:	685a      	ldr	r2, [r3, #4]
  400d50:	687b      	ldr	r3, [r7, #4]
  400d52:	1ad2      	subs	r2, r2, r3
  400d54:	2308      	movs	r3, #8
  400d56:	005b      	lsls	r3, r3, #1
  400d58:	429a      	cmp	r2, r3
  400d5a:	d918      	bls.n	400d8e <pvPortMalloc+0xf2>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
  400d5c:	697a      	ldr	r2, [r7, #20]
  400d5e:	687b      	ldr	r3, [r7, #4]
  400d60:	4413      	add	r3, r2
  400d62:	60bb      	str	r3, [r7, #8]
						configASSERT( ( ( ( uint32_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
  400d64:	68bb      	ldr	r3, [r7, #8]
  400d66:	f003 0307 	and.w	r3, r3, #7
  400d6a:	2b00      	cmp	r3, #0
  400d6c:	d003      	beq.n	400d76 <pvPortMalloc+0xda>
  400d6e:	20e8      	movs	r0, #232	; 0xe8
  400d70:	4921      	ldr	r1, [pc, #132]	; (400df8 <pvPortMalloc+0x15c>)
  400d72:	4b22      	ldr	r3, [pc, #136]	; (400dfc <pvPortMalloc+0x160>)
  400d74:	4798      	blx	r3

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
  400d76:	697b      	ldr	r3, [r7, #20]
  400d78:	685a      	ldr	r2, [r3, #4]
  400d7a:	687b      	ldr	r3, [r7, #4]
  400d7c:	1ad2      	subs	r2, r2, r3
  400d7e:	68bb      	ldr	r3, [r7, #8]
  400d80:	605a      	str	r2, [r3, #4]
						pxBlock->xBlockSize = xWantedSize;
  400d82:	697b      	ldr	r3, [r7, #20]
  400d84:	687a      	ldr	r2, [r7, #4]
  400d86:	605a      	str	r2, [r3, #4]

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
  400d88:	68b8      	ldr	r0, [r7, #8]
  400d8a:	4b1f      	ldr	r3, [pc, #124]	; (400e08 <pvPortMalloc+0x16c>)
  400d8c:	4798      	blx	r3
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
  400d8e:	4b1c      	ldr	r3, [pc, #112]	; (400e00 <pvPortMalloc+0x164>)
  400d90:	681a      	ldr	r2, [r3, #0]
  400d92:	697b      	ldr	r3, [r7, #20]
  400d94:	685b      	ldr	r3, [r3, #4]
  400d96:	1ad2      	subs	r2, r2, r3
  400d98:	4b19      	ldr	r3, [pc, #100]	; (400e00 <pvPortMalloc+0x164>)
  400d9a:	601a      	str	r2, [r3, #0]

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
  400d9c:	4b18      	ldr	r3, [pc, #96]	; (400e00 <pvPortMalloc+0x164>)
  400d9e:	681a      	ldr	r2, [r3, #0]
  400da0:	4b1a      	ldr	r3, [pc, #104]	; (400e0c <pvPortMalloc+0x170>)
  400da2:	681b      	ldr	r3, [r3, #0]
  400da4:	429a      	cmp	r2, r3
  400da6:	d203      	bcs.n	400db0 <pvPortMalloc+0x114>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
  400da8:	4b15      	ldr	r3, [pc, #84]	; (400e00 <pvPortMalloc+0x164>)
  400daa:	681a      	ldr	r2, [r3, #0]
  400dac:	4b17      	ldr	r3, [pc, #92]	; (400e0c <pvPortMalloc+0x170>)
  400dae:	601a      	str	r2, [r3, #0]
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
  400db0:	697b      	ldr	r3, [r7, #20]
  400db2:	685a      	ldr	r2, [r3, #4]
  400db4:	4b0f      	ldr	r3, [pc, #60]	; (400df4 <pvPortMalloc+0x158>)
  400db6:	681b      	ldr	r3, [r3, #0]
  400db8:	431a      	orrs	r2, r3
  400dba:	697b      	ldr	r3, [r7, #20]
  400dbc:	605a      	str	r2, [r3, #4]
					pxBlock->pxNextFreeBlock = NULL;
  400dbe:	697b      	ldr	r3, [r7, #20]
  400dc0:	2200      	movs	r2, #0
  400dc2:	601a      	str	r2, [r3, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
  400dc4:	4b12      	ldr	r3, [pc, #72]	; (400e10 <pvPortMalloc+0x174>)
  400dc6:	4798      	blx	r3
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
  400dc8:	68fb      	ldr	r3, [r7, #12]
  400dca:	f003 0307 	and.w	r3, r3, #7
  400dce:	2b00      	cmp	r3, #0
  400dd0:	d004      	beq.n	400ddc <pvPortMalloc+0x140>
  400dd2:	f44f 7094 	mov.w	r0, #296	; 0x128
  400dd6:	4908      	ldr	r1, [pc, #32]	; (400df8 <pvPortMalloc+0x15c>)
  400dd8:	4b08      	ldr	r3, [pc, #32]	; (400dfc <pvPortMalloc+0x160>)
  400dda:	4798      	blx	r3
	return pvReturn;
  400ddc:	68fb      	ldr	r3, [r7, #12]
}
  400dde:	4618      	mov	r0, r3
  400de0:	3718      	adds	r7, #24
  400de2:	46bd      	mov	sp, r7
  400de4:	bd80      	pop	{r7, pc}
  400de6:	bf00      	nop
  400de8:	00401f59 	.word	0x00401f59
  400dec:	2000c080 	.word	0x2000c080
  400df0:	00400ec5 	.word	0x00400ec5
  400df4:	2000c08c 	.word	0x2000c08c
  400df8:	004045b4 	.word	0x004045b4
  400dfc:	004004d1 	.word	0x004004d1
  400e00:	2000c084 	.word	0x2000c084
  400e04:	2000c078 	.word	0x2000c078
  400e08:	00400f89 	.word	0x00400f89
  400e0c:	2000c088 	.word	0x2000c088
  400e10:	00401fc5 	.word	0x00401fc5

00400e14 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
  400e14:	b580      	push	{r7, lr}
  400e16:	b084      	sub	sp, #16
  400e18:	af00      	add	r7, sp, #0
  400e1a:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
  400e1c:	687b      	ldr	r3, [r7, #4]
  400e1e:	60fb      	str	r3, [r7, #12]
BlockLink_t *pxLink;

	if( pv != NULL )
  400e20:	687b      	ldr	r3, [r7, #4]
  400e22:	2b00      	cmp	r3, #0
  400e24:	d03c      	beq.n	400ea0 <vPortFree+0x8c>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
  400e26:	2308      	movs	r3, #8
  400e28:	425b      	negs	r3, r3
  400e2a:	68fa      	ldr	r2, [r7, #12]
  400e2c:	4413      	add	r3, r2
  400e2e:	60fb      	str	r3, [r7, #12]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
  400e30:	68fb      	ldr	r3, [r7, #12]
  400e32:	60bb      	str	r3, [r7, #8]

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
  400e34:	68bb      	ldr	r3, [r7, #8]
  400e36:	685a      	ldr	r2, [r3, #4]
  400e38:	4b1b      	ldr	r3, [pc, #108]	; (400ea8 <vPortFree+0x94>)
  400e3a:	681b      	ldr	r3, [r3, #0]
  400e3c:	4013      	ands	r3, r2
  400e3e:	2b00      	cmp	r3, #0
  400e40:	d104      	bne.n	400e4c <vPortFree+0x38>
  400e42:	f44f 709e 	mov.w	r0, #316	; 0x13c
  400e46:	4919      	ldr	r1, [pc, #100]	; (400eac <vPortFree+0x98>)
  400e48:	4b19      	ldr	r3, [pc, #100]	; (400eb0 <vPortFree+0x9c>)
  400e4a:	4798      	blx	r3
		configASSERT( pxLink->pxNextFreeBlock == NULL );
  400e4c:	68bb      	ldr	r3, [r7, #8]
  400e4e:	681b      	ldr	r3, [r3, #0]
  400e50:	2b00      	cmp	r3, #0
  400e52:	d004      	beq.n	400e5e <vPortFree+0x4a>
  400e54:	f240 103d 	movw	r0, #317	; 0x13d
  400e58:	4914      	ldr	r1, [pc, #80]	; (400eac <vPortFree+0x98>)
  400e5a:	4b15      	ldr	r3, [pc, #84]	; (400eb0 <vPortFree+0x9c>)
  400e5c:	4798      	blx	r3

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
  400e5e:	68bb      	ldr	r3, [r7, #8]
  400e60:	685a      	ldr	r2, [r3, #4]
  400e62:	4b11      	ldr	r3, [pc, #68]	; (400ea8 <vPortFree+0x94>)
  400e64:	681b      	ldr	r3, [r3, #0]
  400e66:	4013      	ands	r3, r2
  400e68:	2b00      	cmp	r3, #0
  400e6a:	d019      	beq.n	400ea0 <vPortFree+0x8c>
		{
			if( pxLink->pxNextFreeBlock == NULL )
  400e6c:	68bb      	ldr	r3, [r7, #8]
  400e6e:	681b      	ldr	r3, [r3, #0]
  400e70:	2b00      	cmp	r3, #0
  400e72:	d115      	bne.n	400ea0 <vPortFree+0x8c>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
  400e74:	68bb      	ldr	r3, [r7, #8]
  400e76:	685a      	ldr	r2, [r3, #4]
  400e78:	4b0b      	ldr	r3, [pc, #44]	; (400ea8 <vPortFree+0x94>)
  400e7a:	681b      	ldr	r3, [r3, #0]
  400e7c:	43db      	mvns	r3, r3
  400e7e:	401a      	ands	r2, r3
  400e80:	68bb      	ldr	r3, [r7, #8]
  400e82:	605a      	str	r2, [r3, #4]

				vTaskSuspendAll();
  400e84:	4b0b      	ldr	r3, [pc, #44]	; (400eb4 <vPortFree+0xa0>)
  400e86:	4798      	blx	r3
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
  400e88:	68bb      	ldr	r3, [r7, #8]
  400e8a:	685a      	ldr	r2, [r3, #4]
  400e8c:	4b0a      	ldr	r3, [pc, #40]	; (400eb8 <vPortFree+0xa4>)
  400e8e:	681b      	ldr	r3, [r3, #0]
  400e90:	441a      	add	r2, r3
  400e92:	4b09      	ldr	r3, [pc, #36]	; (400eb8 <vPortFree+0xa4>)
  400e94:	601a      	str	r2, [r3, #0]
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
  400e96:	68b8      	ldr	r0, [r7, #8]
  400e98:	4b08      	ldr	r3, [pc, #32]	; (400ebc <vPortFree+0xa8>)
  400e9a:	4798      	blx	r3
				}
				( void ) xTaskResumeAll();
  400e9c:	4b08      	ldr	r3, [pc, #32]	; (400ec0 <vPortFree+0xac>)
  400e9e:	4798      	blx	r3
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
  400ea0:	3710      	adds	r7, #16
  400ea2:	46bd      	mov	sp, r7
  400ea4:	bd80      	pop	{r7, pc}
  400ea6:	bf00      	nop
  400ea8:	2000c08c 	.word	0x2000c08c
  400eac:	004045b4 	.word	0x004045b4
  400eb0:	004004d1 	.word	0x004004d1
  400eb4:	00401f59 	.word	0x00401f59
  400eb8:	2000c084 	.word	0x2000c084
  400ebc:	00400f89 	.word	0x00400f89
  400ec0:	00401fc5 	.word	0x00401fc5

00400ec4 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
  400ec4:	b480      	push	{r7}
  400ec6:	b085      	sub	sp, #20
  400ec8:	af00      	add	r7, sp, #0
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;
uint32_t ulAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
  400eca:	f44f 433c 	mov.w	r3, #48128	; 0xbc00
  400ece:	60bb      	str	r3, [r7, #8]

	/* Ensure the heap starts on a correctly aligned boundary. */
	ulAddress = ( uint32_t ) ucHeap;
  400ed0:	4b27      	ldr	r3, [pc, #156]	; (400f70 <prvHeapInit+0xac>)
  400ed2:	60fb      	str	r3, [r7, #12]

	if( ( ulAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
  400ed4:	68fb      	ldr	r3, [r7, #12]
  400ed6:	f003 0307 	and.w	r3, r3, #7
  400eda:	2b00      	cmp	r3, #0
  400edc:	d00c      	beq.n	400ef8 <prvHeapInit+0x34>
	{
		ulAddress += ( portBYTE_ALIGNMENT - 1 );
  400ede:	68fb      	ldr	r3, [r7, #12]
  400ee0:	3307      	adds	r3, #7
  400ee2:	60fb      	str	r3, [r7, #12]
		ulAddress &= ~portBYTE_ALIGNMENT_MASK;
  400ee4:	68fb      	ldr	r3, [r7, #12]
  400ee6:	f023 0307 	bic.w	r3, r3, #7
  400eea:	60fb      	str	r3, [r7, #12]
		xTotalHeapSize -= ulAddress - ( uint32_t ) ucHeap;
  400eec:	68ba      	ldr	r2, [r7, #8]
  400eee:	68fb      	ldr	r3, [r7, #12]
  400ef0:	1ad2      	subs	r2, r2, r3
  400ef2:	4b1f      	ldr	r3, [pc, #124]	; (400f70 <prvHeapInit+0xac>)
  400ef4:	4413      	add	r3, r2
  400ef6:	60bb      	str	r3, [r7, #8]
	}

	pucAlignedHeap = ( uint8_t * ) ulAddress;
  400ef8:	68fb      	ldr	r3, [r7, #12]
  400efa:	607b      	str	r3, [r7, #4]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
  400efc:	4b1d      	ldr	r3, [pc, #116]	; (400f74 <prvHeapInit+0xb0>)
  400efe:	687a      	ldr	r2, [r7, #4]
  400f00:	601a      	str	r2, [r3, #0]
	xStart.xBlockSize = ( size_t ) 0;
  400f02:	4b1c      	ldr	r3, [pc, #112]	; (400f74 <prvHeapInit+0xb0>)
  400f04:	2200      	movs	r2, #0
  400f06:	605a      	str	r2, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	ulAddress = ( ( uint32_t ) pucAlignedHeap ) + xTotalHeapSize;
  400f08:	687a      	ldr	r2, [r7, #4]
  400f0a:	68bb      	ldr	r3, [r7, #8]
  400f0c:	4413      	add	r3, r2
  400f0e:	60fb      	str	r3, [r7, #12]
	ulAddress -= xHeapStructSize;
  400f10:	2308      	movs	r3, #8
  400f12:	68fa      	ldr	r2, [r7, #12]
  400f14:	1ad3      	subs	r3, r2, r3
  400f16:	60fb      	str	r3, [r7, #12]
	ulAddress &= ~portBYTE_ALIGNMENT_MASK;
  400f18:	68fb      	ldr	r3, [r7, #12]
  400f1a:	f023 0307 	bic.w	r3, r3, #7
  400f1e:	60fb      	str	r3, [r7, #12]
	pxEnd = ( void * ) ulAddress;
  400f20:	68fa      	ldr	r2, [r7, #12]
  400f22:	4b15      	ldr	r3, [pc, #84]	; (400f78 <prvHeapInit+0xb4>)
  400f24:	601a      	str	r2, [r3, #0]
	pxEnd->xBlockSize = 0;
  400f26:	4b14      	ldr	r3, [pc, #80]	; (400f78 <prvHeapInit+0xb4>)
  400f28:	681b      	ldr	r3, [r3, #0]
  400f2a:	2200      	movs	r2, #0
  400f2c:	605a      	str	r2, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
  400f2e:	4b12      	ldr	r3, [pc, #72]	; (400f78 <prvHeapInit+0xb4>)
  400f30:	681b      	ldr	r3, [r3, #0]
  400f32:	2200      	movs	r2, #0
  400f34:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
  400f36:	687b      	ldr	r3, [r7, #4]
  400f38:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = ulAddress - ( uint32_t ) pxFirstFreeBlock;
  400f3a:	683b      	ldr	r3, [r7, #0]
  400f3c:	68fa      	ldr	r2, [r7, #12]
  400f3e:	1ad2      	subs	r2, r2, r3
  400f40:	683b      	ldr	r3, [r7, #0]
  400f42:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
  400f44:	4b0c      	ldr	r3, [pc, #48]	; (400f78 <prvHeapInit+0xb4>)
  400f46:	681a      	ldr	r2, [r3, #0]
  400f48:	683b      	ldr	r3, [r7, #0]
  400f4a:	601a      	str	r2, [r3, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  400f4c:	683b      	ldr	r3, [r7, #0]
  400f4e:	685a      	ldr	r2, [r3, #4]
  400f50:	4b0a      	ldr	r3, [pc, #40]	; (400f7c <prvHeapInit+0xb8>)
  400f52:	601a      	str	r2, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  400f54:	683b      	ldr	r3, [r7, #0]
  400f56:	685a      	ldr	r2, [r3, #4]
  400f58:	4b09      	ldr	r3, [pc, #36]	; (400f80 <prvHeapInit+0xbc>)
  400f5a:	601a      	str	r2, [r3, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
  400f5c:	4b09      	ldr	r3, [pc, #36]	; (400f84 <prvHeapInit+0xc0>)
  400f5e:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
  400f62:	601a      	str	r2, [r3, #0]
}
  400f64:	3714      	adds	r7, #20
  400f66:	46bd      	mov	sp, r7
  400f68:	f85d 7b04 	ldr.w	r7, [sp], #4
  400f6c:	4770      	bx	lr
  400f6e:	bf00      	nop
  400f70:	20000478 	.word	0x20000478
  400f74:	2000c078 	.word	0x2000c078
  400f78:	2000c080 	.word	0x2000c080
  400f7c:	2000c088 	.word	0x2000c088
  400f80:	2000c084 	.word	0x2000c084
  400f84:	2000c08c 	.word	0x2000c08c

00400f88 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
  400f88:	b480      	push	{r7}
  400f8a:	b085      	sub	sp, #20
  400f8c:	af00      	add	r7, sp, #0
  400f8e:	6078      	str	r0, [r7, #4]
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
  400f90:	4b27      	ldr	r3, [pc, #156]	; (401030 <prvInsertBlockIntoFreeList+0xa8>)
  400f92:	60fb      	str	r3, [r7, #12]
  400f94:	e002      	b.n	400f9c <prvInsertBlockIntoFreeList+0x14>
  400f96:	68fb      	ldr	r3, [r7, #12]
  400f98:	681b      	ldr	r3, [r3, #0]
  400f9a:	60fb      	str	r3, [r7, #12]
  400f9c:	68fb      	ldr	r3, [r7, #12]
  400f9e:	681a      	ldr	r2, [r3, #0]
  400fa0:	687b      	ldr	r3, [r7, #4]
  400fa2:	429a      	cmp	r2, r3
  400fa4:	d3f7      	bcc.n	400f96 <prvInsertBlockIntoFreeList+0xe>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
  400fa6:	68fb      	ldr	r3, [r7, #12]
  400fa8:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
  400faa:	68fb      	ldr	r3, [r7, #12]
  400fac:	685b      	ldr	r3, [r3, #4]
  400fae:	68ba      	ldr	r2, [r7, #8]
  400fb0:	441a      	add	r2, r3
  400fb2:	687b      	ldr	r3, [r7, #4]
  400fb4:	429a      	cmp	r2, r3
  400fb6:	d108      	bne.n	400fca <prvInsertBlockIntoFreeList+0x42>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
  400fb8:	68fb      	ldr	r3, [r7, #12]
  400fba:	685a      	ldr	r2, [r3, #4]
  400fbc:	687b      	ldr	r3, [r7, #4]
  400fbe:	685b      	ldr	r3, [r3, #4]
  400fc0:	441a      	add	r2, r3
  400fc2:	68fb      	ldr	r3, [r7, #12]
  400fc4:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
  400fc6:	68fb      	ldr	r3, [r7, #12]
  400fc8:	607b      	str	r3, [r7, #4]
		mtCOVERAGE_TEST_MARKER();
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
  400fca:	687b      	ldr	r3, [r7, #4]
  400fcc:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
  400fce:	687b      	ldr	r3, [r7, #4]
  400fd0:	685b      	ldr	r3, [r3, #4]
  400fd2:	68ba      	ldr	r2, [r7, #8]
  400fd4:	441a      	add	r2, r3
  400fd6:	68fb      	ldr	r3, [r7, #12]
  400fd8:	681b      	ldr	r3, [r3, #0]
  400fda:	429a      	cmp	r2, r3
  400fdc:	d118      	bne.n	401010 <prvInsertBlockIntoFreeList+0x88>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
  400fde:	68fb      	ldr	r3, [r7, #12]
  400fe0:	681a      	ldr	r2, [r3, #0]
  400fe2:	4b14      	ldr	r3, [pc, #80]	; (401034 <prvInsertBlockIntoFreeList+0xac>)
  400fe4:	681b      	ldr	r3, [r3, #0]
  400fe6:	429a      	cmp	r2, r3
  400fe8:	d00d      	beq.n	401006 <prvInsertBlockIntoFreeList+0x7e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
  400fea:	687b      	ldr	r3, [r7, #4]
  400fec:	685a      	ldr	r2, [r3, #4]
  400fee:	68fb      	ldr	r3, [r7, #12]
  400ff0:	681b      	ldr	r3, [r3, #0]
  400ff2:	685b      	ldr	r3, [r3, #4]
  400ff4:	441a      	add	r2, r3
  400ff6:	687b      	ldr	r3, [r7, #4]
  400ff8:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
  400ffa:	68fb      	ldr	r3, [r7, #12]
  400ffc:	681b      	ldr	r3, [r3, #0]
  400ffe:	681a      	ldr	r2, [r3, #0]
  401000:	687b      	ldr	r3, [r7, #4]
  401002:	601a      	str	r2, [r3, #0]
  401004:	e008      	b.n	401018 <prvInsertBlockIntoFreeList+0x90>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
  401006:	4b0b      	ldr	r3, [pc, #44]	; (401034 <prvInsertBlockIntoFreeList+0xac>)
  401008:	681a      	ldr	r2, [r3, #0]
  40100a:	687b      	ldr	r3, [r7, #4]
  40100c:	601a      	str	r2, [r3, #0]
  40100e:	e003      	b.n	401018 <prvInsertBlockIntoFreeList+0x90>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
  401010:	68fb      	ldr	r3, [r7, #12]
  401012:	681a      	ldr	r2, [r3, #0]
  401014:	687b      	ldr	r3, [r7, #4]
  401016:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
  401018:	68fa      	ldr	r2, [r7, #12]
  40101a:	687b      	ldr	r3, [r7, #4]
  40101c:	429a      	cmp	r2, r3
  40101e:	d002      	beq.n	401026 <prvInsertBlockIntoFreeList+0x9e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
  401020:	68fb      	ldr	r3, [r7, #12]
  401022:	687a      	ldr	r2, [r7, #4]
  401024:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
  401026:	3714      	adds	r7, #20
  401028:	46bd      	mov	sp, r7
  40102a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40102e:	4770      	bx	lr
  401030:	2000c078 	.word	0x2000c078
  401034:	2000c080 	.word	0x2000c080

00401038 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
  401038:	b580      	push	{r7, lr}
  40103a:	b084      	sub	sp, #16
  40103c:	af00      	add	r7, sp, #0
  40103e:	6078      	str	r0, [r7, #4]
  401040:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  401042:	687b      	ldr	r3, [r7, #4]
  401044:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
  401046:	68fb      	ldr	r3, [r7, #12]
  401048:	2b00      	cmp	r3, #0
  40104a:	d104      	bne.n	401056 <xQueueGenericReset+0x1e>
  40104c:	f44f 7084 	mov.w	r0, #264	; 0x108
  401050:	4929      	ldr	r1, [pc, #164]	; (4010f8 <xQueueGenericReset+0xc0>)
  401052:	4b2a      	ldr	r3, [pc, #168]	; (4010fc <xQueueGenericReset+0xc4>)
  401054:	4798      	blx	r3

	taskENTER_CRITICAL();
  401056:	4b2a      	ldr	r3, [pc, #168]	; (401100 <xQueueGenericReset+0xc8>)
  401058:	4798      	blx	r3
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  40105a:	68fb      	ldr	r3, [r7, #12]
  40105c:	681a      	ldr	r2, [r3, #0]
  40105e:	68fb      	ldr	r3, [r7, #12]
  401060:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  401062:	68f9      	ldr	r1, [r7, #12]
  401064:	6c09      	ldr	r1, [r1, #64]	; 0x40
  401066:	fb01 f303 	mul.w	r3, r1, r3
  40106a:	441a      	add	r2, r3
  40106c:	68fb      	ldr	r3, [r7, #12]
  40106e:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  401070:	68fb      	ldr	r3, [r7, #12]
  401072:	2200      	movs	r2, #0
  401074:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
  401076:	68fb      	ldr	r3, [r7, #12]
  401078:	681a      	ldr	r2, [r3, #0]
  40107a:	68fb      	ldr	r3, [r7, #12]
  40107c:	609a      	str	r2, [r3, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
  40107e:	68fb      	ldr	r3, [r7, #12]
  401080:	681a      	ldr	r2, [r3, #0]
  401082:	68fb      	ldr	r3, [r7, #12]
  401084:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  401086:	3b01      	subs	r3, #1
  401088:	68f9      	ldr	r1, [r7, #12]
  40108a:	6c09      	ldr	r1, [r1, #64]	; 0x40
  40108c:	fb01 f303 	mul.w	r3, r1, r3
  401090:	441a      	add	r2, r3
  401092:	68fb      	ldr	r3, [r7, #12]
  401094:	60da      	str	r2, [r3, #12]
		pxQueue->xRxLock = queueUNLOCKED;
  401096:	68fb      	ldr	r3, [r7, #12]
  401098:	f04f 32ff 	mov.w	r2, #4294967295
  40109c:	645a      	str	r2, [r3, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
  40109e:	68fb      	ldr	r3, [r7, #12]
  4010a0:	f04f 32ff 	mov.w	r2, #4294967295
  4010a4:	649a      	str	r2, [r3, #72]	; 0x48

		if( xNewQueue == pdFALSE )
  4010a6:	683b      	ldr	r3, [r7, #0]
  4010a8:	2b00      	cmp	r3, #0
  4010aa:	d114      	bne.n	4010d6 <xQueueGenericReset+0x9e>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  4010ac:	68fb      	ldr	r3, [r7, #12]
  4010ae:	691b      	ldr	r3, [r3, #16]
  4010b0:	2b00      	cmp	r3, #0
  4010b2:	d01a      	beq.n	4010ea <xQueueGenericReset+0xb2>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  4010b4:	68fb      	ldr	r3, [r7, #12]
  4010b6:	3310      	adds	r3, #16
  4010b8:	4618      	mov	r0, r3
  4010ba:	4b12      	ldr	r3, [pc, #72]	; (401104 <xQueueGenericReset+0xcc>)
  4010bc:	4798      	blx	r3
  4010be:	4603      	mov	r3, r0
  4010c0:	2b01      	cmp	r3, #1
  4010c2:	d112      	bne.n	4010ea <xQueueGenericReset+0xb2>
				{
					queueYIELD_IF_USING_PREEMPTION();
  4010c4:	4b10      	ldr	r3, [pc, #64]	; (401108 <xQueueGenericReset+0xd0>)
  4010c6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  4010ca:	601a      	str	r2, [r3, #0]
  4010cc:	f3bf 8f4f 	dsb	sy
  4010d0:	f3bf 8f6f 	isb	sy
  4010d4:	e009      	b.n	4010ea <xQueueGenericReset+0xb2>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
  4010d6:	68fb      	ldr	r3, [r7, #12]
  4010d8:	3310      	adds	r3, #16
  4010da:	4618      	mov	r0, r3
  4010dc:	4b0b      	ldr	r3, [pc, #44]	; (40110c <xQueueGenericReset+0xd4>)
  4010de:	4798      	blx	r3
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
  4010e0:	68fb      	ldr	r3, [r7, #12]
  4010e2:	3324      	adds	r3, #36	; 0x24
  4010e4:	4618      	mov	r0, r3
  4010e6:	4b09      	ldr	r3, [pc, #36]	; (40110c <xQueueGenericReset+0xd4>)
  4010e8:	4798      	blx	r3
		}
	}
	taskEXIT_CRITICAL();
  4010ea:	4b09      	ldr	r3, [pc, #36]	; (401110 <xQueueGenericReset+0xd8>)
  4010ec:	4798      	blx	r3

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
  4010ee:	2301      	movs	r3, #1
}
  4010f0:	4618      	mov	r0, r3
  4010f2:	3710      	adds	r7, #16
  4010f4:	46bd      	mov	sp, r7
  4010f6:	bd80      	pop	{r7, pc}
  4010f8:	004045ec 	.word	0x004045ec
  4010fc:	004004d1 	.word	0x004004d1
  401100:	004008dd 	.word	0x004008dd
  401104:	00402555 	.word	0x00402555
  401108:	e000ed04 	.word	0xe000ed04
  40110c:	004005b9 	.word	0x004005b9
  401110:	00400931 	.word	0x00400931

00401114 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
  401114:	b580      	push	{r7, lr}
  401116:	b088      	sub	sp, #32
  401118:	af00      	add	r7, sp, #0
  40111a:	60f8      	str	r0, [r7, #12]
  40111c:	60b9      	str	r1, [r7, #8]
  40111e:	4613      	mov	r3, r2
  401120:	71fb      	strb	r3, [r7, #7]
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
  401122:	2300      	movs	r3, #0
  401124:	61bb      	str	r3, [r7, #24]

	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
  401126:	68fb      	ldr	r3, [r7, #12]
  401128:	2b00      	cmp	r3, #0
  40112a:	d104      	bne.n	401136 <xQueueGenericCreate+0x22>
  40112c:	f44f 70a2 	mov.w	r0, #324	; 0x144
  401130:	4922      	ldr	r1, [pc, #136]	; (4011bc <xQueueGenericCreate+0xa8>)
  401132:	4b23      	ldr	r3, [pc, #140]	; (4011c0 <xQueueGenericCreate+0xac>)
  401134:	4798      	blx	r3

	if( uxItemSize == ( UBaseType_t ) 0 )
  401136:	68bb      	ldr	r3, [r7, #8]
  401138:	2b00      	cmp	r3, #0
  40113a:	d102      	bne.n	401142 <xQueueGenericCreate+0x2e>
	{
		/* There is not going to be a queue storage area. */
		xQueueSizeInBytes = ( size_t ) 0;
  40113c:	2300      	movs	r3, #0
  40113e:	61fb      	str	r3, [r7, #28]
  401140:	e005      	b.n	40114e <xQueueGenericCreate+0x3a>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  401142:	68fb      	ldr	r3, [r7, #12]
  401144:	68ba      	ldr	r2, [r7, #8]
  401146:	fb02 f303 	mul.w	r3, r2, r3
  40114a:	3301      	adds	r3, #1
  40114c:	61fb      	str	r3, [r7, #28]
	}

	/* Allocate the new queue structure and storage area. */
	pcAllocatedBuffer = ( int8_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
  40114e:	69fb      	ldr	r3, [r7, #28]
  401150:	3358      	adds	r3, #88	; 0x58
  401152:	4618      	mov	r0, r3
  401154:	4b1b      	ldr	r3, [pc, #108]	; (4011c4 <xQueueGenericCreate+0xb0>)
  401156:	4798      	blx	r3
  401158:	6178      	str	r0, [r7, #20]

	if( pcAllocatedBuffer != NULL )
  40115a:	697b      	ldr	r3, [r7, #20]
  40115c:	2b00      	cmp	r3, #0
  40115e:	d020      	beq.n	4011a2 <xQueueGenericCreate+0x8e>
	{
		pxNewQueue = ( Queue_t * ) pcAllocatedBuffer; /*lint !e826 MISRA The buffer cannot be to small because it was dimensioned by sizeof( Queue_t ) + xQueueSizeInBytes. */
  401160:	697b      	ldr	r3, [r7, #20]
  401162:	613b      	str	r3, [r7, #16]

		if( uxItemSize == ( UBaseType_t ) 0 )
  401164:	68bb      	ldr	r3, [r7, #8]
  401166:	2b00      	cmp	r3, #0
  401168:	d103      	bne.n	401172 <xQueueGenericCreate+0x5e>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
  40116a:	693b      	ldr	r3, [r7, #16]
  40116c:	693a      	ldr	r2, [r7, #16]
  40116e:	601a      	str	r2, [r3, #0]
  401170:	e004      	b.n	40117c <xQueueGenericCreate+0x68>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area - adding the padding bytes to get a better alignment. */
			pxNewQueue->pcHead = pcAllocatedBuffer + sizeof( Queue_t );
  401172:	697b      	ldr	r3, [r7, #20]
  401174:	f103 0258 	add.w	r2, r3, #88	; 0x58
  401178:	693b      	ldr	r3, [r7, #16]
  40117a:	601a      	str	r2, [r3, #0]
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
  40117c:	693b      	ldr	r3, [r7, #16]
  40117e:	68fa      	ldr	r2, [r7, #12]
  401180:	63da      	str	r2, [r3, #60]	; 0x3c
		pxNewQueue->uxItemSize = uxItemSize;
  401182:	693b      	ldr	r3, [r7, #16]
  401184:	68ba      	ldr	r2, [r7, #8]
  401186:	641a      	str	r2, [r3, #64]	; 0x40
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
  401188:	6938      	ldr	r0, [r7, #16]
  40118a:	2101      	movs	r1, #1
  40118c:	4b0e      	ldr	r3, [pc, #56]	; (4011c8 <xQueueGenericCreate+0xb4>)
  40118e:	4798      	blx	r3

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			pxNewQueue->ucQueueType = ucQueueType;
  401190:	693b      	ldr	r3, [r7, #16]
  401192:	79fa      	ldrb	r2, [r7, #7]
  401194:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
		}
		#endif /* configUSE_TRACE_FACILITY */

		#if( configUSE_QUEUE_SETS == 1 )
		{
			pxNewQueue->pxQueueSetContainer = NULL;
  401198:	693b      	ldr	r3, [r7, #16]
  40119a:	2200      	movs	r2, #0
  40119c:	655a      	str	r2, [r3, #84]	; 0x54
		}
		#endif /* configUSE_QUEUE_SETS */

		traceQUEUE_CREATE( pxNewQueue );
		xReturn = pxNewQueue;
  40119e:	693b      	ldr	r3, [r7, #16]
  4011a0:	61bb      	str	r3, [r7, #24]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
  4011a2:	69bb      	ldr	r3, [r7, #24]
  4011a4:	2b00      	cmp	r3, #0
  4011a6:	d104      	bne.n	4011b2 <xQueueGenericCreate+0x9e>
  4011a8:	f44f 70c1 	mov.w	r0, #386	; 0x182
  4011ac:	4903      	ldr	r1, [pc, #12]	; (4011bc <xQueueGenericCreate+0xa8>)
  4011ae:	4b04      	ldr	r3, [pc, #16]	; (4011c0 <xQueueGenericCreate+0xac>)
  4011b0:	4798      	blx	r3

	return xReturn;
  4011b2:	69bb      	ldr	r3, [r7, #24]
}
  4011b4:	4618      	mov	r0, r3
  4011b6:	3720      	adds	r7, #32
  4011b8:	46bd      	mov	sp, r7
  4011ba:	bd80      	pop	{r7, pc}
  4011bc:	004045ec 	.word	0x004045ec
  4011c0:	004004d1 	.word	0x004004d1
  4011c4:	00400c9d 	.word	0x00400c9d
  4011c8:	00401039 	.word	0x00401039

004011cc <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
  4011cc:	b580      	push	{r7, lr}
  4011ce:	b08a      	sub	sp, #40	; 0x28
  4011d0:	af00      	add	r7, sp, #0
  4011d2:	60f8      	str	r0, [r7, #12]
  4011d4:	60b9      	str	r1, [r7, #8]
  4011d6:	607a      	str	r2, [r7, #4]
  4011d8:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
  4011da:	2300      	movs	r3, #0
  4011dc:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  4011de:	68fb      	ldr	r3, [r7, #12]
  4011e0:	623b      	str	r3, [r7, #32]

	configASSERT( pxQueue );
  4011e2:	6a3b      	ldr	r3, [r7, #32]
  4011e4:	2b00      	cmp	r3, #0
  4011e6:	d104      	bne.n	4011f2 <xQueueGenericSend+0x26>
  4011e8:	f240 206b 	movw	r0, #619	; 0x26b
  4011ec:	4971      	ldr	r1, [pc, #452]	; (4013b4 <xQueueGenericSend+0x1e8>)
  4011ee:	4b72      	ldr	r3, [pc, #456]	; (4013b8 <xQueueGenericSend+0x1ec>)
  4011f0:	4798      	blx	r3
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  4011f2:	68bb      	ldr	r3, [r7, #8]
  4011f4:	2b00      	cmp	r3, #0
  4011f6:	d103      	bne.n	401200 <xQueueGenericSend+0x34>
  4011f8:	6a3b      	ldr	r3, [r7, #32]
  4011fa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4011fc:	2b00      	cmp	r3, #0
  4011fe:	d101      	bne.n	401204 <xQueueGenericSend+0x38>
  401200:	2301      	movs	r3, #1
  401202:	e000      	b.n	401206 <xQueueGenericSend+0x3a>
  401204:	2300      	movs	r3, #0
  401206:	2b00      	cmp	r3, #0
  401208:	d104      	bne.n	401214 <xQueueGenericSend+0x48>
  40120a:	f44f 701b 	mov.w	r0, #620	; 0x26c
  40120e:	4969      	ldr	r1, [pc, #420]	; (4013b4 <xQueueGenericSend+0x1e8>)
  401210:	4b69      	ldr	r3, [pc, #420]	; (4013b8 <xQueueGenericSend+0x1ec>)
  401212:	4798      	blx	r3
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  401214:	683b      	ldr	r3, [r7, #0]
  401216:	2b02      	cmp	r3, #2
  401218:	d103      	bne.n	401222 <xQueueGenericSend+0x56>
  40121a:	6a3b      	ldr	r3, [r7, #32]
  40121c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  40121e:	2b01      	cmp	r3, #1
  401220:	d101      	bne.n	401226 <xQueueGenericSend+0x5a>
  401222:	2301      	movs	r3, #1
  401224:	e000      	b.n	401228 <xQueueGenericSend+0x5c>
  401226:	2300      	movs	r3, #0
  401228:	2b00      	cmp	r3, #0
  40122a:	d104      	bne.n	401236 <xQueueGenericSend+0x6a>
  40122c:	f240 206d 	movw	r0, #621	; 0x26d
  401230:	4960      	ldr	r1, [pc, #384]	; (4013b4 <xQueueGenericSend+0x1e8>)
  401232:	4b61      	ldr	r3, [pc, #388]	; (4013b8 <xQueueGenericSend+0x1ec>)
  401234:	4798      	blx	r3
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  401236:	4b61      	ldr	r3, [pc, #388]	; (4013bc <xQueueGenericSend+0x1f0>)
  401238:	4798      	blx	r3
  40123a:	4603      	mov	r3, r0
  40123c:	2b00      	cmp	r3, #0
  40123e:	d102      	bne.n	401246 <xQueueGenericSend+0x7a>
  401240:	687b      	ldr	r3, [r7, #4]
  401242:	2b00      	cmp	r3, #0
  401244:	d101      	bne.n	40124a <xQueueGenericSend+0x7e>
  401246:	2301      	movs	r3, #1
  401248:	e000      	b.n	40124c <xQueueGenericSend+0x80>
  40124a:	2300      	movs	r3, #0
  40124c:	2b00      	cmp	r3, #0
  40124e:	d104      	bne.n	40125a <xQueueGenericSend+0x8e>
  401250:	f44f 701c 	mov.w	r0, #624	; 0x270
  401254:	4957      	ldr	r1, [pc, #348]	; (4013b4 <xQueueGenericSend+0x1e8>)
  401256:	4b58      	ldr	r3, [pc, #352]	; (4013b8 <xQueueGenericSend+0x1ec>)
  401258:	4798      	blx	r3
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  40125a:	4b59      	ldr	r3, [pc, #356]	; (4013c0 <xQueueGenericSend+0x1f4>)
  40125c:	4798      	blx	r3
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  40125e:	6a3b      	ldr	r3, [r7, #32]
  401260:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  401262:	6a3b      	ldr	r3, [r7, #32]
  401264:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  401266:	429a      	cmp	r2, r3
  401268:	d302      	bcc.n	401270 <xQueueGenericSend+0xa4>
  40126a:	683b      	ldr	r3, [r7, #0]
  40126c:	2b02      	cmp	r3, #2
  40126e:	d13d      	bne.n	4012ec <xQueueGenericSend+0x120>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  401270:	6a38      	ldr	r0, [r7, #32]
  401272:	68b9      	ldr	r1, [r7, #8]
  401274:	683a      	ldr	r2, [r7, #0]
  401276:	4b53      	ldr	r3, [pc, #332]	; (4013c4 <xQueueGenericSend+0x1f8>)
  401278:	4798      	blx	r3
  40127a:	61f8      	str	r0, [r7, #28]

				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
  40127c:	6a3b      	ldr	r3, [r7, #32]
  40127e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  401280:	2b00      	cmp	r3, #0
  401282:	d00f      	beq.n	4012a4 <xQueueGenericSend+0xd8>
					{
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
  401284:	6a38      	ldr	r0, [r7, #32]
  401286:	6839      	ldr	r1, [r7, #0]
  401288:	4b4f      	ldr	r3, [pc, #316]	; (4013c8 <xQueueGenericSend+0x1fc>)
  40128a:	4798      	blx	r3
  40128c:	4603      	mov	r3, r0
  40128e:	2b01      	cmp	r3, #1
  401290:	d128      	bne.n	4012e4 <xQueueGenericSend+0x118>
						{
							/* The queue is a member of a queue set, and posting
							to the queue set caused a higher priority task to
							unblock. A context switch is required. */
							queueYIELD_IF_USING_PREEMPTION();
  401292:	4b4e      	ldr	r3, [pc, #312]	; (4013cc <xQueueGenericSend+0x200>)
  401294:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  401298:	601a      	str	r2, [r3, #0]
  40129a:	f3bf 8f4f 	dsb	sy
  40129e:	f3bf 8f6f 	isb	sy
  4012a2:	e01f      	b.n	4012e4 <xQueueGenericSend+0x118>
					}
					else
					{
						/* If there was a task waiting for data to arrive on the
						queue then unblock it now. */
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4012a4:	6a3b      	ldr	r3, [r7, #32]
  4012a6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  4012a8:	2b00      	cmp	r3, #0
  4012aa:	d010      	beq.n	4012ce <xQueueGenericSend+0x102>
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
  4012ac:	6a3b      	ldr	r3, [r7, #32]
  4012ae:	3324      	adds	r3, #36	; 0x24
  4012b0:	4618      	mov	r0, r3
  4012b2:	4b47      	ldr	r3, [pc, #284]	; (4013d0 <xQueueGenericSend+0x204>)
  4012b4:	4798      	blx	r3
  4012b6:	4603      	mov	r3, r0
  4012b8:	2b01      	cmp	r3, #1
  4012ba:	d113      	bne.n	4012e4 <xQueueGenericSend+0x118>
							{
								/* The unblocked task has a priority higher than
								our own so yield immediately.  Yes it is ok to
								do this from within the critical section - the
								kernel takes care of that. */
								queueYIELD_IF_USING_PREEMPTION();
  4012bc:	4b43      	ldr	r3, [pc, #268]	; (4013cc <xQueueGenericSend+0x200>)
  4012be:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  4012c2:	601a      	str	r2, [r3, #0]
  4012c4:	f3bf 8f4f 	dsb	sy
  4012c8:	f3bf 8f6f 	isb	sy
  4012cc:	e00a      	b.n	4012e4 <xQueueGenericSend+0x118>
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
						}
						else if( xYieldRequired != pdFALSE )
  4012ce:	69fb      	ldr	r3, [r7, #28]
  4012d0:	2b00      	cmp	r3, #0
  4012d2:	d007      	beq.n	4012e4 <xQueueGenericSend+0x118>
						{
							/* This path is a special case that will only get
							executed if the task was holding multiple mutexes
							and the mutexes were given back in an order that is
							different to that in which they were taken. */
							queueYIELD_IF_USING_PREEMPTION();
  4012d4:	4b3d      	ldr	r3, [pc, #244]	; (4013cc <xQueueGenericSend+0x200>)
  4012d6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  4012da:	601a      	str	r2, [r3, #0]
  4012dc:	f3bf 8f4f 	dsb	sy
  4012e0:	f3bf 8f6f 	isb	sy
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
  4012e4:	4b3b      	ldr	r3, [pc, #236]	; (4013d4 <xQueueGenericSend+0x208>)
  4012e6:	4798      	blx	r3
				return pdPASS;
  4012e8:	2301      	movs	r3, #1
  4012ea:	e05f      	b.n	4013ac <xQueueGenericSend+0x1e0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
  4012ec:	687b      	ldr	r3, [r7, #4]
  4012ee:	2b00      	cmp	r3, #0
  4012f0:	d103      	bne.n	4012fa <xQueueGenericSend+0x12e>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  4012f2:	4b38      	ldr	r3, [pc, #224]	; (4013d4 <xQueueGenericSend+0x208>)
  4012f4:	4798      	blx	r3

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
  4012f6:	2300      	movs	r3, #0
  4012f8:	e058      	b.n	4013ac <xQueueGenericSend+0x1e0>
				}
				else if( xEntryTimeSet == pdFALSE )
  4012fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4012fc:	2b00      	cmp	r3, #0
  4012fe:	d106      	bne.n	40130e <xQueueGenericSend+0x142>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  401300:	f107 0314 	add.w	r3, r7, #20
  401304:	4618      	mov	r0, r3
  401306:	4b34      	ldr	r3, [pc, #208]	; (4013d8 <xQueueGenericSend+0x20c>)
  401308:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
  40130a:	2301      	movs	r3, #1
  40130c:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
  40130e:	4b31      	ldr	r3, [pc, #196]	; (4013d4 <xQueueGenericSend+0x208>)
  401310:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  401312:	4b32      	ldr	r3, [pc, #200]	; (4013dc <xQueueGenericSend+0x210>)
  401314:	4798      	blx	r3
		prvLockQueue( pxQueue );
  401316:	4b2a      	ldr	r3, [pc, #168]	; (4013c0 <xQueueGenericSend+0x1f4>)
  401318:	4798      	blx	r3
  40131a:	6a3b      	ldr	r3, [r7, #32]
  40131c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  40131e:	f1b3 3fff 	cmp.w	r3, #4294967295
  401322:	d102      	bne.n	40132a <xQueueGenericSend+0x15e>
  401324:	6a3b      	ldr	r3, [r7, #32]
  401326:	2200      	movs	r2, #0
  401328:	645a      	str	r2, [r3, #68]	; 0x44
  40132a:	6a3b      	ldr	r3, [r7, #32]
  40132c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  40132e:	f1b3 3fff 	cmp.w	r3, #4294967295
  401332:	d102      	bne.n	40133a <xQueueGenericSend+0x16e>
  401334:	6a3b      	ldr	r3, [r7, #32]
  401336:	2200      	movs	r2, #0
  401338:	649a      	str	r2, [r3, #72]	; 0x48
  40133a:	4b26      	ldr	r3, [pc, #152]	; (4013d4 <xQueueGenericSend+0x208>)
  40133c:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  40133e:	f107 0214 	add.w	r2, r7, #20
  401342:	1d3b      	adds	r3, r7, #4
  401344:	4610      	mov	r0, r2
  401346:	4619      	mov	r1, r3
  401348:	4b25      	ldr	r3, [pc, #148]	; (4013e0 <xQueueGenericSend+0x214>)
  40134a:	4798      	blx	r3
  40134c:	4603      	mov	r3, r0
  40134e:	2b00      	cmp	r3, #0
  401350:	d124      	bne.n	40139c <xQueueGenericSend+0x1d0>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
  401352:	6a38      	ldr	r0, [r7, #32]
  401354:	4b23      	ldr	r3, [pc, #140]	; (4013e4 <xQueueGenericSend+0x218>)
  401356:	4798      	blx	r3
  401358:	4603      	mov	r3, r0
  40135a:	2b00      	cmp	r3, #0
  40135c:	d018      	beq.n	401390 <xQueueGenericSend+0x1c4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
  40135e:	6a3b      	ldr	r3, [r7, #32]
  401360:	f103 0210 	add.w	r2, r3, #16
  401364:	687b      	ldr	r3, [r7, #4]
  401366:	4610      	mov	r0, r2
  401368:	4619      	mov	r1, r3
  40136a:	4b1f      	ldr	r3, [pc, #124]	; (4013e8 <xQueueGenericSend+0x21c>)
  40136c:	4798      	blx	r3
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
  40136e:	6a38      	ldr	r0, [r7, #32]
  401370:	4b1e      	ldr	r3, [pc, #120]	; (4013ec <xQueueGenericSend+0x220>)
  401372:	4798      	blx	r3
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
  401374:	4b1e      	ldr	r3, [pc, #120]	; (4013f0 <xQueueGenericSend+0x224>)
  401376:	4798      	blx	r3
  401378:	4603      	mov	r3, r0
  40137a:	2b00      	cmp	r3, #0
  40137c:	d115      	bne.n	4013aa <xQueueGenericSend+0x1de>
				{
					portYIELD_WITHIN_API();
  40137e:	4b13      	ldr	r3, [pc, #76]	; (4013cc <xQueueGenericSend+0x200>)
  401380:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  401384:	601a      	str	r2, [r3, #0]
  401386:	f3bf 8f4f 	dsb	sy
  40138a:	f3bf 8f6f 	isb	sy
  40138e:	e00c      	b.n	4013aa <xQueueGenericSend+0x1de>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  401390:	6a38      	ldr	r0, [r7, #32]
  401392:	4b16      	ldr	r3, [pc, #88]	; (4013ec <xQueueGenericSend+0x220>)
  401394:	4798      	blx	r3
				( void ) xTaskResumeAll();
  401396:	4b16      	ldr	r3, [pc, #88]	; (4013f0 <xQueueGenericSend+0x224>)
  401398:	4798      	blx	r3
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
  40139a:	e75e      	b.n	40125a <xQueueGenericSend+0x8e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
  40139c:	6a38      	ldr	r0, [r7, #32]
  40139e:	4b13      	ldr	r3, [pc, #76]	; (4013ec <xQueueGenericSend+0x220>)
  4013a0:	4798      	blx	r3
			( void ) xTaskResumeAll();
  4013a2:	4b13      	ldr	r3, [pc, #76]	; (4013f0 <xQueueGenericSend+0x224>)
  4013a4:	4798      	blx	r3

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
  4013a6:	2300      	movs	r3, #0
  4013a8:	e000      	b.n	4013ac <xQueueGenericSend+0x1e0>
		}
	}
  4013aa:	e756      	b.n	40125a <xQueueGenericSend+0x8e>
}
  4013ac:	4618      	mov	r0, r3
  4013ae:	3728      	adds	r7, #40	; 0x28
  4013b0:	46bd      	mov	sp, r7
  4013b2:	bd80      	pop	{r7, pc}
  4013b4:	004045ec 	.word	0x004045ec
  4013b8:	004004d1 	.word	0x004004d1
  4013bc:	00402b15 	.word	0x00402b15
  4013c0:	004008dd 	.word	0x004008dd
  4013c4:	00401855 	.word	0x00401855
  4013c8:	00401b75 	.word	0x00401b75
  4013cc:	e000ed04 	.word	0xe000ed04
  4013d0:	00402555 	.word	0x00402555
  4013d4:	00400931 	.word	0x00400931
  4013d8:	00402625 	.word	0x00402625
  4013dc:	00401f59 	.word	0x00401f59
  4013e0:	00402665 	.word	0x00402665
  4013e4:	00401a85 	.word	0x00401a85
  4013e8:	00402425 	.word	0x00402425
  4013ec:	00401989 	.word	0x00401989
  4013f0:	00401fc5 	.word	0x00401fc5

004013f4 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
  4013f4:	b580      	push	{r7, lr}
  4013f6:	b08a      	sub	sp, #40	; 0x28
  4013f8:	af00      	add	r7, sp, #0
  4013fa:	60f8      	str	r0, [r7, #12]
  4013fc:	60b9      	str	r1, [r7, #8]
  4013fe:	607a      	str	r2, [r7, #4]
  401400:	603b      	str	r3, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  401402:	68fb      	ldr	r3, [r7, #12]
  401404:	623b      	str	r3, [r7, #32]

	configASSERT( pxQueue );
  401406:	6a3b      	ldr	r3, [r7, #32]
  401408:	2b00      	cmp	r3, #0
  40140a:	d104      	bne.n	401416 <xQueueGenericSendFromISR+0x22>
  40140c:	f44f 6085 	mov.w	r0, #1064	; 0x428
  401410:	4940      	ldr	r1, [pc, #256]	; (401514 <xQueueGenericSendFromISR+0x120>)
  401412:	4b41      	ldr	r3, [pc, #260]	; (401518 <xQueueGenericSendFromISR+0x124>)
  401414:	4798      	blx	r3
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  401416:	68bb      	ldr	r3, [r7, #8]
  401418:	2b00      	cmp	r3, #0
  40141a:	d103      	bne.n	401424 <xQueueGenericSendFromISR+0x30>
  40141c:	6a3b      	ldr	r3, [r7, #32]
  40141e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  401420:	2b00      	cmp	r3, #0
  401422:	d101      	bne.n	401428 <xQueueGenericSendFromISR+0x34>
  401424:	2301      	movs	r3, #1
  401426:	e000      	b.n	40142a <xQueueGenericSendFromISR+0x36>
  401428:	2300      	movs	r3, #0
  40142a:	2b00      	cmp	r3, #0
  40142c:	d104      	bne.n	401438 <xQueueGenericSendFromISR+0x44>
  40142e:	f240 4029 	movw	r0, #1065	; 0x429
  401432:	4938      	ldr	r1, [pc, #224]	; (401514 <xQueueGenericSendFromISR+0x120>)
  401434:	4b38      	ldr	r3, [pc, #224]	; (401518 <xQueueGenericSendFromISR+0x124>)
  401436:	4798      	blx	r3
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  401438:	683b      	ldr	r3, [r7, #0]
  40143a:	2b02      	cmp	r3, #2
  40143c:	d103      	bne.n	401446 <xQueueGenericSendFromISR+0x52>
  40143e:	6a3b      	ldr	r3, [r7, #32]
  401440:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  401442:	2b01      	cmp	r3, #1
  401444:	d101      	bne.n	40144a <xQueueGenericSendFromISR+0x56>
  401446:	2301      	movs	r3, #1
  401448:	e000      	b.n	40144c <xQueueGenericSendFromISR+0x58>
  40144a:	2300      	movs	r3, #0
  40144c:	2b00      	cmp	r3, #0
  40144e:	d104      	bne.n	40145a <xQueueGenericSendFromISR+0x66>
  401450:	f240 402a 	movw	r0, #1066	; 0x42a
  401454:	492f      	ldr	r1, [pc, #188]	; (401514 <xQueueGenericSendFromISR+0x120>)
  401456:	4b30      	ldr	r3, [pc, #192]	; (401518 <xQueueGenericSendFromISR+0x124>)
  401458:	4798      	blx	r3
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  40145a:	4b30      	ldr	r3, [pc, #192]	; (40151c <xQueueGenericSendFromISR+0x128>)
  40145c:	4798      	blx	r3

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
  40145e:	f3ef 8211 	mrs	r2, BASEPRI
  401462:	f04f 0350 	mov.w	r3, #80	; 0x50
  401466:	f383 8811 	msr	BASEPRI, r3
  40146a:	f3bf 8f6f 	isb	sy
  40146e:	f3bf 8f4f 	dsb	sy
  401472:	61ba      	str	r2, [r7, #24]
  401474:	617b      	str	r3, [r7, #20]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
  401476:	69bb      	ldr	r3, [r7, #24]
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  401478:	61fb      	str	r3, [r7, #28]
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  40147a:	6a3b      	ldr	r3, [r7, #32]
  40147c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  40147e:	6a3b      	ldr	r3, [r7, #32]
  401480:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  401482:	429a      	cmp	r2, r3
  401484:	d302      	bcc.n	40148c <xQueueGenericSendFromISR+0x98>
  401486:	683b      	ldr	r3, [r7, #0]
  401488:	2b02      	cmp	r3, #2
  40148a:	d136      	bne.n	4014fa <xQueueGenericSendFromISR+0x106>
			/* A task can only have an inherited priority if it is a mutex
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  Therefore, unlike the xQueueGenericGive()
			function, there is no need to determine the need for priority
			disinheritance here or to clear the mutex holder TCB member. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  40148c:	6a38      	ldr	r0, [r7, #32]
  40148e:	68b9      	ldr	r1, [r7, #8]
  401490:	683a      	ldr	r2, [r7, #0]
  401492:	4b23      	ldr	r3, [pc, #140]	; (401520 <xQueueGenericSendFromISR+0x12c>)
  401494:	4798      	blx	r3

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
  401496:	6a3b      	ldr	r3, [r7, #32]
  401498:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  40149a:	f1b3 3fff 	cmp.w	r3, #4294967295
  40149e:	d124      	bne.n	4014ea <xQueueGenericSendFromISR+0xf6>
			{
				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
  4014a0:	6a3b      	ldr	r3, [r7, #32]
  4014a2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  4014a4:	2b00      	cmp	r3, #0
  4014a6:	d00d      	beq.n	4014c4 <xQueueGenericSendFromISR+0xd0>
					{
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
  4014a8:	6a38      	ldr	r0, [r7, #32]
  4014aa:	6839      	ldr	r1, [r7, #0]
  4014ac:	4b1d      	ldr	r3, [pc, #116]	; (401524 <xQueueGenericSendFromISR+0x130>)
  4014ae:	4798      	blx	r3
  4014b0:	4603      	mov	r3, r0
  4014b2:	2b01      	cmp	r3, #1
  4014b4:	d11e      	bne.n	4014f4 <xQueueGenericSendFromISR+0x100>
						{
							/* The queue is a member of a queue set, and posting
							to the queue set caused a higher priority task to
							unblock.  A context switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
  4014b6:	687b      	ldr	r3, [r7, #4]
  4014b8:	2b00      	cmp	r3, #0
  4014ba:	d01b      	beq.n	4014f4 <xQueueGenericSendFromISR+0x100>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
  4014bc:	687b      	ldr	r3, [r7, #4]
  4014be:	2201      	movs	r2, #1
  4014c0:	601a      	str	r2, [r3, #0]
  4014c2:	e017      	b.n	4014f4 <xQueueGenericSendFromISR+0x100>
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else
					{
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4014c4:	6a3b      	ldr	r3, [r7, #32]
  4014c6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  4014c8:	2b00      	cmp	r3, #0
  4014ca:	d013      	beq.n	4014f4 <xQueueGenericSendFromISR+0x100>
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  4014cc:	6a3b      	ldr	r3, [r7, #32]
  4014ce:	3324      	adds	r3, #36	; 0x24
  4014d0:	4618      	mov	r0, r3
  4014d2:	4b15      	ldr	r3, [pc, #84]	; (401528 <xQueueGenericSendFromISR+0x134>)
  4014d4:	4798      	blx	r3
  4014d6:	4603      	mov	r3, r0
  4014d8:	2b00      	cmp	r3, #0
  4014da:	d00b      	beq.n	4014f4 <xQueueGenericSendFromISR+0x100>
							{
								/* The task waiting has a higher priority so
								record that a context switch is required. */
								if( pxHigherPriorityTaskWoken != NULL )
  4014dc:	687b      	ldr	r3, [r7, #4]
  4014de:	2b00      	cmp	r3, #0
  4014e0:	d008      	beq.n	4014f4 <xQueueGenericSendFromISR+0x100>
								{
									*pxHigherPriorityTaskWoken = pdTRUE;
  4014e2:	687b      	ldr	r3, [r7, #4]
  4014e4:	2201      	movs	r2, #1
  4014e6:	601a      	str	r2, [r3, #0]
  4014e8:	e004      	b.n	4014f4 <xQueueGenericSendFromISR+0x100>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
  4014ea:	6a3b      	ldr	r3, [r7, #32]
  4014ec:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  4014ee:	1c5a      	adds	r2, r3, #1
  4014f0:	6a3b      	ldr	r3, [r7, #32]
  4014f2:	649a      	str	r2, [r3, #72]	; 0x48
			}

			xReturn = pdPASS;
  4014f4:	2301      	movs	r3, #1
  4014f6:	627b      	str	r3, [r7, #36]	; 0x24
  4014f8:	e001      	b.n	4014fe <xQueueGenericSendFromISR+0x10a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  4014fa:	2300      	movs	r3, #0
  4014fc:	627b      	str	r3, [r7, #36]	; 0x24
  4014fe:	69fb      	ldr	r3, [r7, #28]
  401500:	613b      	str	r3, [r7, #16]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
  401502:	693b      	ldr	r3, [r7, #16]
  401504:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  401508:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
  40150a:	4618      	mov	r0, r3
  40150c:	3728      	adds	r7, #40	; 0x28
  40150e:	46bd      	mov	sp, r7
  401510:	bd80      	pop	{r7, pc}
  401512:	bf00      	nop
  401514:	004045ec 	.word	0x004045ec
  401518:	004004d1 	.word	0x004004d1
  40151c:	00400c35 	.word	0x00400c35
  401520:	00401855 	.word	0x00401855
  401524:	00401b75 	.word	0x00401b75
  401528:	00402555 	.word	0x00402555

0040152c <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
  40152c:	b580      	push	{r7, lr}
  40152e:	b088      	sub	sp, #32
  401530:	af00      	add	r7, sp, #0
  401532:	6078      	str	r0, [r7, #4]
  401534:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  401536:	687b      	ldr	r3, [r7, #4]
  401538:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
  40153a:	69bb      	ldr	r3, [r7, #24]
  40153c:	2b00      	cmp	r3, #0
  40153e:	d104      	bne.n	40154a <xQueueGiveFromISR+0x1e>
  401540:	f240 40bd 	movw	r0, #1213	; 0x4bd
  401544:	4932      	ldr	r1, [pc, #200]	; (401610 <xQueueGiveFromISR+0xe4>)
  401546:	4b33      	ldr	r3, [pc, #204]	; (401614 <xQueueGiveFromISR+0xe8>)
  401548:	4798      	blx	r3

	/* xQueueGenericSendFromISR() should be used in the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
  40154a:	69bb      	ldr	r3, [r7, #24]
  40154c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  40154e:	2b00      	cmp	r3, #0
  401550:	d004      	beq.n	40155c <xQueueGiveFromISR+0x30>
  401552:	f44f 6098 	mov.w	r0, #1216	; 0x4c0
  401556:	492e      	ldr	r1, [pc, #184]	; (401610 <xQueueGiveFromISR+0xe4>)
  401558:	4b2e      	ldr	r3, [pc, #184]	; (401614 <xQueueGiveFromISR+0xe8>)
  40155a:	4798      	blx	r3
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  40155c:	4b2e      	ldr	r3, [pc, #184]	; (401618 <xQueueGiveFromISR+0xec>)
  40155e:	4798      	blx	r3

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
  401560:	f3ef 8211 	mrs	r2, BASEPRI
  401564:	f04f 0350 	mov.w	r3, #80	; 0x50
  401568:	f383 8811 	msr	BASEPRI, r3
  40156c:	f3bf 8f6f 	isb	sy
  401570:	f3bf 8f4f 	dsb	sy
  401574:	613a      	str	r2, [r7, #16]
  401576:	60fb      	str	r3, [r7, #12]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
  401578:	693b      	ldr	r3, [r7, #16]
	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  40157a:	617b      	str	r3, [r7, #20]
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
  40157c:	69bb      	ldr	r3, [r7, #24]
  40157e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  401580:	69bb      	ldr	r3, [r7, #24]
  401582:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  401584:	429a      	cmp	r2, r3
  401586:	d236      	bcs.n	4015f6 <xQueueGiveFromISR+0xca>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  Therefore, unlike the xQueueGenericGive()
			function, there is no need to determine the need for priority
			disinheritance here or to clear the mutex holder TCB member. */

			++( pxQueue->uxMessagesWaiting );
  401588:	69bb      	ldr	r3, [r7, #24]
  40158a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40158c:	1c5a      	adds	r2, r3, #1
  40158e:	69bb      	ldr	r3, [r7, #24]
  401590:	639a      	str	r2, [r3, #56]	; 0x38

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
  401592:	69bb      	ldr	r3, [r7, #24]
  401594:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  401596:	f1b3 3fff 	cmp.w	r3, #4294967295
  40159a:	d124      	bne.n	4015e6 <xQueueGiveFromISR+0xba>
			{
				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
  40159c:	69bb      	ldr	r3, [r7, #24]
  40159e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  4015a0:	2b00      	cmp	r3, #0
  4015a2:	d00d      	beq.n	4015c0 <xQueueGiveFromISR+0x94>
					{
						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
  4015a4:	69b8      	ldr	r0, [r7, #24]
  4015a6:	2100      	movs	r1, #0
  4015a8:	4b1c      	ldr	r3, [pc, #112]	; (40161c <xQueueGiveFromISR+0xf0>)
  4015aa:	4798      	blx	r3
  4015ac:	4603      	mov	r3, r0
  4015ae:	2b01      	cmp	r3, #1
  4015b0:	d11e      	bne.n	4015f0 <xQueueGiveFromISR+0xc4>
						{
							/* The semaphore is a member of a queue set, and
							posting	to the queue set caused a higher priority
							task to	unblock.  A context switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
  4015b2:	683b      	ldr	r3, [r7, #0]
  4015b4:	2b00      	cmp	r3, #0
  4015b6:	d01b      	beq.n	4015f0 <xQueueGiveFromISR+0xc4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
  4015b8:	683b      	ldr	r3, [r7, #0]
  4015ba:	2201      	movs	r2, #1
  4015bc:	601a      	str	r2, [r3, #0]
  4015be:	e017      	b.n	4015f0 <xQueueGiveFromISR+0xc4>
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else
					{
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4015c0:	69bb      	ldr	r3, [r7, #24]
  4015c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  4015c4:	2b00      	cmp	r3, #0
  4015c6:	d013      	beq.n	4015f0 <xQueueGiveFromISR+0xc4>
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  4015c8:	69bb      	ldr	r3, [r7, #24]
  4015ca:	3324      	adds	r3, #36	; 0x24
  4015cc:	4618      	mov	r0, r3
  4015ce:	4b14      	ldr	r3, [pc, #80]	; (401620 <xQueueGiveFromISR+0xf4>)
  4015d0:	4798      	blx	r3
  4015d2:	4603      	mov	r3, r0
  4015d4:	2b00      	cmp	r3, #0
  4015d6:	d00b      	beq.n	4015f0 <xQueueGiveFromISR+0xc4>
							{
								/* The task waiting has a higher priority so
								record that a context switch is required. */
								if( pxHigherPriorityTaskWoken != NULL )
  4015d8:	683b      	ldr	r3, [r7, #0]
  4015da:	2b00      	cmp	r3, #0
  4015dc:	d008      	beq.n	4015f0 <xQueueGiveFromISR+0xc4>
								{
									*pxHigherPriorityTaskWoken = pdTRUE;
  4015de:	683b      	ldr	r3, [r7, #0]
  4015e0:	2201      	movs	r2, #1
  4015e2:	601a      	str	r2, [r3, #0]
  4015e4:	e004      	b.n	4015f0 <xQueueGiveFromISR+0xc4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
  4015e6:	69bb      	ldr	r3, [r7, #24]
  4015e8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  4015ea:	1c5a      	adds	r2, r3, #1
  4015ec:	69bb      	ldr	r3, [r7, #24]
  4015ee:	649a      	str	r2, [r3, #72]	; 0x48
			}

			xReturn = pdPASS;
  4015f0:	2301      	movs	r3, #1
  4015f2:	61fb      	str	r3, [r7, #28]
  4015f4:	e001      	b.n	4015fa <xQueueGiveFromISR+0xce>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  4015f6:	2300      	movs	r3, #0
  4015f8:	61fb      	str	r3, [r7, #28]
  4015fa:	697b      	ldr	r3, [r7, #20]
  4015fc:	60bb      	str	r3, [r7, #8]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
  4015fe:	68bb      	ldr	r3, [r7, #8]
  401600:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  401604:	69fb      	ldr	r3, [r7, #28]
}
  401606:	4618      	mov	r0, r3
  401608:	3720      	adds	r7, #32
  40160a:	46bd      	mov	sp, r7
  40160c:	bd80      	pop	{r7, pc}
  40160e:	bf00      	nop
  401610:	004045ec 	.word	0x004045ec
  401614:	004004d1 	.word	0x004004d1
  401618:	00400c35 	.word	0x00400c35
  40161c:	00401b75 	.word	0x00401b75
  401620:	00402555 	.word	0x00402555

00401624 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
  401624:	b580      	push	{r7, lr}
  401626:	b08a      	sub	sp, #40	; 0x28
  401628:	af00      	add	r7, sp, #0
  40162a:	60f8      	str	r0, [r7, #12]
  40162c:	60b9      	str	r1, [r7, #8]
  40162e:	607a      	str	r2, [r7, #4]
  401630:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE;
  401632:	2300      	movs	r3, #0
  401634:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  401636:	68fb      	ldr	r3, [r7, #12]
  401638:	623b      	str	r3, [r7, #32]

	configASSERT( pxQueue );
  40163a:	6a3b      	ldr	r3, [r7, #32]
  40163c:	2b00      	cmp	r3, #0
  40163e:	d104      	bne.n	40164a <xQueueGenericReceive+0x26>
  401640:	f44f 60ab 	mov.w	r0, #1368	; 0x558
  401644:	4972      	ldr	r1, [pc, #456]	; (401810 <xQueueGenericReceive+0x1ec>)
  401646:	4b73      	ldr	r3, [pc, #460]	; (401814 <xQueueGenericReceive+0x1f0>)
  401648:	4798      	blx	r3
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  40164a:	68bb      	ldr	r3, [r7, #8]
  40164c:	2b00      	cmp	r3, #0
  40164e:	d103      	bne.n	401658 <xQueueGenericReceive+0x34>
  401650:	6a3b      	ldr	r3, [r7, #32]
  401652:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  401654:	2b00      	cmp	r3, #0
  401656:	d101      	bne.n	40165c <xQueueGenericReceive+0x38>
  401658:	2301      	movs	r3, #1
  40165a:	e000      	b.n	40165e <xQueueGenericReceive+0x3a>
  40165c:	2300      	movs	r3, #0
  40165e:	2b00      	cmp	r3, #0
  401660:	d104      	bne.n	40166c <xQueueGenericReceive+0x48>
  401662:	f240 5059 	movw	r0, #1369	; 0x559
  401666:	496a      	ldr	r1, [pc, #424]	; (401810 <xQueueGenericReceive+0x1ec>)
  401668:	4b6a      	ldr	r3, [pc, #424]	; (401814 <xQueueGenericReceive+0x1f0>)
  40166a:	4798      	blx	r3
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  40166c:	4b6a      	ldr	r3, [pc, #424]	; (401818 <xQueueGenericReceive+0x1f4>)
  40166e:	4798      	blx	r3
  401670:	4603      	mov	r3, r0
  401672:	2b00      	cmp	r3, #0
  401674:	d102      	bne.n	40167c <xQueueGenericReceive+0x58>
  401676:	687b      	ldr	r3, [r7, #4]
  401678:	2b00      	cmp	r3, #0
  40167a:	d101      	bne.n	401680 <xQueueGenericReceive+0x5c>
  40167c:	2301      	movs	r3, #1
  40167e:	e000      	b.n	401682 <xQueueGenericReceive+0x5e>
  401680:	2300      	movs	r3, #0
  401682:	2b00      	cmp	r3, #0
  401684:	d104      	bne.n	401690 <xQueueGenericReceive+0x6c>
  401686:	f240 505c 	movw	r0, #1372	; 0x55c
  40168a:	4961      	ldr	r1, [pc, #388]	; (401810 <xQueueGenericReceive+0x1ec>)
  40168c:	4b61      	ldr	r3, [pc, #388]	; (401814 <xQueueGenericReceive+0x1f0>)
  40168e:	4798      	blx	r3
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
  401690:	4b62      	ldr	r3, [pc, #392]	; (40181c <xQueueGenericReceive+0x1f8>)
  401692:	4798      	blx	r3
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
  401694:	6a3b      	ldr	r3, [r7, #32]
  401696:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  401698:	2b00      	cmp	r3, #0
  40169a:	d047      	beq.n	40172c <xQueueGenericReceive+0x108>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
  40169c:	6a3b      	ldr	r3, [r7, #32]
  40169e:	68db      	ldr	r3, [r3, #12]
  4016a0:	61fb      	str	r3, [r7, #28]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
  4016a2:	6a38      	ldr	r0, [r7, #32]
  4016a4:	68b9      	ldr	r1, [r7, #8]
  4016a6:	4b5e      	ldr	r3, [pc, #376]	; (401820 <xQueueGenericReceive+0x1fc>)
  4016a8:	4798      	blx	r3

				if( xJustPeeking == pdFALSE )
  4016aa:	683b      	ldr	r3, [r7, #0]
  4016ac:	2b00      	cmp	r3, #0
  4016ae:	d122      	bne.n	4016f6 <xQueueGenericReceive+0xd2>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
  4016b0:	6a3b      	ldr	r3, [r7, #32]
  4016b2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  4016b4:	1e5a      	subs	r2, r3, #1
  4016b6:	6a3b      	ldr	r3, [r7, #32]
  4016b8:	639a      	str	r2, [r3, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  4016ba:	6a3b      	ldr	r3, [r7, #32]
  4016bc:	681b      	ldr	r3, [r3, #0]
  4016be:	2b00      	cmp	r3, #0
  4016c0:	d104      	bne.n	4016cc <xQueueGenericReceive+0xa8>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
  4016c2:	4b58      	ldr	r3, [pc, #352]	; (401824 <xQueueGenericReceive+0x200>)
  4016c4:	4798      	blx	r3
  4016c6:	4602      	mov	r2, r0
  4016c8:	6a3b      	ldr	r3, [r7, #32]
  4016ca:	605a      	str	r2, [r3, #4]
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  4016cc:	6a3b      	ldr	r3, [r7, #32]
  4016ce:	691b      	ldr	r3, [r3, #16]
  4016d0:	2b00      	cmp	r3, #0
  4016d2:	d027      	beq.n	401724 <xQueueGenericReceive+0x100>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  4016d4:	6a3b      	ldr	r3, [r7, #32]
  4016d6:	3310      	adds	r3, #16
  4016d8:	4618      	mov	r0, r3
  4016da:	4b53      	ldr	r3, [pc, #332]	; (401828 <xQueueGenericReceive+0x204>)
  4016dc:	4798      	blx	r3
  4016de:	4603      	mov	r3, r0
  4016e0:	2b01      	cmp	r3, #1
  4016e2:	d11f      	bne.n	401724 <xQueueGenericReceive+0x100>
						{
							queueYIELD_IF_USING_PREEMPTION();
  4016e4:	4b51      	ldr	r3, [pc, #324]	; (40182c <xQueueGenericReceive+0x208>)
  4016e6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  4016ea:	601a      	str	r2, [r3, #0]
  4016ec:	f3bf 8f4f 	dsb	sy
  4016f0:	f3bf 8f6f 	isb	sy
  4016f4:	e016      	b.n	401724 <xQueueGenericReceive+0x100>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
  4016f6:	6a3b      	ldr	r3, [r7, #32]
  4016f8:	69fa      	ldr	r2, [r7, #28]
  4016fa:	60da      	str	r2, [r3, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4016fc:	6a3b      	ldr	r3, [r7, #32]
  4016fe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  401700:	2b00      	cmp	r3, #0
  401702:	d00f      	beq.n	401724 <xQueueGenericReceive+0x100>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  401704:	6a3b      	ldr	r3, [r7, #32]
  401706:	3324      	adds	r3, #36	; 0x24
  401708:	4618      	mov	r0, r3
  40170a:	4b47      	ldr	r3, [pc, #284]	; (401828 <xQueueGenericReceive+0x204>)
  40170c:	4798      	blx	r3
  40170e:	4603      	mov	r3, r0
  401710:	2b00      	cmp	r3, #0
  401712:	d007      	beq.n	401724 <xQueueGenericReceive+0x100>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
  401714:	4b45      	ldr	r3, [pc, #276]	; (40182c <xQueueGenericReceive+0x208>)
  401716:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  40171a:	601a      	str	r2, [r3, #0]
  40171c:	f3bf 8f4f 	dsb	sy
  401720:	f3bf 8f6f 	isb	sy
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
  401724:	4b42      	ldr	r3, [pc, #264]	; (401830 <xQueueGenericReceive+0x20c>)
  401726:	4798      	blx	r3
				return pdPASS;
  401728:	2301      	movs	r3, #1
  40172a:	e06c      	b.n	401806 <xQueueGenericReceive+0x1e2>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
  40172c:	687b      	ldr	r3, [r7, #4]
  40172e:	2b00      	cmp	r3, #0
  401730:	d103      	bne.n	40173a <xQueueGenericReceive+0x116>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  401732:	4b3f      	ldr	r3, [pc, #252]	; (401830 <xQueueGenericReceive+0x20c>)
  401734:	4798      	blx	r3
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  401736:	2300      	movs	r3, #0
  401738:	e065      	b.n	401806 <xQueueGenericReceive+0x1e2>
				}
				else if( xEntryTimeSet == pdFALSE )
  40173a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40173c:	2b00      	cmp	r3, #0
  40173e:	d106      	bne.n	40174e <xQueueGenericReceive+0x12a>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  401740:	f107 0314 	add.w	r3, r7, #20
  401744:	4618      	mov	r0, r3
  401746:	4b3b      	ldr	r3, [pc, #236]	; (401834 <xQueueGenericReceive+0x210>)
  401748:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
  40174a:	2301      	movs	r3, #1
  40174c:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
  40174e:	4b38      	ldr	r3, [pc, #224]	; (401830 <xQueueGenericReceive+0x20c>)
  401750:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  401752:	4b39      	ldr	r3, [pc, #228]	; (401838 <xQueueGenericReceive+0x214>)
  401754:	4798      	blx	r3
		prvLockQueue( pxQueue );
  401756:	4b31      	ldr	r3, [pc, #196]	; (40181c <xQueueGenericReceive+0x1f8>)
  401758:	4798      	blx	r3
  40175a:	6a3b      	ldr	r3, [r7, #32]
  40175c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  40175e:	f1b3 3fff 	cmp.w	r3, #4294967295
  401762:	d102      	bne.n	40176a <xQueueGenericReceive+0x146>
  401764:	6a3b      	ldr	r3, [r7, #32]
  401766:	2200      	movs	r2, #0
  401768:	645a      	str	r2, [r3, #68]	; 0x44
  40176a:	6a3b      	ldr	r3, [r7, #32]
  40176c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  40176e:	f1b3 3fff 	cmp.w	r3, #4294967295
  401772:	d102      	bne.n	40177a <xQueueGenericReceive+0x156>
  401774:	6a3b      	ldr	r3, [r7, #32]
  401776:	2200      	movs	r2, #0
  401778:	649a      	str	r2, [r3, #72]	; 0x48
  40177a:	4b2d      	ldr	r3, [pc, #180]	; (401830 <xQueueGenericReceive+0x20c>)
  40177c:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  40177e:	f107 0214 	add.w	r2, r7, #20
  401782:	1d3b      	adds	r3, r7, #4
  401784:	4610      	mov	r0, r2
  401786:	4619      	mov	r1, r3
  401788:	4b2c      	ldr	r3, [pc, #176]	; (40183c <xQueueGenericReceive+0x218>)
  40178a:	4798      	blx	r3
  40178c:	4603      	mov	r3, r0
  40178e:	2b00      	cmp	r3, #0
  401790:	d131      	bne.n	4017f6 <xQueueGenericReceive+0x1d2>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  401792:	6a38      	ldr	r0, [r7, #32]
  401794:	4b2a      	ldr	r3, [pc, #168]	; (401840 <xQueueGenericReceive+0x21c>)
  401796:	4798      	blx	r3
  401798:	4603      	mov	r3, r0
  40179a:	2b00      	cmp	r3, #0
  40179c:	d025      	beq.n	4017ea <xQueueGenericReceive+0x1c6>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  40179e:	6a3b      	ldr	r3, [r7, #32]
  4017a0:	681b      	ldr	r3, [r3, #0]
  4017a2:	2b00      	cmp	r3, #0
  4017a4:	d108      	bne.n	4017b8 <xQueueGenericReceive+0x194>
					{
						taskENTER_CRITICAL();
  4017a6:	4b1d      	ldr	r3, [pc, #116]	; (40181c <xQueueGenericReceive+0x1f8>)
  4017a8:	4798      	blx	r3
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
  4017aa:	6a3b      	ldr	r3, [r7, #32]
  4017ac:	685b      	ldr	r3, [r3, #4]
  4017ae:	4618      	mov	r0, r3
  4017b0:	4b24      	ldr	r3, [pc, #144]	; (401844 <xQueueGenericReceive+0x220>)
  4017b2:	4798      	blx	r3
						}
						taskEXIT_CRITICAL();
  4017b4:	4b1e      	ldr	r3, [pc, #120]	; (401830 <xQueueGenericReceive+0x20c>)
  4017b6:	4798      	blx	r3
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  4017b8:	6a3b      	ldr	r3, [r7, #32]
  4017ba:	f103 0224 	add.w	r2, r3, #36	; 0x24
  4017be:	687b      	ldr	r3, [r7, #4]
  4017c0:	4610      	mov	r0, r2
  4017c2:	4619      	mov	r1, r3
  4017c4:	4b20      	ldr	r3, [pc, #128]	; (401848 <xQueueGenericReceive+0x224>)
  4017c6:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
  4017c8:	6a38      	ldr	r0, [r7, #32]
  4017ca:	4b20      	ldr	r3, [pc, #128]	; (40184c <xQueueGenericReceive+0x228>)
  4017cc:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
  4017ce:	4b20      	ldr	r3, [pc, #128]	; (401850 <xQueueGenericReceive+0x22c>)
  4017d0:	4798      	blx	r3
  4017d2:	4603      	mov	r3, r0
  4017d4:	2b00      	cmp	r3, #0
  4017d6:	d115      	bne.n	401804 <xQueueGenericReceive+0x1e0>
				{
					portYIELD_WITHIN_API();
  4017d8:	4b14      	ldr	r3, [pc, #80]	; (40182c <xQueueGenericReceive+0x208>)
  4017da:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  4017de:	601a      	str	r2, [r3, #0]
  4017e0:	f3bf 8f4f 	dsb	sy
  4017e4:	f3bf 8f6f 	isb	sy
  4017e8:	e00c      	b.n	401804 <xQueueGenericReceive+0x1e0>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  4017ea:	6a38      	ldr	r0, [r7, #32]
  4017ec:	4b17      	ldr	r3, [pc, #92]	; (40184c <xQueueGenericReceive+0x228>)
  4017ee:	4798      	blx	r3
				( void ) xTaskResumeAll();
  4017f0:	4b17      	ldr	r3, [pc, #92]	; (401850 <xQueueGenericReceive+0x22c>)
  4017f2:	4798      	blx	r3
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
  4017f4:	e74c      	b.n	401690 <xQueueGenericReceive+0x6c>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
  4017f6:	6a38      	ldr	r0, [r7, #32]
  4017f8:	4b14      	ldr	r3, [pc, #80]	; (40184c <xQueueGenericReceive+0x228>)
  4017fa:	4798      	blx	r3
			( void ) xTaskResumeAll();
  4017fc:	4b14      	ldr	r3, [pc, #80]	; (401850 <xQueueGenericReceive+0x22c>)
  4017fe:	4798      	blx	r3
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
  401800:	2300      	movs	r3, #0
  401802:	e000      	b.n	401806 <xQueueGenericReceive+0x1e2>
		}
	}
  401804:	e744      	b.n	401690 <xQueueGenericReceive+0x6c>
}
  401806:	4618      	mov	r0, r3
  401808:	3728      	adds	r7, #40	; 0x28
  40180a:	46bd      	mov	sp, r7
  40180c:	bd80      	pop	{r7, pc}
  40180e:	bf00      	nop
  401810:	004045ec 	.word	0x004045ec
  401814:	004004d1 	.word	0x004004d1
  401818:	00402b15 	.word	0x00402b15
  40181c:	004008dd 	.word	0x004008dd
  401820:	00401939 	.word	0x00401939
  401824:	00402d31 	.word	0x00402d31
  401828:	00402555 	.word	0x00402555
  40182c:	e000ed04 	.word	0xe000ed04
  401830:	00400931 	.word	0x00400931
  401834:	00402625 	.word	0x00402625
  401838:	00401f59 	.word	0x00401f59
  40183c:	00402665 	.word	0x00402665
  401840:	00401a51 	.word	0x00401a51
  401844:	00402b51 	.word	0x00402b51
  401848:	00402425 	.word	0x00402425
  40184c:	00401989 	.word	0x00401989
  401850:	00401fc5 	.word	0x00401fc5

00401854 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
  401854:	b580      	push	{r7, lr}
  401856:	b086      	sub	sp, #24
  401858:	af00      	add	r7, sp, #0
  40185a:	60f8      	str	r0, [r7, #12]
  40185c:	60b9      	str	r1, [r7, #8]
  40185e:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdFALSE;
  401860:	2300      	movs	r3, #0
  401862:	617b      	str	r3, [r7, #20]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
  401864:	68fb      	ldr	r3, [r7, #12]
  401866:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  401868:	2b00      	cmp	r3, #0
  40186a:	d10d      	bne.n	401888 <prvCopyDataToQueue+0x34>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  40186c:	68fb      	ldr	r3, [r7, #12]
  40186e:	681b      	ldr	r3, [r3, #0]
  401870:	2b00      	cmp	r3, #0
  401872:	d152      	bne.n	40191a <prvCopyDataToQueue+0xc6>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
  401874:	68fb      	ldr	r3, [r7, #12]
  401876:	685b      	ldr	r3, [r3, #4]
  401878:	4618      	mov	r0, r3
  40187a:	4b2d      	ldr	r3, [pc, #180]	; (401930 <prvCopyDataToQueue+0xdc>)
  40187c:	4798      	blx	r3
  40187e:	6178      	str	r0, [r7, #20]
				pxQueue->pxMutexHolder = NULL;
  401880:	68fb      	ldr	r3, [r7, #12]
  401882:	2200      	movs	r2, #0
  401884:	605a      	str	r2, [r3, #4]
  401886:	e048      	b.n	40191a <prvCopyDataToQueue+0xc6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
  401888:	687b      	ldr	r3, [r7, #4]
  40188a:	2b00      	cmp	r3, #0
  40188c:	d11a      	bne.n	4018c4 <prvCopyDataToQueue+0x70>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
  40188e:	68fb      	ldr	r3, [r7, #12]
  401890:	689a      	ldr	r2, [r3, #8]
  401892:	68fb      	ldr	r3, [r7, #12]
  401894:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  401896:	4610      	mov	r0, r2
  401898:	68b9      	ldr	r1, [r7, #8]
  40189a:	461a      	mov	r2, r3
  40189c:	4b25      	ldr	r3, [pc, #148]	; (401934 <prvCopyDataToQueue+0xe0>)
  40189e:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  4018a0:	68fb      	ldr	r3, [r7, #12]
  4018a2:	689a      	ldr	r2, [r3, #8]
  4018a4:	68fb      	ldr	r3, [r7, #12]
  4018a6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4018a8:	441a      	add	r2, r3
  4018aa:	68fb      	ldr	r3, [r7, #12]
  4018ac:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  4018ae:	68fb      	ldr	r3, [r7, #12]
  4018b0:	689a      	ldr	r2, [r3, #8]
  4018b2:	68fb      	ldr	r3, [r7, #12]
  4018b4:	685b      	ldr	r3, [r3, #4]
  4018b6:	429a      	cmp	r2, r3
  4018b8:	d32f      	bcc.n	40191a <prvCopyDataToQueue+0xc6>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
  4018ba:	68fb      	ldr	r3, [r7, #12]
  4018bc:	681a      	ldr	r2, [r3, #0]
  4018be:	68fb      	ldr	r3, [r7, #12]
  4018c0:	609a      	str	r2, [r3, #8]
  4018c2:	e02a      	b.n	40191a <prvCopyDataToQueue+0xc6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  4018c4:	68fb      	ldr	r3, [r7, #12]
  4018c6:	68da      	ldr	r2, [r3, #12]
  4018c8:	68fb      	ldr	r3, [r7, #12]
  4018ca:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4018cc:	4610      	mov	r0, r2
  4018ce:	68b9      	ldr	r1, [r7, #8]
  4018d0:	461a      	mov	r2, r3
  4018d2:	4b18      	ldr	r3, [pc, #96]	; (401934 <prvCopyDataToQueue+0xe0>)
  4018d4:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
  4018d6:	68fb      	ldr	r3, [r7, #12]
  4018d8:	68da      	ldr	r2, [r3, #12]
  4018da:	68fb      	ldr	r3, [r7, #12]
  4018dc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4018de:	425b      	negs	r3, r3
  4018e0:	441a      	add	r2, r3
  4018e2:	68fb      	ldr	r3, [r7, #12]
  4018e4:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  4018e6:	68fb      	ldr	r3, [r7, #12]
  4018e8:	68da      	ldr	r2, [r3, #12]
  4018ea:	68fb      	ldr	r3, [r7, #12]
  4018ec:	681b      	ldr	r3, [r3, #0]
  4018ee:	429a      	cmp	r2, r3
  4018f0:	d207      	bcs.n	401902 <prvCopyDataToQueue+0xae>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
  4018f2:	68fb      	ldr	r3, [r7, #12]
  4018f4:	685a      	ldr	r2, [r3, #4]
  4018f6:	68fb      	ldr	r3, [r7, #12]
  4018f8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4018fa:	425b      	negs	r3, r3
  4018fc:	441a      	add	r2, r3
  4018fe:	68fb      	ldr	r3, [r7, #12]
  401900:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
  401902:	687b      	ldr	r3, [r7, #4]
  401904:	2b02      	cmp	r3, #2
  401906:	d108      	bne.n	40191a <prvCopyDataToQueue+0xc6>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
  401908:	68fb      	ldr	r3, [r7, #12]
  40190a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40190c:	2b00      	cmp	r3, #0
  40190e:	d004      	beq.n	40191a <prvCopyDataToQueue+0xc6>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
  401910:	68fb      	ldr	r3, [r7, #12]
  401912:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  401914:	1e5a      	subs	r2, r3, #1
  401916:	68fb      	ldr	r3, [r7, #12]
  401918:	639a      	str	r2, [r3, #56]	; 0x38
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
  40191a:	68fb      	ldr	r3, [r7, #12]
  40191c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40191e:	1c5a      	adds	r2, r3, #1
  401920:	68fb      	ldr	r3, [r7, #12]
  401922:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
  401924:	697b      	ldr	r3, [r7, #20]
}
  401926:	4618      	mov	r0, r3
  401928:	3718      	adds	r7, #24
  40192a:	46bd      	mov	sp, r7
  40192c:	bd80      	pop	{r7, pc}
  40192e:	bf00      	nop
  401930:	00402c45 	.word	0x00402c45
  401934:	00404239 	.word	0x00404239

00401938 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
  401938:	b580      	push	{r7, lr}
  40193a:	b082      	sub	sp, #8
  40193c:	af00      	add	r7, sp, #0
  40193e:	6078      	str	r0, [r7, #4]
  401940:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
  401942:	687b      	ldr	r3, [r7, #4]
  401944:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  401946:	2b00      	cmp	r3, #0
  401948:	d019      	beq.n	40197e <prvCopyDataFromQueue+0x46>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
  40194a:	687b      	ldr	r3, [r7, #4]
  40194c:	68da      	ldr	r2, [r3, #12]
  40194e:	687b      	ldr	r3, [r7, #4]
  401950:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  401952:	441a      	add	r2, r3
  401954:	687b      	ldr	r3, [r7, #4]
  401956:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
  401958:	687b      	ldr	r3, [r7, #4]
  40195a:	68da      	ldr	r2, [r3, #12]
  40195c:	687b      	ldr	r3, [r7, #4]
  40195e:	685b      	ldr	r3, [r3, #4]
  401960:	429a      	cmp	r2, r3
  401962:	d303      	bcc.n	40196c <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
  401964:	687b      	ldr	r3, [r7, #4]
  401966:	681a      	ldr	r2, [r3, #0]
  401968:	687b      	ldr	r3, [r7, #4]
  40196a:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
  40196c:	687b      	ldr	r3, [r7, #4]
  40196e:	68da      	ldr	r2, [r3, #12]
  401970:	687b      	ldr	r3, [r7, #4]
  401972:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  401974:	6838      	ldr	r0, [r7, #0]
  401976:	4611      	mov	r1, r2
  401978:	461a      	mov	r2, r3
  40197a:	4b02      	ldr	r3, [pc, #8]	; (401984 <prvCopyDataFromQueue+0x4c>)
  40197c:	4798      	blx	r3
	}
}
  40197e:	3708      	adds	r7, #8
  401980:	46bd      	mov	sp, r7
  401982:	bd80      	pop	{r7, pc}
  401984:	00404239 	.word	0x00404239

00401988 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
  401988:	b580      	push	{r7, lr}
  40198a:	b082      	sub	sp, #8
  40198c:	af00      	add	r7, sp, #0
  40198e:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
  401990:	4b2a      	ldr	r3, [pc, #168]	; (401a3c <prvUnlockQueue+0xb4>)
  401992:	4798      	blx	r3
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  401994:	e022      	b.n	4019dc <prvUnlockQueue+0x54>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			#if ( configUSE_QUEUE_SETS == 1 )
			{
				if( pxQueue->pxQueueSetContainer != NULL )
  401996:	687b      	ldr	r3, [r7, #4]
  401998:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  40199a:	2b00      	cmp	r3, #0
  40199c:	d009      	beq.n	4019b2 <prvUnlockQueue+0x2a>
				{
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
  40199e:	6878      	ldr	r0, [r7, #4]
  4019a0:	2100      	movs	r1, #0
  4019a2:	4b27      	ldr	r3, [pc, #156]	; (401a40 <prvUnlockQueue+0xb8>)
  4019a4:	4798      	blx	r3
  4019a6:	4603      	mov	r3, r0
  4019a8:	2b01      	cmp	r3, #1
  4019aa:	d112      	bne.n	4019d2 <prvUnlockQueue+0x4a>
					{
						/* The queue is a member of a queue set, and posting to
						the queue set caused a higher priority task to unblock.
						A context switch is required. */
						vTaskMissedYield();
  4019ac:	4b25      	ldr	r3, [pc, #148]	; (401a44 <prvUnlockQueue+0xbc>)
  4019ae:	4798      	blx	r3
  4019b0:	e00f      	b.n	4019d2 <prvUnlockQueue+0x4a>
				}
				else
				{
					/* Tasks that are removed from the event list will get added to
					the pending ready list as the scheduler is still suspended. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4019b2:	687b      	ldr	r3, [r7, #4]
  4019b4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  4019b6:	2b00      	cmp	r3, #0
  4019b8:	d00a      	beq.n	4019d0 <prvUnlockQueue+0x48>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  4019ba:	687b      	ldr	r3, [r7, #4]
  4019bc:	3324      	adds	r3, #36	; 0x24
  4019be:	4618      	mov	r0, r3
  4019c0:	4b21      	ldr	r3, [pc, #132]	; (401a48 <prvUnlockQueue+0xc0>)
  4019c2:	4798      	blx	r3
  4019c4:	4603      	mov	r3, r0
  4019c6:	2b00      	cmp	r3, #0
  4019c8:	d003      	beq.n	4019d2 <prvUnlockQueue+0x4a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							vTaskMissedYield();
  4019ca:	4b1e      	ldr	r3, [pc, #120]	; (401a44 <prvUnlockQueue+0xbc>)
  4019cc:	4798      	blx	r3
  4019ce:	e000      	b.n	4019d2 <prvUnlockQueue+0x4a>
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else
					{
						break;
  4019d0:	e008      	b.n	4019e4 <prvUnlockQueue+0x5c>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
  4019d2:	687b      	ldr	r3, [r7, #4]
  4019d4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  4019d6:	1e5a      	subs	r2, r3, #1
  4019d8:	687b      	ldr	r3, [r7, #4]
  4019da:	649a      	str	r2, [r3, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  4019dc:	687b      	ldr	r3, [r7, #4]
  4019de:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  4019e0:	2b00      	cmp	r3, #0
  4019e2:	dcd8      	bgt.n	401996 <prvUnlockQueue+0xe>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
  4019e4:	687b      	ldr	r3, [r7, #4]
  4019e6:	f04f 32ff 	mov.w	r2, #4294967295
  4019ea:	649a      	str	r2, [r3, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
  4019ec:	4b17      	ldr	r3, [pc, #92]	; (401a4c <prvUnlockQueue+0xc4>)
  4019ee:	4798      	blx	r3

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
  4019f0:	4b12      	ldr	r3, [pc, #72]	; (401a3c <prvUnlockQueue+0xb4>)
  4019f2:	4798      	blx	r3
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  4019f4:	e014      	b.n	401a20 <prvUnlockQueue+0x98>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  4019f6:	687b      	ldr	r3, [r7, #4]
  4019f8:	691b      	ldr	r3, [r3, #16]
  4019fa:	2b00      	cmp	r3, #0
  4019fc:	d00f      	beq.n	401a1e <prvUnlockQueue+0x96>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  4019fe:	687b      	ldr	r3, [r7, #4]
  401a00:	3310      	adds	r3, #16
  401a02:	4618      	mov	r0, r3
  401a04:	4b10      	ldr	r3, [pc, #64]	; (401a48 <prvUnlockQueue+0xc0>)
  401a06:	4798      	blx	r3
  401a08:	4603      	mov	r3, r0
  401a0a:	2b00      	cmp	r3, #0
  401a0c:	d001      	beq.n	401a12 <prvUnlockQueue+0x8a>
				{
					vTaskMissedYield();
  401a0e:	4b0d      	ldr	r3, [pc, #52]	; (401a44 <prvUnlockQueue+0xbc>)
  401a10:	4798      	blx	r3
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
  401a12:	687b      	ldr	r3, [r7, #4]
  401a14:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  401a16:	1e5a      	subs	r2, r3, #1
  401a18:	687b      	ldr	r3, [r7, #4]
  401a1a:	645a      	str	r2, [r3, #68]	; 0x44
  401a1c:	e000      	b.n	401a20 <prvUnlockQueue+0x98>
			}
			else
			{
				break;
  401a1e:	e003      	b.n	401a28 <prvUnlockQueue+0xa0>
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  401a20:	687b      	ldr	r3, [r7, #4]
  401a22:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  401a24:	2b00      	cmp	r3, #0
  401a26:	dce6      	bgt.n	4019f6 <prvUnlockQueue+0x6e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
  401a28:	687b      	ldr	r3, [r7, #4]
  401a2a:	f04f 32ff 	mov.w	r2, #4294967295
  401a2e:	645a      	str	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
  401a30:	4b06      	ldr	r3, [pc, #24]	; (401a4c <prvUnlockQueue+0xc4>)
  401a32:	4798      	blx	r3
}
  401a34:	3708      	adds	r7, #8
  401a36:	46bd      	mov	sp, r7
  401a38:	bd80      	pop	{r7, pc}
  401a3a:	bf00      	nop
  401a3c:	004008dd 	.word	0x004008dd
  401a40:	00401b75 	.word	0x00401b75
  401a44:	00402721 	.word	0x00402721
  401a48:	00402555 	.word	0x00402555
  401a4c:	00400931 	.word	0x00400931

00401a50 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
  401a50:	b580      	push	{r7, lr}
  401a52:	b084      	sub	sp, #16
  401a54:	af00      	add	r7, sp, #0
  401a56:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
  401a58:	4b08      	ldr	r3, [pc, #32]	; (401a7c <prvIsQueueEmpty+0x2c>)
  401a5a:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
  401a5c:	687b      	ldr	r3, [r7, #4]
  401a5e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  401a60:	2b00      	cmp	r3, #0
  401a62:	d102      	bne.n	401a6a <prvIsQueueEmpty+0x1a>
		{
			xReturn = pdTRUE;
  401a64:	2301      	movs	r3, #1
  401a66:	60fb      	str	r3, [r7, #12]
  401a68:	e001      	b.n	401a6e <prvIsQueueEmpty+0x1e>
		}
		else
		{
			xReturn = pdFALSE;
  401a6a:	2300      	movs	r3, #0
  401a6c:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
  401a6e:	4b04      	ldr	r3, [pc, #16]	; (401a80 <prvIsQueueEmpty+0x30>)
  401a70:	4798      	blx	r3

	return xReturn;
  401a72:	68fb      	ldr	r3, [r7, #12]
}
  401a74:	4618      	mov	r0, r3
  401a76:	3710      	adds	r7, #16
  401a78:	46bd      	mov	sp, r7
  401a7a:	bd80      	pop	{r7, pc}
  401a7c:	004008dd 	.word	0x004008dd
  401a80:	00400931 	.word	0x00400931

00401a84 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
  401a84:	b580      	push	{r7, lr}
  401a86:	b084      	sub	sp, #16
  401a88:	af00      	add	r7, sp, #0
  401a8a:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
  401a8c:	4b09      	ldr	r3, [pc, #36]	; (401ab4 <prvIsQueueFull+0x30>)
  401a8e:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
  401a90:	687b      	ldr	r3, [r7, #4]
  401a92:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  401a94:	687b      	ldr	r3, [r7, #4]
  401a96:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  401a98:	429a      	cmp	r2, r3
  401a9a:	d102      	bne.n	401aa2 <prvIsQueueFull+0x1e>
		{
			xReturn = pdTRUE;
  401a9c:	2301      	movs	r3, #1
  401a9e:	60fb      	str	r3, [r7, #12]
  401aa0:	e001      	b.n	401aa6 <prvIsQueueFull+0x22>
		}
		else
		{
			xReturn = pdFALSE;
  401aa2:	2300      	movs	r3, #0
  401aa4:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
  401aa6:	4b04      	ldr	r3, [pc, #16]	; (401ab8 <prvIsQueueFull+0x34>)
  401aa8:	4798      	blx	r3

	return xReturn;
  401aaa:	68fb      	ldr	r3, [r7, #12]
}
  401aac:	4618      	mov	r0, r3
  401aae:	3710      	adds	r7, #16
  401ab0:	46bd      	mov	sp, r7
  401ab2:	bd80      	pop	{r7, pc}
  401ab4:	004008dd 	.word	0x004008dd
  401ab8:	00400931 	.word	0x00400931

00401abc <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
  401abc:	b480      	push	{r7}
  401abe:	b085      	sub	sp, #20
  401ac0:	af00      	add	r7, sp, #0
  401ac2:	6078      	str	r0, [r7, #4]
  401ac4:	6039      	str	r1, [r7, #0]
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
  401ac6:	2300      	movs	r3, #0
  401ac8:	60fb      	str	r3, [r7, #12]
  401aca:	e014      	b.n	401af6 <vQueueAddToRegistry+0x3a>
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
  401acc:	4b0e      	ldr	r3, [pc, #56]	; (401b08 <vQueueAddToRegistry+0x4c>)
  401ace:	68fa      	ldr	r2, [r7, #12]
  401ad0:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
  401ad4:	2b00      	cmp	r3, #0
  401ad6:	d10b      	bne.n	401af0 <vQueueAddToRegistry+0x34>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
  401ad8:	4b0b      	ldr	r3, [pc, #44]	; (401b08 <vQueueAddToRegistry+0x4c>)
  401ada:	68fa      	ldr	r2, [r7, #12]
  401adc:	6839      	ldr	r1, [r7, #0]
  401ade:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
  401ae2:	4a09      	ldr	r2, [pc, #36]	; (401b08 <vQueueAddToRegistry+0x4c>)
  401ae4:	68fb      	ldr	r3, [r7, #12]
  401ae6:	00db      	lsls	r3, r3, #3
  401ae8:	4413      	add	r3, r2
  401aea:	687a      	ldr	r2, [r7, #4]
  401aec:	605a      	str	r2, [r3, #4]

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
  401aee:	e005      	b.n	401afc <vQueueAddToRegistry+0x40>
	{
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
  401af0:	68fb      	ldr	r3, [r7, #12]
  401af2:	3301      	adds	r3, #1
  401af4:	60fb      	str	r3, [r7, #12]
  401af6:	68fb      	ldr	r3, [r7, #12]
  401af8:	2b07      	cmp	r3, #7
  401afa:	d9e7      	bls.n	401acc <vQueueAddToRegistry+0x10>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
  401afc:	3714      	adds	r7, #20
  401afe:	46bd      	mov	sp, r7
  401b00:	f85d 7b04 	ldr.w	r7, [sp], #4
  401b04:	4770      	bx	lr
  401b06:	bf00      	nop
  401b08:	2000c450 	.word	0x2000c450

00401b0c <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait )
	{
  401b0c:	b580      	push	{r7, lr}
  401b0e:	b084      	sub	sp, #16
  401b10:	af00      	add	r7, sp, #0
  401b12:	6078      	str	r0, [r7, #4]
  401b14:	6039      	str	r1, [r7, #0]
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  401b16:	687b      	ldr	r3, [r7, #4]
  401b18:	60fb      	str	r3, [r7, #12]
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
  401b1a:	4b12      	ldr	r3, [pc, #72]	; (401b64 <vQueueWaitForMessageRestricted+0x58>)
  401b1c:	4798      	blx	r3
  401b1e:	68fb      	ldr	r3, [r7, #12]
  401b20:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  401b22:	f1b3 3fff 	cmp.w	r3, #4294967295
  401b26:	d102      	bne.n	401b2e <vQueueWaitForMessageRestricted+0x22>
  401b28:	68fb      	ldr	r3, [r7, #12]
  401b2a:	2200      	movs	r2, #0
  401b2c:	645a      	str	r2, [r3, #68]	; 0x44
  401b2e:	68fb      	ldr	r3, [r7, #12]
  401b30:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  401b32:	f1b3 3fff 	cmp.w	r3, #4294967295
  401b36:	d102      	bne.n	401b3e <vQueueWaitForMessageRestricted+0x32>
  401b38:	68fb      	ldr	r3, [r7, #12]
  401b3a:	2200      	movs	r2, #0
  401b3c:	649a      	str	r2, [r3, #72]	; 0x48
  401b3e:	4b0a      	ldr	r3, [pc, #40]	; (401b68 <vQueueWaitForMessageRestricted+0x5c>)
  401b40:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  401b42:	68fb      	ldr	r3, [r7, #12]
  401b44:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  401b46:	2b00      	cmp	r3, #0
  401b48:	d105      	bne.n	401b56 <vQueueWaitForMessageRestricted+0x4a>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  401b4a:	68fb      	ldr	r3, [r7, #12]
  401b4c:	3324      	adds	r3, #36	; 0x24
  401b4e:	4618      	mov	r0, r3
  401b50:	6839      	ldr	r1, [r7, #0]
  401b52:	4b06      	ldr	r3, [pc, #24]	; (401b6c <vQueueWaitForMessageRestricted+0x60>)
  401b54:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
  401b56:	68f8      	ldr	r0, [r7, #12]
  401b58:	4b05      	ldr	r3, [pc, #20]	; (401b70 <vQueueWaitForMessageRestricted+0x64>)
  401b5a:	4798      	blx	r3
	}
  401b5c:	3710      	adds	r7, #16
  401b5e:	46bd      	mov	sp, r7
  401b60:	bd80      	pop	{r7, pc}
  401b62:	bf00      	nop
  401b64:	004008dd 	.word	0x004008dd
  401b68:	00400931 	.word	0x00400931
  401b6c:	004024cd 	.word	0x004024cd
  401b70:	00401989 	.word	0x00401989

00401b74 <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
	{
  401b74:	b580      	push	{r7, lr}
  401b76:	b084      	sub	sp, #16
  401b78:	af00      	add	r7, sp, #0
  401b7a:	6078      	str	r0, [r7, #4]
  401b7c:	6039      	str	r1, [r7, #0]
	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
  401b7e:	687b      	ldr	r3, [r7, #4]
  401b80:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  401b82:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn = pdFALSE;
  401b84:	2300      	movs	r3, #0
  401b86:	60fb      	str	r3, [r7, #12]

		/* This function must be called form a critical section. */

		configASSERT( pxQueueSetContainer );
  401b88:	68bb      	ldr	r3, [r7, #8]
  401b8a:	2b00      	cmp	r3, #0
  401b8c:	d104      	bne.n	401b98 <prvNotifyQueueSetContainer+0x24>
  401b8e:	f640 10f9 	movw	r0, #2553	; 0x9f9
  401b92:	4917      	ldr	r1, [pc, #92]	; (401bf0 <prvNotifyQueueSetContainer+0x7c>)
  401b94:	4b17      	ldr	r3, [pc, #92]	; (401bf4 <prvNotifyQueueSetContainer+0x80>)
  401b96:	4798      	blx	r3
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
  401b98:	68bb      	ldr	r3, [r7, #8]
  401b9a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  401b9c:	68bb      	ldr	r3, [r7, #8]
  401b9e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  401ba0:	429a      	cmp	r2, r3
  401ba2:	d304      	bcc.n	401bae <prvNotifyQueueSetContainer+0x3a>
  401ba4:	f640 10fa 	movw	r0, #2554	; 0x9fa
  401ba8:	4911      	ldr	r1, [pc, #68]	; (401bf0 <prvNotifyQueueSetContainer+0x7c>)
  401baa:	4b12      	ldr	r3, [pc, #72]	; (401bf4 <prvNotifyQueueSetContainer+0x80>)
  401bac:	4798      	blx	r3

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
  401bae:	68bb      	ldr	r3, [r7, #8]
  401bb0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  401bb2:	68bb      	ldr	r3, [r7, #8]
  401bb4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  401bb6:	429a      	cmp	r2, r3
  401bb8:	d214      	bcs.n	401be4 <prvNotifyQueueSetContainer+0x70>
		{
			traceQUEUE_SEND( pxQueueSetContainer );
			/* The data copied is the handle of the queue that contains data. */
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
  401bba:	1d3b      	adds	r3, r7, #4
  401bbc:	68b8      	ldr	r0, [r7, #8]
  401bbe:	4619      	mov	r1, r3
  401bc0:	683a      	ldr	r2, [r7, #0]
  401bc2:	4b0d      	ldr	r3, [pc, #52]	; (401bf8 <prvNotifyQueueSetContainer+0x84>)
  401bc4:	4798      	blx	r3
  401bc6:	60f8      	str	r0, [r7, #12]

			if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
  401bc8:	68bb      	ldr	r3, [r7, #8]
  401bca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  401bcc:	2b00      	cmp	r3, #0
  401bce:	d009      	beq.n	401be4 <prvNotifyQueueSetContainer+0x70>
			{
				if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
  401bd0:	68bb      	ldr	r3, [r7, #8]
  401bd2:	3324      	adds	r3, #36	; 0x24
  401bd4:	4618      	mov	r0, r3
  401bd6:	4b09      	ldr	r3, [pc, #36]	; (401bfc <prvNotifyQueueSetContainer+0x88>)
  401bd8:	4798      	blx	r3
  401bda:	4603      	mov	r3, r0
  401bdc:	2b00      	cmp	r3, #0
  401bde:	d001      	beq.n	401be4 <prvNotifyQueueSetContainer+0x70>
				{
					/* The task waiting has a higher priority */
					xReturn = pdTRUE;
  401be0:	2301      	movs	r3, #1
  401be2:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
  401be4:	68fb      	ldr	r3, [r7, #12]
	}
  401be6:	4618      	mov	r0, r3
  401be8:	3710      	adds	r7, #16
  401bea:	46bd      	mov	sp, r7
  401bec:	bd80      	pop	{r7, pc}
  401bee:	bf00      	nop
  401bf0:	004045ec 	.word	0x004045ec
  401bf4:	004004d1 	.word	0x004004d1
  401bf8:	00401855 	.word	0x00401855
  401bfc:	00402555 	.word	0x00402555

00401c00 <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
  401c00:	b590      	push	{r4, r7, lr}
  401c02:	b08b      	sub	sp, #44	; 0x2c
  401c04:	af02      	add	r7, sp, #8
  401c06:	60f8      	str	r0, [r7, #12]
  401c08:	60b9      	str	r1, [r7, #8]
  401c0a:	603b      	str	r3, [r7, #0]
  401c0c:	4613      	mov	r3, r2
  401c0e:	80fb      	strh	r3, [r7, #6]
BaseType_t xReturn;
TCB_t * pxNewTCB;
StackType_t *pxTopOfStack;

	configASSERT( pxTaskCode );
  401c10:	68fb      	ldr	r3, [r7, #12]
  401c12:	2b00      	cmp	r3, #0
  401c14:	d104      	bne.n	401c20 <xTaskGenericCreate+0x20>
  401c16:	f240 2029 	movw	r0, #553	; 0x229
  401c1a:	4952      	ldr	r1, [pc, #328]	; (401d64 <xTaskGenericCreate+0x164>)
  401c1c:	4b52      	ldr	r3, [pc, #328]	; (401d68 <xTaskGenericCreate+0x168>)
  401c1e:	4798      	blx	r3
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
  401c20:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401c22:	2b04      	cmp	r3, #4
  401c24:	d904      	bls.n	401c30 <xTaskGenericCreate+0x30>
  401c26:	f240 202a 	movw	r0, #554	; 0x22a
  401c2a:	494e      	ldr	r1, [pc, #312]	; (401d64 <xTaskGenericCreate+0x164>)
  401c2c:	4b4e      	ldr	r3, [pc, #312]	; (401d68 <xTaskGenericCreate+0x168>)
  401c2e:	4798      	blx	r3

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
  401c30:	88fb      	ldrh	r3, [r7, #6]
  401c32:	4618      	mov	r0, r3
  401c34:	6bb9      	ldr	r1, [r7, #56]	; 0x38
  401c36:	4b4d      	ldr	r3, [pc, #308]	; (401d6c <xTaskGenericCreate+0x16c>)
  401c38:	4798      	blx	r3
  401c3a:	61b8      	str	r0, [r7, #24]

	if( pxNewTCB != NULL )
  401c3c:	69bb      	ldr	r3, [r7, #24]
  401c3e:	2b00      	cmp	r3, #0
  401c40:	d073      	beq.n	401d2a <xTaskGenericCreate+0x12a>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
  401c42:	69bb      	ldr	r3, [r7, #24]
  401c44:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  401c46:	88fb      	ldrh	r3, [r7, #6]
  401c48:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
  401c4c:	3b01      	subs	r3, #1
  401c4e:	009b      	lsls	r3, r3, #2
  401c50:	4413      	add	r3, r2
  401c52:	617b      	str	r3, [r7, #20]
			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
  401c54:	697b      	ldr	r3, [r7, #20]
  401c56:	f023 0307 	bic.w	r3, r3, #7
  401c5a:	617b      	str	r3, [r7, #20]

			/* Check the alignment of the calculated top of stack is correct. */
			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
  401c5c:	697b      	ldr	r3, [r7, #20]
  401c5e:	f003 0307 	and.w	r3, r3, #7
  401c62:	2b00      	cmp	r3, #0
  401c64:	d004      	beq.n	401c70 <xTaskGenericCreate+0x70>
  401c66:	f44f 7016 	mov.w	r0, #600	; 0x258
  401c6a:	493e      	ldr	r1, [pc, #248]	; (401d64 <xTaskGenericCreate+0x164>)
  401c6c:	4b3e      	ldr	r3, [pc, #248]	; (401d68 <xTaskGenericCreate+0x168>)
  401c6e:	4798      	blx	r3
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
  401c70:	88fb      	ldrh	r3, [r7, #6]
  401c72:	9300      	str	r3, [sp, #0]
  401c74:	69b8      	ldr	r0, [r7, #24]
  401c76:	68b9      	ldr	r1, [r7, #8]
  401c78:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  401c7a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  401c7c:	4c3c      	ldr	r4, [pc, #240]	; (401d70 <xTaskGenericCreate+0x170>)
  401c7e:	47a0      	blx	r4
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  401c80:	6978      	ldr	r0, [r7, #20]
  401c82:	68f9      	ldr	r1, [r7, #12]
  401c84:	683a      	ldr	r2, [r7, #0]
  401c86:	4b3b      	ldr	r3, [pc, #236]	; (401d74 <xTaskGenericCreate+0x174>)
  401c88:	4798      	blx	r3
  401c8a:	4602      	mov	r2, r0
  401c8c:	69bb      	ldr	r3, [r7, #24]
  401c8e:	601a      	str	r2, [r3, #0]
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
  401c90:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  401c92:	2b00      	cmp	r3, #0
  401c94:	d002      	beq.n	401c9c <xTaskGenericCreate+0x9c>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
  401c96:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  401c98:	69ba      	ldr	r2, [r7, #24]
  401c9a:	601a      	str	r2, [r3, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
  401c9c:	4b36      	ldr	r3, [pc, #216]	; (401d78 <xTaskGenericCreate+0x178>)
  401c9e:	4798      	blx	r3
		{
			uxCurrentNumberOfTasks++;
  401ca0:	4b36      	ldr	r3, [pc, #216]	; (401d7c <xTaskGenericCreate+0x17c>)
  401ca2:	681b      	ldr	r3, [r3, #0]
  401ca4:	1c5a      	adds	r2, r3, #1
  401ca6:	4b35      	ldr	r3, [pc, #212]	; (401d7c <xTaskGenericCreate+0x17c>)
  401ca8:	601a      	str	r2, [r3, #0]
			if( pxCurrentTCB == NULL )
  401caa:	4b35      	ldr	r3, [pc, #212]	; (401d80 <xTaskGenericCreate+0x180>)
  401cac:	681b      	ldr	r3, [r3, #0]
  401cae:	2b00      	cmp	r3, #0
  401cb0:	d109      	bne.n	401cc6 <xTaskGenericCreate+0xc6>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
  401cb2:	4b33      	ldr	r3, [pc, #204]	; (401d80 <xTaskGenericCreate+0x180>)
  401cb4:	69ba      	ldr	r2, [r7, #24]
  401cb6:	601a      	str	r2, [r3, #0]

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
  401cb8:	4b30      	ldr	r3, [pc, #192]	; (401d7c <xTaskGenericCreate+0x17c>)
  401cba:	681b      	ldr	r3, [r3, #0]
  401cbc:	2b01      	cmp	r3, #1
  401cbe:	d10f      	bne.n	401ce0 <xTaskGenericCreate+0xe0>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
  401cc0:	4b30      	ldr	r3, [pc, #192]	; (401d84 <xTaskGenericCreate+0x184>)
  401cc2:	4798      	blx	r3
  401cc4:	e00c      	b.n	401ce0 <xTaskGenericCreate+0xe0>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
  401cc6:	4b30      	ldr	r3, [pc, #192]	; (401d88 <xTaskGenericCreate+0x188>)
  401cc8:	681b      	ldr	r3, [r3, #0]
  401cca:	2b00      	cmp	r3, #0
  401ccc:	d108      	bne.n	401ce0 <xTaskGenericCreate+0xe0>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
  401cce:	4b2c      	ldr	r3, [pc, #176]	; (401d80 <xTaskGenericCreate+0x180>)
  401cd0:	681b      	ldr	r3, [r3, #0]
  401cd2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  401cd4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401cd6:	429a      	cmp	r2, r3
  401cd8:	d802      	bhi.n	401ce0 <xTaskGenericCreate+0xe0>
					{
						pxCurrentTCB = pxNewTCB;
  401cda:	4b29      	ldr	r3, [pc, #164]	; (401d80 <xTaskGenericCreate+0x180>)
  401cdc:	69ba      	ldr	r2, [r7, #24]
  401cde:	601a      	str	r2, [r3, #0]
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
  401ce0:	4b2a      	ldr	r3, [pc, #168]	; (401d8c <xTaskGenericCreate+0x18c>)
  401ce2:	681b      	ldr	r3, [r3, #0]
  401ce4:	1c5a      	adds	r2, r3, #1
  401ce6:	4b29      	ldr	r3, [pc, #164]	; (401d8c <xTaskGenericCreate+0x18c>)
  401ce8:	601a      	str	r2, [r3, #0]

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
  401cea:	4b28      	ldr	r3, [pc, #160]	; (401d8c <xTaskGenericCreate+0x18c>)
  401cec:	681a      	ldr	r2, [r3, #0]
  401cee:	69bb      	ldr	r3, [r7, #24]
  401cf0:	641a      	str	r2, [r3, #64]	; 0x40
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
  401cf2:	69bb      	ldr	r3, [r7, #24]
  401cf4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  401cf6:	2201      	movs	r2, #1
  401cf8:	409a      	lsls	r2, r3
  401cfa:	4b25      	ldr	r3, [pc, #148]	; (401d90 <xTaskGenericCreate+0x190>)
  401cfc:	681b      	ldr	r3, [r3, #0]
  401cfe:	431a      	orrs	r2, r3
  401d00:	4b23      	ldr	r3, [pc, #140]	; (401d90 <xTaskGenericCreate+0x190>)
  401d02:	601a      	str	r2, [r3, #0]
  401d04:	69bb      	ldr	r3, [r7, #24]
  401d06:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  401d08:	4613      	mov	r3, r2
  401d0a:	009b      	lsls	r3, r3, #2
  401d0c:	4413      	add	r3, r2
  401d0e:	009b      	lsls	r3, r3, #2
  401d10:	4a20      	ldr	r2, [pc, #128]	; (401d94 <xTaskGenericCreate+0x194>)
  401d12:	441a      	add	r2, r3
  401d14:	69bb      	ldr	r3, [r7, #24]
  401d16:	3304      	adds	r3, #4
  401d18:	4610      	mov	r0, r2
  401d1a:	4619      	mov	r1, r3
  401d1c:	4b1e      	ldr	r3, [pc, #120]	; (401d98 <xTaskGenericCreate+0x198>)
  401d1e:	4798      	blx	r3

			xReturn = pdPASS;
  401d20:	2301      	movs	r3, #1
  401d22:	61fb      	str	r3, [r7, #28]
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
  401d24:	4b1d      	ldr	r3, [pc, #116]	; (401d9c <xTaskGenericCreate+0x19c>)
  401d26:	4798      	blx	r3
  401d28:	e002      	b.n	401d30 <xTaskGenericCreate+0x130>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  401d2a:	f04f 33ff 	mov.w	r3, #4294967295
  401d2e:	61fb      	str	r3, [r7, #28]
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
  401d30:	69fb      	ldr	r3, [r7, #28]
  401d32:	2b01      	cmp	r3, #1
  401d34:	d111      	bne.n	401d5a <xTaskGenericCreate+0x15a>
	{
		if( xSchedulerRunning != pdFALSE )
  401d36:	4b14      	ldr	r3, [pc, #80]	; (401d88 <xTaskGenericCreate+0x188>)
  401d38:	681b      	ldr	r3, [r3, #0]
  401d3a:	2b00      	cmp	r3, #0
  401d3c:	d00d      	beq.n	401d5a <xTaskGenericCreate+0x15a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
  401d3e:	4b10      	ldr	r3, [pc, #64]	; (401d80 <xTaskGenericCreate+0x180>)
  401d40:	681b      	ldr	r3, [r3, #0]
  401d42:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  401d44:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401d46:	429a      	cmp	r2, r3
  401d48:	d207      	bcs.n	401d5a <xTaskGenericCreate+0x15a>
			{
				taskYIELD_IF_USING_PREEMPTION();
  401d4a:	4b15      	ldr	r3, [pc, #84]	; (401da0 <xTaskGenericCreate+0x1a0>)
  401d4c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  401d50:	601a      	str	r2, [r3, #0]
  401d52:	f3bf 8f4f 	dsb	sy
  401d56:	f3bf 8f6f 	isb	sy
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
  401d5a:	69fb      	ldr	r3, [r7, #28]
}
  401d5c:	4618      	mov	r0, r3
  401d5e:	3724      	adds	r7, #36	; 0x24
  401d60:	46bd      	mov	sp, r7
  401d62:	bd90      	pop	{r4, r7, pc}
  401d64:	00404614 	.word	0x00404614
  401d68:	004004d1 	.word	0x004004d1
  401d6c:	00402a2d 	.word	0x00402a2d
  401d70:	00402805 	.word	0x00402805
  401d74:	0040071d 	.word	0x0040071d
  401d78:	004008dd 	.word	0x004008dd
  401d7c:	2000c168 	.word	0x2000c168
  401d80:	2000c090 	.word	0x2000c090
  401d84:	004028b1 	.word	0x004028b1
  401d88:	2000c174 	.word	0x2000c174
  401d8c:	2000c184 	.word	0x2000c184
  401d90:	2000c170 	.word	0x2000c170
  401d94:	2000c094 	.word	0x2000c094
  401d98:	00400611 	.word	0x00400611
  401d9c:	00400931 	.word	0x00400931
  401da0:	e000ed04 	.word	0xe000ed04

00401da4 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
  401da4:	b580      	push	{r7, lr}
  401da6:	b086      	sub	sp, #24
  401da8:	af00      	add	r7, sp, #0
  401daa:	6078      	str	r0, [r7, #4]
  401dac:	6039      	str	r1, [r7, #0]
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
  401dae:	2300      	movs	r3, #0
  401db0:	617b      	str	r3, [r7, #20]

		configASSERT( pxPreviousWakeTime );
  401db2:	687b      	ldr	r3, [r7, #4]
  401db4:	2b00      	cmp	r3, #0
  401db6:	d104      	bne.n	401dc2 <vTaskDelayUntil+0x1e>
  401db8:	f240 303b 	movw	r0, #827	; 0x33b
  401dbc:	4934      	ldr	r1, [pc, #208]	; (401e90 <vTaskDelayUntil+0xec>)
  401dbe:	4b35      	ldr	r3, [pc, #212]	; (401e94 <vTaskDelayUntil+0xf0>)
  401dc0:	4798      	blx	r3
		configASSERT( ( xTimeIncrement > 0U ) );
  401dc2:	683b      	ldr	r3, [r7, #0]
  401dc4:	2b00      	cmp	r3, #0
  401dc6:	d104      	bne.n	401dd2 <vTaskDelayUntil+0x2e>
  401dc8:	f44f 704f 	mov.w	r0, #828	; 0x33c
  401dcc:	4930      	ldr	r1, [pc, #192]	; (401e90 <vTaskDelayUntil+0xec>)
  401dce:	4b31      	ldr	r3, [pc, #196]	; (401e94 <vTaskDelayUntil+0xf0>)
  401dd0:	4798      	blx	r3
		configASSERT( uxSchedulerSuspended == 0 );
  401dd2:	4b31      	ldr	r3, [pc, #196]	; (401e98 <vTaskDelayUntil+0xf4>)
  401dd4:	681b      	ldr	r3, [r3, #0]
  401dd6:	2b00      	cmp	r3, #0
  401dd8:	d004      	beq.n	401de4 <vTaskDelayUntil+0x40>
  401dda:	f240 303d 	movw	r0, #829	; 0x33d
  401dde:	492c      	ldr	r1, [pc, #176]	; (401e90 <vTaskDelayUntil+0xec>)
  401de0:	4b2c      	ldr	r3, [pc, #176]	; (401e94 <vTaskDelayUntil+0xf0>)
  401de2:	4798      	blx	r3

		vTaskSuspendAll();
  401de4:	4b2d      	ldr	r3, [pc, #180]	; (401e9c <vTaskDelayUntil+0xf8>)
  401de6:	4798      	blx	r3
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
  401de8:	4b2d      	ldr	r3, [pc, #180]	; (401ea0 <vTaskDelayUntil+0xfc>)
  401dea:	681b      	ldr	r3, [r3, #0]
  401dec:	613b      	str	r3, [r7, #16]

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
  401dee:	687b      	ldr	r3, [r7, #4]
  401df0:	681a      	ldr	r2, [r3, #0]
  401df2:	683b      	ldr	r3, [r7, #0]
  401df4:	4413      	add	r3, r2
  401df6:	60fb      	str	r3, [r7, #12]

			if( xConstTickCount < *pxPreviousWakeTime )
  401df8:	687b      	ldr	r3, [r7, #4]
  401dfa:	681a      	ldr	r2, [r3, #0]
  401dfc:	693b      	ldr	r3, [r7, #16]
  401dfe:	429a      	cmp	r2, r3
  401e00:	d90b      	bls.n	401e1a <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
  401e02:	687b      	ldr	r3, [r7, #4]
  401e04:	681a      	ldr	r2, [r3, #0]
  401e06:	68fb      	ldr	r3, [r7, #12]
  401e08:	429a      	cmp	r2, r3
  401e0a:	d911      	bls.n	401e30 <vTaskDelayUntil+0x8c>
  401e0c:	68fa      	ldr	r2, [r7, #12]
  401e0e:	693b      	ldr	r3, [r7, #16]
  401e10:	429a      	cmp	r2, r3
  401e12:	d90d      	bls.n	401e30 <vTaskDelayUntil+0x8c>
				{
					xShouldDelay = pdTRUE;
  401e14:	2301      	movs	r3, #1
  401e16:	617b      	str	r3, [r7, #20]
  401e18:	e00a      	b.n	401e30 <vTaskDelayUntil+0x8c>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
  401e1a:	687b      	ldr	r3, [r7, #4]
  401e1c:	681a      	ldr	r2, [r3, #0]
  401e1e:	68fb      	ldr	r3, [r7, #12]
  401e20:	429a      	cmp	r2, r3
  401e22:	d803      	bhi.n	401e2c <vTaskDelayUntil+0x88>
  401e24:	68fa      	ldr	r2, [r7, #12]
  401e26:	693b      	ldr	r3, [r7, #16]
  401e28:	429a      	cmp	r2, r3
  401e2a:	d901      	bls.n	401e30 <vTaskDelayUntil+0x8c>
				{
					xShouldDelay = pdTRUE;
  401e2c:	2301      	movs	r3, #1
  401e2e:	617b      	str	r3, [r7, #20]
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
  401e30:	687b      	ldr	r3, [r7, #4]
  401e32:	68fa      	ldr	r2, [r7, #12]
  401e34:	601a      	str	r2, [r3, #0]

			if( xShouldDelay != pdFALSE )
  401e36:	697b      	ldr	r3, [r7, #20]
  401e38:	2b00      	cmp	r3, #0
  401e3a:	d017      	beq.n	401e6c <vTaskDelayUntil+0xc8>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
  401e3c:	4b19      	ldr	r3, [pc, #100]	; (401ea4 <vTaskDelayUntil+0x100>)
  401e3e:	681b      	ldr	r3, [r3, #0]
  401e40:	3304      	adds	r3, #4
  401e42:	4618      	mov	r0, r3
  401e44:	4b18      	ldr	r3, [pc, #96]	; (401ea8 <vTaskDelayUntil+0x104>)
  401e46:	4798      	blx	r3
  401e48:	4603      	mov	r3, r0
  401e4a:	2b00      	cmp	r3, #0
  401e4c:	d10b      	bne.n	401e66 <vTaskDelayUntil+0xc2>
				{
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
  401e4e:	4b15      	ldr	r3, [pc, #84]	; (401ea4 <vTaskDelayUntil+0x100>)
  401e50:	681b      	ldr	r3, [r3, #0]
  401e52:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  401e54:	2201      	movs	r2, #1
  401e56:	fa02 f303 	lsl.w	r3, r2, r3
  401e5a:	43da      	mvns	r2, r3
  401e5c:	4b13      	ldr	r3, [pc, #76]	; (401eac <vTaskDelayUntil+0x108>)
  401e5e:	681b      	ldr	r3, [r3, #0]
  401e60:	401a      	ands	r2, r3
  401e62:	4b12      	ldr	r3, [pc, #72]	; (401eac <vTaskDelayUntil+0x108>)
  401e64:	601a      	str	r2, [r3, #0]
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
  401e66:	68f8      	ldr	r0, [r7, #12]
  401e68:	4b11      	ldr	r3, [pc, #68]	; (401eb0 <vTaskDelayUntil+0x10c>)
  401e6a:	4798      	blx	r3
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
  401e6c:	4b11      	ldr	r3, [pc, #68]	; (401eb4 <vTaskDelayUntil+0x110>)
  401e6e:	4798      	blx	r3
  401e70:	60b8      	str	r0, [r7, #8]

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
  401e72:	68bb      	ldr	r3, [r7, #8]
  401e74:	2b00      	cmp	r3, #0
  401e76:	d107      	bne.n	401e88 <vTaskDelayUntil+0xe4>
		{
			portYIELD_WITHIN_API();
  401e78:	4b0f      	ldr	r3, [pc, #60]	; (401eb8 <vTaskDelayUntil+0x114>)
  401e7a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  401e7e:	601a      	str	r2, [r3, #0]
  401e80:	f3bf 8f4f 	dsb	sy
  401e84:	f3bf 8f6f 	isb	sy
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  401e88:	3718      	adds	r7, #24
  401e8a:	46bd      	mov	sp, r7
  401e8c:	bd80      	pop	{r7, pc}
  401e8e:	bf00      	nop
  401e90:	00404614 	.word	0x00404614
  401e94:	004004d1 	.word	0x004004d1
  401e98:	2000c188 	.word	0x2000c188
  401e9c:	00401f59 	.word	0x00401f59
  401ea0:	2000c16c 	.word	0x2000c16c
  401ea4:	2000c090 	.word	0x2000c090
  401ea8:	004006c9 	.word	0x004006c9
  401eac:	2000c170 	.word	0x2000c170
  401eb0:	004029bd 	.word	0x004029bd
  401eb4:	00401fc5 	.word	0x00401fc5
  401eb8:	e000ed04 	.word	0xe000ed04

00401ebc <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
  401ebc:	b590      	push	{r4, r7, lr}
  401ebe:	b087      	sub	sp, #28
  401ec0:	af04      	add	r7, sp, #16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
  401ec2:	2300      	movs	r3, #0
  401ec4:	9300      	str	r3, [sp, #0]
  401ec6:	2300      	movs	r3, #0
  401ec8:	9301      	str	r3, [sp, #4]
  401eca:	2300      	movs	r3, #0
  401ecc:	9302      	str	r3, [sp, #8]
  401ece:	2300      	movs	r3, #0
  401ed0:	9303      	str	r3, [sp, #12]
  401ed2:	4817      	ldr	r0, [pc, #92]	; (401f30 <vTaskStartScheduler+0x74>)
  401ed4:	4917      	ldr	r1, [pc, #92]	; (401f34 <vTaskStartScheduler+0x78>)
  401ed6:	2278      	movs	r2, #120	; 0x78
  401ed8:	2300      	movs	r3, #0
  401eda:	4c17      	ldr	r4, [pc, #92]	; (401f38 <vTaskStartScheduler+0x7c>)
  401edc:	47a0      	blx	r4
  401ede:	6078      	str	r0, [r7, #4]
	}
	#endif /* INCLUDE_xTaskGetIdleTaskHandle */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
  401ee0:	687b      	ldr	r3, [r7, #4]
  401ee2:	2b01      	cmp	r3, #1
  401ee4:	d102      	bne.n	401eec <vTaskStartScheduler+0x30>
		{
			xReturn = xTimerCreateTimerTask();
  401ee6:	4b15      	ldr	r3, [pc, #84]	; (401f3c <vTaskStartScheduler+0x80>)
  401ee8:	4798      	blx	r3
  401eea:	6078      	str	r0, [r7, #4]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
  401eec:	687b      	ldr	r3, [r7, #4]
  401eee:	2b01      	cmp	r3, #1
  401ef0:	d113      	bne.n	401f1a <vTaskStartScheduler+0x5e>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
  401ef2:	f04f 0350 	mov.w	r3, #80	; 0x50
  401ef6:	f383 8811 	msr	BASEPRI, r3
  401efa:	f3bf 8f6f 	isb	sy
  401efe:	f3bf 8f4f 	dsb	sy
  401f02:	603b      	str	r3, [r7, #0]
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
  401f04:	4b0e      	ldr	r3, [pc, #56]	; (401f40 <vTaskStartScheduler+0x84>)
  401f06:	2201      	movs	r2, #1
  401f08:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
  401f0a:	4b0e      	ldr	r3, [pc, #56]	; (401f44 <vTaskStartScheduler+0x88>)
  401f0c:	2200      	movs	r2, #0
  401f0e:	601a      	str	r2, [r3, #0]

		/* If configGENERATE_RUN_TIME_STATS is defined then the following
		macro must be defined to configure the timer/counter used to generate
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
  401f10:	4b0d      	ldr	r3, [pc, #52]	; (401f48 <vTaskStartScheduler+0x8c>)
  401f12:	4798      	blx	r3

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
  401f14:	4b0d      	ldr	r3, [pc, #52]	; (401f4c <vTaskStartScheduler+0x90>)
  401f16:	4798      	blx	r3
  401f18:	e007      	b.n	401f2a <vTaskStartScheduler+0x6e>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
  401f1a:	687b      	ldr	r3, [r7, #4]
  401f1c:	2b00      	cmp	r3, #0
  401f1e:	d104      	bne.n	401f2a <vTaskStartScheduler+0x6e>
  401f20:	f240 604c 	movw	r0, #1612	; 0x64c
  401f24:	490a      	ldr	r1, [pc, #40]	; (401f50 <vTaskStartScheduler+0x94>)
  401f26:	4b0b      	ldr	r3, [pc, #44]	; (401f54 <vTaskStartScheduler+0x98>)
  401f28:	4798      	blx	r3
	}
}
  401f2a:	370c      	adds	r7, #12
  401f2c:	46bd      	mov	sp, r7
  401f2e:	bd90      	pop	{r4, r7, pc}
  401f30:	00402739 	.word	0x00402739
  401f34:	0040463c 	.word	0x0040463c
  401f38:	00401c01 	.word	0x00401c01
  401f3c:	00402d59 	.word	0x00402d59
  401f40:	2000c174 	.word	0x2000c174
  401f44:	2000c16c 	.word	0x2000c16c
  401f48:	00400509 	.word	0x00400509
  401f4c:	004007fd 	.word	0x004007fd
  401f50:	00404614 	.word	0x00404614
  401f54:	004004d1 	.word	0x004004d1

00401f58 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
  401f58:	b480      	push	{r7}
  401f5a:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
  401f5c:	4b04      	ldr	r3, [pc, #16]	; (401f70 <vTaskSuspendAll+0x18>)
  401f5e:	681b      	ldr	r3, [r3, #0]
  401f60:	1c5a      	adds	r2, r3, #1
  401f62:	4b03      	ldr	r3, [pc, #12]	; (401f70 <vTaskSuspendAll+0x18>)
  401f64:	601a      	str	r2, [r3, #0]
}
  401f66:	46bd      	mov	sp, r7
  401f68:	f85d 7b04 	ldr.w	r7, [sp], #4
  401f6c:	4770      	bx	lr
  401f6e:	bf00      	nop
  401f70:	2000c188 	.word	0x2000c188

00401f74 <prvGetExpectedIdleTime>:
/*----------------------------------------------------------*/

#if ( configUSE_TICKLESS_IDLE != 0 )

	static TickType_t prvGetExpectedIdleTime( void )
	{
  401f74:	b480      	push	{r7}
  401f76:	b083      	sub	sp, #12
  401f78:	af00      	add	r7, sp, #0
	TickType_t xReturn;

		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
  401f7a:	4b0e      	ldr	r3, [pc, #56]	; (401fb4 <prvGetExpectedIdleTime+0x40>)
  401f7c:	681b      	ldr	r3, [r3, #0]
  401f7e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  401f80:	2b00      	cmp	r3, #0
  401f82:	d002      	beq.n	401f8a <prvGetExpectedIdleTime+0x16>
		{
			xReturn = 0;
  401f84:	2300      	movs	r3, #0
  401f86:	607b      	str	r3, [r7, #4]
  401f88:	e00c      	b.n	401fa4 <prvGetExpectedIdleTime+0x30>
		}
		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
  401f8a:	4b0b      	ldr	r3, [pc, #44]	; (401fb8 <prvGetExpectedIdleTime+0x44>)
  401f8c:	681b      	ldr	r3, [r3, #0]
  401f8e:	2b01      	cmp	r3, #1
  401f90:	d902      	bls.n	401f98 <prvGetExpectedIdleTime+0x24>
		{
			/* There are other idle priority tasks in the ready state.  If
			time slicing is used then the very next tick interrupt must be
			processed. */
			xReturn = 0;
  401f92:	2300      	movs	r3, #0
  401f94:	607b      	str	r3, [r7, #4]
  401f96:	e005      	b.n	401fa4 <prvGetExpectedIdleTime+0x30>
		}
		else
		{
			xReturn = xNextTaskUnblockTime - xTickCount;
  401f98:	4b08      	ldr	r3, [pc, #32]	; (401fbc <prvGetExpectedIdleTime+0x48>)
  401f9a:	681a      	ldr	r2, [r3, #0]
  401f9c:	4b08      	ldr	r3, [pc, #32]	; (401fc0 <prvGetExpectedIdleTime+0x4c>)
  401f9e:	681b      	ldr	r3, [r3, #0]
  401fa0:	1ad3      	subs	r3, r2, r3
  401fa2:	607b      	str	r3, [r7, #4]
		}

		return xReturn;
  401fa4:	687b      	ldr	r3, [r7, #4]
	}
  401fa6:	4618      	mov	r0, r3
  401fa8:	370c      	adds	r7, #12
  401faa:	46bd      	mov	sp, r7
  401fac:	f85d 7b04 	ldr.w	r7, [sp], #4
  401fb0:	4770      	bx	lr
  401fb2:	bf00      	nop
  401fb4:	2000c090 	.word	0x2000c090
  401fb8:	2000c094 	.word	0x2000c094
  401fbc:	20000008 	.word	0x20000008
  401fc0:	2000c16c 	.word	0x2000c16c

00401fc4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
  401fc4:	b580      	push	{r7, lr}
  401fc6:	b082      	sub	sp, #8
  401fc8:	af00      	add	r7, sp, #0
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
  401fca:	2300      	movs	r3, #0
  401fcc:	607b      	str	r3, [r7, #4]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
  401fce:	4b3b      	ldr	r3, [pc, #236]	; (4020bc <xTaskResumeAll+0xf8>)
  401fd0:	681b      	ldr	r3, [r3, #0]
  401fd2:	2b00      	cmp	r3, #0
  401fd4:	d104      	bne.n	401fe0 <xTaskResumeAll+0x1c>
  401fd6:	f240 6089 	movw	r0, #1673	; 0x689
  401fda:	4939      	ldr	r1, [pc, #228]	; (4020c0 <xTaskResumeAll+0xfc>)
  401fdc:	4b39      	ldr	r3, [pc, #228]	; (4020c4 <xTaskResumeAll+0x100>)
  401fde:	4798      	blx	r3
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
  401fe0:	4b39      	ldr	r3, [pc, #228]	; (4020c8 <xTaskResumeAll+0x104>)
  401fe2:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
  401fe4:	4b35      	ldr	r3, [pc, #212]	; (4020bc <xTaskResumeAll+0xf8>)
  401fe6:	681b      	ldr	r3, [r3, #0]
  401fe8:	1e5a      	subs	r2, r3, #1
  401fea:	4b34      	ldr	r3, [pc, #208]	; (4020bc <xTaskResumeAll+0xf8>)
  401fec:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  401fee:	4b33      	ldr	r3, [pc, #204]	; (4020bc <xTaskResumeAll+0xf8>)
  401ff0:	681b      	ldr	r3, [r3, #0]
  401ff2:	2b00      	cmp	r3, #0
  401ff4:	d15b      	bne.n	4020ae <xTaskResumeAll+0xea>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
  401ff6:	4b35      	ldr	r3, [pc, #212]	; (4020cc <xTaskResumeAll+0x108>)
  401ff8:	681b      	ldr	r3, [r3, #0]
  401ffa:	2b00      	cmp	r3, #0
  401ffc:	d057      	beq.n	4020ae <xTaskResumeAll+0xea>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  401ffe:	e02e      	b.n	40205e <xTaskResumeAll+0x9a>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
  402000:	4b33      	ldr	r3, [pc, #204]	; (4020d0 <xTaskResumeAll+0x10c>)
  402002:	68db      	ldr	r3, [r3, #12]
  402004:	68db      	ldr	r3, [r3, #12]
  402006:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  402008:	683b      	ldr	r3, [r7, #0]
  40200a:	3318      	adds	r3, #24
  40200c:	4618      	mov	r0, r3
  40200e:	4b31      	ldr	r3, [pc, #196]	; (4020d4 <xTaskResumeAll+0x110>)
  402010:	4798      	blx	r3
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
  402012:	683b      	ldr	r3, [r7, #0]
  402014:	3304      	adds	r3, #4
  402016:	4618      	mov	r0, r3
  402018:	4b2e      	ldr	r3, [pc, #184]	; (4020d4 <xTaskResumeAll+0x110>)
  40201a:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
  40201c:	683b      	ldr	r3, [r7, #0]
  40201e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402020:	2201      	movs	r2, #1
  402022:	409a      	lsls	r2, r3
  402024:	4b2c      	ldr	r3, [pc, #176]	; (4020d8 <xTaskResumeAll+0x114>)
  402026:	681b      	ldr	r3, [r3, #0]
  402028:	431a      	orrs	r2, r3
  40202a:	4b2b      	ldr	r3, [pc, #172]	; (4020d8 <xTaskResumeAll+0x114>)
  40202c:	601a      	str	r2, [r3, #0]
  40202e:	683b      	ldr	r3, [r7, #0]
  402030:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402032:	4613      	mov	r3, r2
  402034:	009b      	lsls	r3, r3, #2
  402036:	4413      	add	r3, r2
  402038:	009b      	lsls	r3, r3, #2
  40203a:	4a28      	ldr	r2, [pc, #160]	; (4020dc <xTaskResumeAll+0x118>)
  40203c:	441a      	add	r2, r3
  40203e:	683b      	ldr	r3, [r7, #0]
  402040:	3304      	adds	r3, #4
  402042:	4610      	mov	r0, r2
  402044:	4619      	mov	r1, r3
  402046:	4b26      	ldr	r3, [pc, #152]	; (4020e0 <xTaskResumeAll+0x11c>)
  402048:	4798      	blx	r3

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  40204a:	683b      	ldr	r3, [r7, #0]
  40204c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  40204e:	4b25      	ldr	r3, [pc, #148]	; (4020e4 <xTaskResumeAll+0x120>)
  402050:	681b      	ldr	r3, [r3, #0]
  402052:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402054:	429a      	cmp	r2, r3
  402056:	d302      	bcc.n	40205e <xTaskResumeAll+0x9a>
					{
						xYieldPending = pdTRUE;
  402058:	4b23      	ldr	r3, [pc, #140]	; (4020e8 <xTaskResumeAll+0x124>)
  40205a:	2201      	movs	r2, #1
  40205c:	601a      	str	r2, [r3, #0]
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  40205e:	4b1c      	ldr	r3, [pc, #112]	; (4020d0 <xTaskResumeAll+0x10c>)
  402060:	681b      	ldr	r3, [r3, #0]
  402062:	2b00      	cmp	r3, #0
  402064:	d1cc      	bne.n	402000 <xTaskResumeAll+0x3c>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
  402066:	4b21      	ldr	r3, [pc, #132]	; (4020ec <xTaskResumeAll+0x128>)
  402068:	681b      	ldr	r3, [r3, #0]
  40206a:	2b00      	cmp	r3, #0
  40206c:	d011      	beq.n	402092 <xTaskResumeAll+0xce>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
  40206e:	e00c      	b.n	40208a <xTaskResumeAll+0xc6>
					{
						if( xTaskIncrementTick() != pdFALSE )
  402070:	4b1f      	ldr	r3, [pc, #124]	; (4020f0 <xTaskResumeAll+0x12c>)
  402072:	4798      	blx	r3
  402074:	4603      	mov	r3, r0
  402076:	2b00      	cmp	r3, #0
  402078:	d002      	beq.n	402080 <xTaskResumeAll+0xbc>
						{
							xYieldPending = pdTRUE;
  40207a:	4b1b      	ldr	r3, [pc, #108]	; (4020e8 <xTaskResumeAll+0x124>)
  40207c:	2201      	movs	r2, #1
  40207e:	601a      	str	r2, [r3, #0]
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
  402080:	4b1a      	ldr	r3, [pc, #104]	; (4020ec <xTaskResumeAll+0x128>)
  402082:	681b      	ldr	r3, [r3, #0]
  402084:	1e5a      	subs	r2, r3, #1
  402086:	4b19      	ldr	r3, [pc, #100]	; (4020ec <xTaskResumeAll+0x128>)
  402088:	601a      	str	r2, [r3, #0]
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
  40208a:	4b18      	ldr	r3, [pc, #96]	; (4020ec <xTaskResumeAll+0x128>)
  40208c:	681b      	ldr	r3, [r3, #0]
  40208e:	2b00      	cmp	r3, #0
  402090:	d1ee      	bne.n	402070 <xTaskResumeAll+0xac>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
  402092:	4b15      	ldr	r3, [pc, #84]	; (4020e8 <xTaskResumeAll+0x124>)
  402094:	681b      	ldr	r3, [r3, #0]
  402096:	2b01      	cmp	r3, #1
  402098:	d109      	bne.n	4020ae <xTaskResumeAll+0xea>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
  40209a:	2301      	movs	r3, #1
  40209c:	607b      	str	r3, [r7, #4]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
  40209e:	4b15      	ldr	r3, [pc, #84]	; (4020f4 <xTaskResumeAll+0x130>)
  4020a0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  4020a4:	601a      	str	r2, [r3, #0]
  4020a6:	f3bf 8f4f 	dsb	sy
  4020aa:	f3bf 8f6f 	isb	sy
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
  4020ae:	4b12      	ldr	r3, [pc, #72]	; (4020f8 <xTaskResumeAll+0x134>)
  4020b0:	4798      	blx	r3

	return xAlreadyYielded;
  4020b2:	687b      	ldr	r3, [r7, #4]
}
  4020b4:	4618      	mov	r0, r3
  4020b6:	3708      	adds	r7, #8
  4020b8:	46bd      	mov	sp, r7
  4020ba:	bd80      	pop	{r7, pc}
  4020bc:	2000c188 	.word	0x2000c188
  4020c0:	00404614 	.word	0x00404614
  4020c4:	004004d1 	.word	0x004004d1
  4020c8:	004008dd 	.word	0x004008dd
  4020cc:	2000c168 	.word	0x2000c168
  4020d0:	2000c128 	.word	0x2000c128
  4020d4:	004006c9 	.word	0x004006c9
  4020d8:	2000c170 	.word	0x2000c170
  4020dc:	2000c094 	.word	0x2000c094
  4020e0:	00400611 	.word	0x00400611
  4020e4:	2000c090 	.word	0x2000c090
  4020e8:	2000c17c 	.word	0x2000c17c
  4020ec:	2000c178 	.word	0x2000c178
  4020f0:	00402161 	.word	0x00402161
  4020f4:	e000ed04 	.word	0xe000ed04
  4020f8:	00400931 	.word	0x00400931

004020fc <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
  4020fc:	b480      	push	{r7}
  4020fe:	b083      	sub	sp, #12
  402100:	af00      	add	r7, sp, #0
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
  402102:	4b05      	ldr	r3, [pc, #20]	; (402118 <xTaskGetTickCount+0x1c>)
  402104:	681b      	ldr	r3, [r3, #0]
  402106:	607b      	str	r3, [r7, #4]
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
  402108:	687b      	ldr	r3, [r7, #4]
}
  40210a:	4618      	mov	r0, r3
  40210c:	370c      	adds	r7, #12
  40210e:	46bd      	mov	sp, r7
  402110:	f85d 7b04 	ldr.w	r7, [sp], #4
  402114:	4770      	bx	lr
  402116:	bf00      	nop
  402118:	2000c16c 	.word	0x2000c16c

0040211c <vTaskStepTick>:
implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1. */
#if ( configUSE_TICKLESS_IDLE != 0 )

	void vTaskStepTick( const TickType_t xTicksToJump )
	{
  40211c:	b580      	push	{r7, lr}
  40211e:	b082      	sub	sp, #8
  402120:	af00      	add	r7, sp, #0
  402122:	6078      	str	r0, [r7, #4]
		/* Correct the tick count value after a period during which the tick
		was suppressed.  Note this does *not* call the tick hook function for
		each stepped tick. */
		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
  402124:	4b0a      	ldr	r3, [pc, #40]	; (402150 <vTaskStepTick+0x34>)
  402126:	681a      	ldr	r2, [r3, #0]
  402128:	687b      	ldr	r3, [r7, #4]
  40212a:	441a      	add	r2, r3
  40212c:	4b09      	ldr	r3, [pc, #36]	; (402154 <vTaskStepTick+0x38>)
  40212e:	681b      	ldr	r3, [r3, #0]
  402130:	429a      	cmp	r2, r3
  402132:	d904      	bls.n	40213e <vTaskStepTick+0x22>
  402134:	f240 7086 	movw	r0, #1926	; 0x786
  402138:	4907      	ldr	r1, [pc, #28]	; (402158 <vTaskStepTick+0x3c>)
  40213a:	4b08      	ldr	r3, [pc, #32]	; (40215c <vTaskStepTick+0x40>)
  40213c:	4798      	blx	r3
		xTickCount += xTicksToJump;
  40213e:	4b04      	ldr	r3, [pc, #16]	; (402150 <vTaskStepTick+0x34>)
  402140:	681a      	ldr	r2, [r3, #0]
  402142:	687b      	ldr	r3, [r7, #4]
  402144:	441a      	add	r2, r3
  402146:	4b02      	ldr	r3, [pc, #8]	; (402150 <vTaskStepTick+0x34>)
  402148:	601a      	str	r2, [r3, #0]
		traceINCREASE_TICK_COUNT( xTicksToJump );
	}
  40214a:	3708      	adds	r7, #8
  40214c:	46bd      	mov	sp, r7
  40214e:	bd80      	pop	{r7, pc}
  402150:	2000c16c 	.word	0x2000c16c
  402154:	20000008 	.word	0x20000008
  402158:	00404614 	.word	0x00404614
  40215c:	004004d1 	.word	0x004004d1

00402160 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
  402160:	b580      	push	{r7, lr}
  402162:	b086      	sub	sp, #24
  402164:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
  402166:	2300      	movs	r3, #0
  402168:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  40216a:	4b4e      	ldr	r3, [pc, #312]	; (4022a4 <xTaskIncrementTick+0x144>)
  40216c:	681b      	ldr	r3, [r3, #0]
  40216e:	2b00      	cmp	r3, #0
  402170:	f040 8088 	bne.w	402284 <xTaskIncrementTick+0x124>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
  402174:	4b4c      	ldr	r3, [pc, #304]	; (4022a8 <xTaskIncrementTick+0x148>)
  402176:	681b      	ldr	r3, [r3, #0]
  402178:	1c5a      	adds	r2, r3, #1
  40217a:	4b4b      	ldr	r3, [pc, #300]	; (4022a8 <xTaskIncrementTick+0x148>)
  40217c:	601a      	str	r2, [r3, #0]

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
  40217e:	4b4a      	ldr	r3, [pc, #296]	; (4022a8 <xTaskIncrementTick+0x148>)
  402180:	681b      	ldr	r3, [r3, #0]
  402182:	613b      	str	r3, [r7, #16]

			if( xConstTickCount == ( TickType_t ) 0U )
  402184:	693b      	ldr	r3, [r7, #16]
  402186:	2b00      	cmp	r3, #0
  402188:	d11a      	bne.n	4021c0 <xTaskIncrementTick+0x60>
			{
				taskSWITCH_DELAYED_LISTS();
  40218a:	4b48      	ldr	r3, [pc, #288]	; (4022ac <xTaskIncrementTick+0x14c>)
  40218c:	681b      	ldr	r3, [r3, #0]
  40218e:	681b      	ldr	r3, [r3, #0]
  402190:	2b00      	cmp	r3, #0
  402192:	d004      	beq.n	40219e <xTaskIncrementTick+0x3e>
  402194:	f240 70a5 	movw	r0, #1957	; 0x7a5
  402198:	4945      	ldr	r1, [pc, #276]	; (4022b0 <xTaskIncrementTick+0x150>)
  40219a:	4b46      	ldr	r3, [pc, #280]	; (4022b4 <xTaskIncrementTick+0x154>)
  40219c:	4798      	blx	r3
  40219e:	4b43      	ldr	r3, [pc, #268]	; (4022ac <xTaskIncrementTick+0x14c>)
  4021a0:	681b      	ldr	r3, [r3, #0]
  4021a2:	60fb      	str	r3, [r7, #12]
  4021a4:	4b44      	ldr	r3, [pc, #272]	; (4022b8 <xTaskIncrementTick+0x158>)
  4021a6:	681a      	ldr	r2, [r3, #0]
  4021a8:	4b40      	ldr	r3, [pc, #256]	; (4022ac <xTaskIncrementTick+0x14c>)
  4021aa:	601a      	str	r2, [r3, #0]
  4021ac:	4b42      	ldr	r3, [pc, #264]	; (4022b8 <xTaskIncrementTick+0x158>)
  4021ae:	68fa      	ldr	r2, [r7, #12]
  4021b0:	601a      	str	r2, [r3, #0]
  4021b2:	4b42      	ldr	r3, [pc, #264]	; (4022bc <xTaskIncrementTick+0x15c>)
  4021b4:	681b      	ldr	r3, [r3, #0]
  4021b6:	1c5a      	adds	r2, r3, #1
  4021b8:	4b40      	ldr	r3, [pc, #256]	; (4022bc <xTaskIncrementTick+0x15c>)
  4021ba:	601a      	str	r2, [r3, #0]
  4021bc:	4b40      	ldr	r3, [pc, #256]	; (4022c0 <xTaskIncrementTick+0x160>)
  4021be:	4798      	blx	r3

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
  4021c0:	4b40      	ldr	r3, [pc, #256]	; (4022c4 <xTaskIncrementTick+0x164>)
  4021c2:	681b      	ldr	r3, [r3, #0]
  4021c4:	693a      	ldr	r2, [r7, #16]
  4021c6:	429a      	cmp	r2, r3
  4021c8:	d34d      	bcc.n	402266 <xTaskIncrementTick+0x106>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  4021ca:	4b38      	ldr	r3, [pc, #224]	; (4022ac <xTaskIncrementTick+0x14c>)
  4021cc:	681b      	ldr	r3, [r3, #0]
  4021ce:	681b      	ldr	r3, [r3, #0]
  4021d0:	2b00      	cmp	r3, #0
  4021d2:	d101      	bne.n	4021d8 <xTaskIncrementTick+0x78>
  4021d4:	2301      	movs	r3, #1
  4021d6:	e000      	b.n	4021da <xTaskIncrementTick+0x7a>
  4021d8:	2300      	movs	r3, #0
  4021da:	2b00      	cmp	r3, #0
  4021dc:	d004      	beq.n	4021e8 <xTaskIncrementTick+0x88>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
  4021de:	4b39      	ldr	r3, [pc, #228]	; (4022c4 <xTaskIncrementTick+0x164>)
  4021e0:	f04f 32ff 	mov.w	r2, #4294967295
  4021e4:	601a      	str	r2, [r3, #0]
						break;
  4021e6:	e03e      	b.n	402266 <xTaskIncrementTick+0x106>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  4021e8:	4b30      	ldr	r3, [pc, #192]	; (4022ac <xTaskIncrementTick+0x14c>)
  4021ea:	681b      	ldr	r3, [r3, #0]
  4021ec:	68db      	ldr	r3, [r3, #12]
  4021ee:	68db      	ldr	r3, [r3, #12]
  4021f0:	60bb      	str	r3, [r7, #8]
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  4021f2:	68bb      	ldr	r3, [r7, #8]
  4021f4:	685b      	ldr	r3, [r3, #4]
  4021f6:	607b      	str	r3, [r7, #4]

						if( xConstTickCount < xItemValue )
  4021f8:	693a      	ldr	r2, [r7, #16]
  4021fa:	687b      	ldr	r3, [r7, #4]
  4021fc:	429a      	cmp	r2, r3
  4021fe:	d203      	bcs.n	402208 <xTaskIncrementTick+0xa8>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
  402200:	4b30      	ldr	r3, [pc, #192]	; (4022c4 <xTaskIncrementTick+0x164>)
  402202:	687a      	ldr	r2, [r7, #4]
  402204:	601a      	str	r2, [r3, #0]
							break;
  402206:	e02e      	b.n	402266 <xTaskIncrementTick+0x106>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
  402208:	68bb      	ldr	r3, [r7, #8]
  40220a:	3304      	adds	r3, #4
  40220c:	4618      	mov	r0, r3
  40220e:	4b2e      	ldr	r3, [pc, #184]	; (4022c8 <xTaskIncrementTick+0x168>)
  402210:	4798      	blx	r3

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  402212:	68bb      	ldr	r3, [r7, #8]
  402214:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  402216:	2b00      	cmp	r3, #0
  402218:	d004      	beq.n	402224 <xTaskIncrementTick+0xc4>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  40221a:	68bb      	ldr	r3, [r7, #8]
  40221c:	3318      	adds	r3, #24
  40221e:	4618      	mov	r0, r3
  402220:	4b29      	ldr	r3, [pc, #164]	; (4022c8 <xTaskIncrementTick+0x168>)
  402222:	4798      	blx	r3
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
  402224:	68bb      	ldr	r3, [r7, #8]
  402226:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402228:	2201      	movs	r2, #1
  40222a:	409a      	lsls	r2, r3
  40222c:	4b27      	ldr	r3, [pc, #156]	; (4022cc <xTaskIncrementTick+0x16c>)
  40222e:	681b      	ldr	r3, [r3, #0]
  402230:	431a      	orrs	r2, r3
  402232:	4b26      	ldr	r3, [pc, #152]	; (4022cc <xTaskIncrementTick+0x16c>)
  402234:	601a      	str	r2, [r3, #0]
  402236:	68bb      	ldr	r3, [r7, #8]
  402238:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  40223a:	4613      	mov	r3, r2
  40223c:	009b      	lsls	r3, r3, #2
  40223e:	4413      	add	r3, r2
  402240:	009b      	lsls	r3, r3, #2
  402242:	4a23      	ldr	r2, [pc, #140]	; (4022d0 <xTaskIncrementTick+0x170>)
  402244:	441a      	add	r2, r3
  402246:	68bb      	ldr	r3, [r7, #8]
  402248:	3304      	adds	r3, #4
  40224a:	4610      	mov	r0, r2
  40224c:	4619      	mov	r1, r3
  40224e:	4b21      	ldr	r3, [pc, #132]	; (4022d4 <xTaskIncrementTick+0x174>)
  402250:	4798      	blx	r3
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  402252:	68bb      	ldr	r3, [r7, #8]
  402254:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402256:	4b20      	ldr	r3, [pc, #128]	; (4022d8 <xTaskIncrementTick+0x178>)
  402258:	681b      	ldr	r3, [r3, #0]
  40225a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40225c:	429a      	cmp	r2, r3
  40225e:	d301      	bcc.n	402264 <xTaskIncrementTick+0x104>
							{
								xSwitchRequired = pdTRUE;
  402260:	2301      	movs	r3, #1
  402262:	617b      	str	r3, [r7, #20]
								mtCOVERAGE_TEST_MARKER();
							}
						}
						#endif /* configUSE_PREEMPTION */
					}
				}
  402264:	e7b1      	b.n	4021ca <xTaskIncrementTick+0x6a>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
  402266:	4b1c      	ldr	r3, [pc, #112]	; (4022d8 <xTaskIncrementTick+0x178>)
  402268:	681b      	ldr	r3, [r3, #0]
  40226a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  40226c:	4918      	ldr	r1, [pc, #96]	; (4022d0 <xTaskIncrementTick+0x170>)
  40226e:	4613      	mov	r3, r2
  402270:	009b      	lsls	r3, r3, #2
  402272:	4413      	add	r3, r2
  402274:	009b      	lsls	r3, r3, #2
  402276:	440b      	add	r3, r1
  402278:	681b      	ldr	r3, [r3, #0]
  40227a:	2b01      	cmp	r3, #1
  40227c:	d907      	bls.n	40228e <xTaskIncrementTick+0x12e>
			{
				xSwitchRequired = pdTRUE;
  40227e:	2301      	movs	r3, #1
  402280:	617b      	str	r3, [r7, #20]
  402282:	e004      	b.n	40228e <xTaskIncrementTick+0x12e>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
  402284:	4b15      	ldr	r3, [pc, #84]	; (4022dc <xTaskIncrementTick+0x17c>)
  402286:	681b      	ldr	r3, [r3, #0]
  402288:	1c5a      	adds	r2, r3, #1
  40228a:	4b14      	ldr	r3, [pc, #80]	; (4022dc <xTaskIncrementTick+0x17c>)
  40228c:	601a      	str	r2, [r3, #0]
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
  40228e:	4b14      	ldr	r3, [pc, #80]	; (4022e0 <xTaskIncrementTick+0x180>)
  402290:	681b      	ldr	r3, [r3, #0]
  402292:	2b00      	cmp	r3, #0
  402294:	d001      	beq.n	40229a <xTaskIncrementTick+0x13a>
		{
			xSwitchRequired = pdTRUE;
  402296:	2301      	movs	r3, #1
  402298:	617b      	str	r3, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
  40229a:	697b      	ldr	r3, [r7, #20]
}
  40229c:	4618      	mov	r0, r3
  40229e:	3718      	adds	r7, #24
  4022a0:	46bd      	mov	sp, r7
  4022a2:	bd80      	pop	{r7, pc}
  4022a4:	2000c188 	.word	0x2000c188
  4022a8:	2000c16c 	.word	0x2000c16c
  4022ac:	2000c120 	.word	0x2000c120
  4022b0:	00404614 	.word	0x00404614
  4022b4:	004004d1 	.word	0x004004d1
  4022b8:	2000c124 	.word	0x2000c124
  4022bc:	2000c180 	.word	0x2000c180
  4022c0:	00402acd 	.word	0x00402acd
  4022c4:	20000008 	.word	0x20000008
  4022c8:	004006c9 	.word	0x004006c9
  4022cc:	2000c170 	.word	0x2000c170
  4022d0:	2000c094 	.word	0x2000c094
  4022d4:	00400611 	.word	0x00400611
  4022d8:	2000c090 	.word	0x2000c090
  4022dc:	2000c178 	.word	0x2000c178
  4022e0:	2000c17c 	.word	0x2000c17c

004022e4 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
  4022e4:	b580      	push	{r7, lr}
  4022e6:	b084      	sub	sp, #16
  4022e8:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
  4022ea:	4b41      	ldr	r3, [pc, #260]	; (4023f0 <vTaskSwitchContext+0x10c>)
  4022ec:	681b      	ldr	r3, [r3, #0]
  4022ee:	2b00      	cmp	r3, #0
  4022f0:	d003      	beq.n	4022fa <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
  4022f2:	4b40      	ldr	r3, [pc, #256]	; (4023f4 <vTaskSwitchContext+0x110>)
  4022f4:	2201      	movs	r2, #1
  4022f6:	601a      	str	r2, [r3, #0]
  4022f8:	e077      	b.n	4023ea <vTaskSwitchContext+0x106>
	}
	else
	{
		xYieldPending = pdFALSE;
  4022fa:	4b3e      	ldr	r3, [pc, #248]	; (4023f4 <vTaskSwitchContext+0x110>)
  4022fc:	2200      	movs	r2, #0
  4022fe:	601a      	str	r2, [r3, #0]
		#if ( configGENERATE_RUN_TIME_STATS == 1 )
		{
				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
				#else
					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
  402300:	4b3d      	ldr	r3, [pc, #244]	; (4023f8 <vTaskSwitchContext+0x114>)
  402302:	4798      	blx	r3
  402304:	4602      	mov	r2, r0
  402306:	4b3d      	ldr	r3, [pc, #244]	; (4023fc <vTaskSwitchContext+0x118>)
  402308:	601a      	str	r2, [r3, #0]
				stored in ulTaskSwitchedInTime.  Note that there is no overflow
				protection here	so count values are only valid until the timer
				overflows.  The guard against negative values is to protect
				against suspect run time stat counter implementations - which
				are provided by the application, not the kernel. */
				if( ulTotalRunTime > ulTaskSwitchedInTime )
  40230a:	4b3c      	ldr	r3, [pc, #240]	; (4023fc <vTaskSwitchContext+0x118>)
  40230c:	681a      	ldr	r2, [r3, #0]
  40230e:	4b3c      	ldr	r3, [pc, #240]	; (402400 <vTaskSwitchContext+0x11c>)
  402310:	681b      	ldr	r3, [r3, #0]
  402312:	429a      	cmp	r2, r3
  402314:	d909      	bls.n	40232a <vTaskSwitchContext+0x46>
				{
					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
  402316:	4b3b      	ldr	r3, [pc, #236]	; (402404 <vTaskSwitchContext+0x120>)
  402318:	681b      	ldr	r3, [r3, #0]
  40231a:	6d19      	ldr	r1, [r3, #80]	; 0x50
  40231c:	4a37      	ldr	r2, [pc, #220]	; (4023fc <vTaskSwitchContext+0x118>)
  40231e:	6810      	ldr	r0, [r2, #0]
  402320:	4a37      	ldr	r2, [pc, #220]	; (402400 <vTaskSwitchContext+0x11c>)
  402322:	6812      	ldr	r2, [r2, #0]
  402324:	1a82      	subs	r2, r0, r2
  402326:	440a      	add	r2, r1
  402328:	651a      	str	r2, [r3, #80]	; 0x50
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				ulTaskSwitchedInTime = ulTotalRunTime;
  40232a:	4b34      	ldr	r3, [pc, #208]	; (4023fc <vTaskSwitchContext+0x118>)
  40232c:	681a      	ldr	r2, [r3, #0]
  40232e:	4b34      	ldr	r3, [pc, #208]	; (402400 <vTaskSwitchContext+0x11c>)
  402330:	601a      	str	r2, [r3, #0]
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
  402332:	4b34      	ldr	r3, [pc, #208]	; (402404 <vTaskSwitchContext+0x120>)
  402334:	681b      	ldr	r3, [r3, #0]
  402336:	681a      	ldr	r2, [r3, #0]
  402338:	4b32      	ldr	r3, [pc, #200]	; (402404 <vTaskSwitchContext+0x120>)
  40233a:	681b      	ldr	r3, [r3, #0]
  40233c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40233e:	429a      	cmp	r2, r3
  402340:	d808      	bhi.n	402354 <vTaskSwitchContext+0x70>
  402342:	4b30      	ldr	r3, [pc, #192]	; (402404 <vTaskSwitchContext+0x120>)
  402344:	681a      	ldr	r2, [r3, #0]
  402346:	4b2f      	ldr	r3, [pc, #188]	; (402404 <vTaskSwitchContext+0x120>)
  402348:	681b      	ldr	r3, [r3, #0]
  40234a:	3334      	adds	r3, #52	; 0x34
  40234c:	4610      	mov	r0, r2
  40234e:	4619      	mov	r1, r3
  402350:	4b2d      	ldr	r3, [pc, #180]	; (402408 <vTaskSwitchContext+0x124>)
  402352:	4798      	blx	r3
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
  402354:	4b2b      	ldr	r3, [pc, #172]	; (402404 <vTaskSwitchContext+0x120>)
  402356:	681b      	ldr	r3, [r3, #0]
  402358:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40235a:	4618      	mov	r0, r3
  40235c:	492b      	ldr	r1, [pc, #172]	; (40240c <vTaskSwitchContext+0x128>)
  40235e:	2214      	movs	r2, #20
  402360:	4b2b      	ldr	r3, [pc, #172]	; (402410 <vTaskSwitchContext+0x12c>)
  402362:	4798      	blx	r3
  402364:	4603      	mov	r3, r0
  402366:	2b00      	cmp	r3, #0
  402368:	d008      	beq.n	40237c <vTaskSwitchContext+0x98>
  40236a:	4b26      	ldr	r3, [pc, #152]	; (402404 <vTaskSwitchContext+0x120>)
  40236c:	681a      	ldr	r2, [r3, #0]
  40236e:	4b25      	ldr	r3, [pc, #148]	; (402404 <vTaskSwitchContext+0x120>)
  402370:	681b      	ldr	r3, [r3, #0]
  402372:	3334      	adds	r3, #52	; 0x34
  402374:	4610      	mov	r0, r2
  402376:	4619      	mov	r1, r3
  402378:	4b23      	ldr	r3, [pc, #140]	; (402408 <vTaskSwitchContext+0x124>)
  40237a:	4798      	blx	r3

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
  40237c:	4b25      	ldr	r3, [pc, #148]	; (402414 <vTaskSwitchContext+0x130>)
  40237e:	681b      	ldr	r3, [r3, #0]
  402380:	607b      	str	r3, [r7, #4]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
	{
	uint8_t ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
  402382:	687b      	ldr	r3, [r7, #4]
  402384:	fab3 f383 	clz	r3, r3
  402388:	70fb      	strb	r3, [r7, #3]
		return ucReturn;
  40238a:	78fb      	ldrb	r3, [r7, #3]
  40238c:	f1c3 031f 	rsb	r3, r3, #31
  402390:	60fb      	str	r3, [r7, #12]
  402392:	4921      	ldr	r1, [pc, #132]	; (402418 <vTaskSwitchContext+0x134>)
  402394:	68fa      	ldr	r2, [r7, #12]
  402396:	4613      	mov	r3, r2
  402398:	009b      	lsls	r3, r3, #2
  40239a:	4413      	add	r3, r2
  40239c:	009b      	lsls	r3, r3, #2
  40239e:	440b      	add	r3, r1
  4023a0:	681b      	ldr	r3, [r3, #0]
  4023a2:	2b00      	cmp	r3, #0
  4023a4:	d104      	bne.n	4023b0 <vTaskSwitchContext+0xcc>
  4023a6:	f640 00c4 	movw	r0, #2244	; 0x8c4
  4023aa:	491c      	ldr	r1, [pc, #112]	; (40241c <vTaskSwitchContext+0x138>)
  4023ac:	4b1c      	ldr	r3, [pc, #112]	; (402420 <vTaskSwitchContext+0x13c>)
  4023ae:	4798      	blx	r3
  4023b0:	68fa      	ldr	r2, [r7, #12]
  4023b2:	4613      	mov	r3, r2
  4023b4:	009b      	lsls	r3, r3, #2
  4023b6:	4413      	add	r3, r2
  4023b8:	009b      	lsls	r3, r3, #2
  4023ba:	4a17      	ldr	r2, [pc, #92]	; (402418 <vTaskSwitchContext+0x134>)
  4023bc:	4413      	add	r3, r2
  4023be:	60bb      	str	r3, [r7, #8]
  4023c0:	68bb      	ldr	r3, [r7, #8]
  4023c2:	685b      	ldr	r3, [r3, #4]
  4023c4:	685a      	ldr	r2, [r3, #4]
  4023c6:	68bb      	ldr	r3, [r7, #8]
  4023c8:	605a      	str	r2, [r3, #4]
  4023ca:	68bb      	ldr	r3, [r7, #8]
  4023cc:	685a      	ldr	r2, [r3, #4]
  4023ce:	68bb      	ldr	r3, [r7, #8]
  4023d0:	3308      	adds	r3, #8
  4023d2:	429a      	cmp	r2, r3
  4023d4:	d104      	bne.n	4023e0 <vTaskSwitchContext+0xfc>
  4023d6:	68bb      	ldr	r3, [r7, #8]
  4023d8:	685b      	ldr	r3, [r3, #4]
  4023da:	685a      	ldr	r2, [r3, #4]
  4023dc:	68bb      	ldr	r3, [r7, #8]
  4023de:	605a      	str	r2, [r3, #4]
  4023e0:	68bb      	ldr	r3, [r7, #8]
  4023e2:	685b      	ldr	r3, [r3, #4]
  4023e4:	68da      	ldr	r2, [r3, #12]
  4023e6:	4b07      	ldr	r3, [pc, #28]	; (402404 <vTaskSwitchContext+0x120>)
  4023e8:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
  4023ea:	3710      	adds	r7, #16
  4023ec:	46bd      	mov	sp, r7
  4023ee:	bd80      	pop	{r7, pc}
  4023f0:	2000c188 	.word	0x2000c188
  4023f4:	2000c17c 	.word	0x2000c17c
  4023f8:	00400541 	.word	0x00400541
  4023fc:	2000c190 	.word	0x2000c190
  402400:	2000c18c 	.word	0x2000c18c
  402404:	2000c090 	.word	0x2000c090
  402408:	004004b1 	.word	0x004004b1
  40240c:	0040466c 	.word	0x0040466c
  402410:	004041d1 	.word	0x004041d1
  402414:	2000c170 	.word	0x2000c170
  402418:	2000c094 	.word	0x2000c094
  40241c:	00404614 	.word	0x00404614
  402420:	004004d1 	.word	0x004004d1

00402424 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
  402424:	b580      	push	{r7, lr}
  402426:	b084      	sub	sp, #16
  402428:	af00      	add	r7, sp, #0
  40242a:	6078      	str	r0, [r7, #4]
  40242c:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;

	configASSERT( pxEventList );
  40242e:	687b      	ldr	r3, [r7, #4]
  402430:	2b00      	cmp	r3, #0
  402432:	d104      	bne.n	40243e <vTaskPlaceOnEventList+0x1a>
  402434:	f640 00d6 	movw	r0, #2262	; 0x8d6
  402438:	491a      	ldr	r1, [pc, #104]	; (4024a4 <vTaskPlaceOnEventList+0x80>)
  40243a:	4b1b      	ldr	r3, [pc, #108]	; (4024a8 <vTaskPlaceOnEventList+0x84>)
  40243c:	4798      	blx	r3

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  40243e:	4b1b      	ldr	r3, [pc, #108]	; (4024ac <vTaskPlaceOnEventList+0x88>)
  402440:	681b      	ldr	r3, [r3, #0]
  402442:	3318      	adds	r3, #24
  402444:	6878      	ldr	r0, [r7, #4]
  402446:	4619      	mov	r1, r3
  402448:	4b19      	ldr	r3, [pc, #100]	; (4024b0 <vTaskPlaceOnEventList+0x8c>)
  40244a:	4798      	blx	r3

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
  40244c:	4b17      	ldr	r3, [pc, #92]	; (4024ac <vTaskPlaceOnEventList+0x88>)
  40244e:	681b      	ldr	r3, [r3, #0]
  402450:	3304      	adds	r3, #4
  402452:	4618      	mov	r0, r3
  402454:	4b17      	ldr	r3, [pc, #92]	; (4024b4 <vTaskPlaceOnEventList+0x90>)
  402456:	4798      	blx	r3
  402458:	4603      	mov	r3, r0
  40245a:	2b00      	cmp	r3, #0
  40245c:	d10b      	bne.n	402476 <vTaskPlaceOnEventList+0x52>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
  40245e:	4b13      	ldr	r3, [pc, #76]	; (4024ac <vTaskPlaceOnEventList+0x88>)
  402460:	681b      	ldr	r3, [r3, #0]
  402462:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402464:	2201      	movs	r2, #1
  402466:	fa02 f303 	lsl.w	r3, r2, r3
  40246a:	43da      	mvns	r2, r3
  40246c:	4b12      	ldr	r3, [pc, #72]	; (4024b8 <vTaskPlaceOnEventList+0x94>)
  40246e:	681b      	ldr	r3, [r3, #0]
  402470:	401a      	ands	r2, r3
  402472:	4b11      	ldr	r3, [pc, #68]	; (4024b8 <vTaskPlaceOnEventList+0x94>)
  402474:	601a      	str	r2, [r3, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
  402476:	683b      	ldr	r3, [r7, #0]
  402478:	f1b3 3fff 	cmp.w	r3, #4294967295
  40247c:	d107      	bne.n	40248e <vTaskPlaceOnEventList+0x6a>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
  40247e:	4b0b      	ldr	r3, [pc, #44]	; (4024ac <vTaskPlaceOnEventList+0x88>)
  402480:	681b      	ldr	r3, [r3, #0]
  402482:	3304      	adds	r3, #4
  402484:	480d      	ldr	r0, [pc, #52]	; (4024bc <vTaskPlaceOnEventList+0x98>)
  402486:	4619      	mov	r1, r3
  402488:	4b0d      	ldr	r3, [pc, #52]	; (4024c0 <vTaskPlaceOnEventList+0x9c>)
  40248a:	4798      	blx	r3
  40248c:	e007      	b.n	40249e <vTaskPlaceOnEventList+0x7a>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
  40248e:	4b0d      	ldr	r3, [pc, #52]	; (4024c4 <vTaskPlaceOnEventList+0xa0>)
  402490:	681a      	ldr	r2, [r3, #0]
  402492:	683b      	ldr	r3, [r7, #0]
  402494:	4413      	add	r3, r2
  402496:	60fb      	str	r3, [r7, #12]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
  402498:	68f8      	ldr	r0, [r7, #12]
  40249a:	4b0b      	ldr	r3, [pc, #44]	; (4024c8 <vTaskPlaceOnEventList+0xa4>)
  40249c:	4798      	blx	r3
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
  40249e:	3710      	adds	r7, #16
  4024a0:	46bd      	mov	sp, r7
  4024a2:	bd80      	pop	{r7, pc}
  4024a4:	00404614 	.word	0x00404614
  4024a8:	004004d1 	.word	0x004004d1
  4024ac:	2000c090 	.word	0x2000c090
  4024b0:	00400659 	.word	0x00400659
  4024b4:	004006c9 	.word	0x004006c9
  4024b8:	2000c170 	.word	0x2000c170
  4024bc:	2000c154 	.word	0x2000c154
  4024c0:	00400611 	.word	0x00400611
  4024c4:	2000c16c 	.word	0x2000c16c
  4024c8:	004029bd 	.word	0x004029bd

004024cc <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait )
	{
  4024cc:	b580      	push	{r7, lr}
  4024ce:	b084      	sub	sp, #16
  4024d0:	af00      	add	r7, sp, #0
  4024d2:	6078      	str	r0, [r7, #4]
  4024d4:	6039      	str	r1, [r7, #0]
	TickType_t xTimeToWake;

		configASSERT( pxEventList );
  4024d6:	687b      	ldr	r3, [r7, #4]
  4024d8:	2b00      	cmp	r3, #0
  4024da:	d104      	bne.n	4024e6 <vTaskPlaceOnEventListRestricted+0x1a>
  4024dc:	f640 1055 	movw	r0, #2389	; 0x955
  4024e0:	4914      	ldr	r1, [pc, #80]	; (402534 <vTaskPlaceOnEventListRestricted+0x68>)
  4024e2:	4b15      	ldr	r3, [pc, #84]	; (402538 <vTaskPlaceOnEventListRestricted+0x6c>)
  4024e4:	4798      	blx	r3

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  4024e6:	4b15      	ldr	r3, [pc, #84]	; (40253c <vTaskPlaceOnEventListRestricted+0x70>)
  4024e8:	681b      	ldr	r3, [r3, #0]
  4024ea:	3318      	adds	r3, #24
  4024ec:	6878      	ldr	r0, [r7, #4]
  4024ee:	4619      	mov	r1, r3
  4024f0:	4b13      	ldr	r3, [pc, #76]	; (402540 <vTaskPlaceOnEventListRestricted+0x74>)
  4024f2:	4798      	blx	r3

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called form a critical section. */
		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
  4024f4:	4b11      	ldr	r3, [pc, #68]	; (40253c <vTaskPlaceOnEventListRestricted+0x70>)
  4024f6:	681b      	ldr	r3, [r3, #0]
  4024f8:	3304      	adds	r3, #4
  4024fa:	4618      	mov	r0, r3
  4024fc:	4b11      	ldr	r3, [pc, #68]	; (402544 <vTaskPlaceOnEventListRestricted+0x78>)
  4024fe:	4798      	blx	r3
  402500:	4603      	mov	r3, r0
  402502:	2b00      	cmp	r3, #0
  402504:	d10b      	bne.n	40251e <vTaskPlaceOnEventListRestricted+0x52>
		{
			/* The current task must be in a ready list, so there is no need to
			check, and the port reset macro can be called directly. */
			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
  402506:	4b0d      	ldr	r3, [pc, #52]	; (40253c <vTaskPlaceOnEventListRestricted+0x70>)
  402508:	681b      	ldr	r3, [r3, #0]
  40250a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40250c:	2201      	movs	r2, #1
  40250e:	fa02 f303 	lsl.w	r3, r2, r3
  402512:	43da      	mvns	r2, r3
  402514:	4b0c      	ldr	r3, [pc, #48]	; (402548 <vTaskPlaceOnEventListRestricted+0x7c>)
  402516:	681b      	ldr	r3, [r3, #0]
  402518:	401a      	ands	r2, r3
  40251a:	4b0b      	ldr	r3, [pc, #44]	; (402548 <vTaskPlaceOnEventListRestricted+0x7c>)
  40251c:	601a      	str	r2, [r3, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
  40251e:	4b0b      	ldr	r3, [pc, #44]	; (40254c <vTaskPlaceOnEventListRestricted+0x80>)
  402520:	681a      	ldr	r2, [r3, #0]
  402522:	683b      	ldr	r3, [r7, #0]
  402524:	4413      	add	r3, r2
  402526:	60fb      	str	r3, [r7, #12]

		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
  402528:	68f8      	ldr	r0, [r7, #12]
  40252a:	4b09      	ldr	r3, [pc, #36]	; (402550 <vTaskPlaceOnEventListRestricted+0x84>)
  40252c:	4798      	blx	r3
	}
  40252e:	3710      	adds	r7, #16
  402530:	46bd      	mov	sp, r7
  402532:	bd80      	pop	{r7, pc}
  402534:	00404614 	.word	0x00404614
  402538:	004004d1 	.word	0x004004d1
  40253c:	2000c090 	.word	0x2000c090
  402540:	00400611 	.word	0x00400611
  402544:	004006c9 	.word	0x004006c9
  402548:	2000c170 	.word	0x2000c170
  40254c:	2000c16c 	.word	0x2000c16c
  402550:	004029bd 	.word	0x004029bd

00402554 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
  402554:	b580      	push	{r7, lr}
  402556:	b084      	sub	sp, #16
  402558:	af00      	add	r7, sp, #0
  40255a:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
  40255c:	687b      	ldr	r3, [r7, #4]
  40255e:	68db      	ldr	r3, [r3, #12]
  402560:	68db      	ldr	r3, [r3, #12]
  402562:	60bb      	str	r3, [r7, #8]
	configASSERT( pxUnblockedTCB );
  402564:	68bb      	ldr	r3, [r7, #8]
  402566:	2b00      	cmp	r3, #0
  402568:	d104      	bne.n	402574 <xTaskRemoveFromEventList+0x20>
  40256a:	f640 108f 	movw	r0, #2447	; 0x98f
  40256e:	4922      	ldr	r1, [pc, #136]	; (4025f8 <xTaskRemoveFromEventList+0xa4>)
  402570:	4b22      	ldr	r3, [pc, #136]	; (4025fc <xTaskRemoveFromEventList+0xa8>)
  402572:	4798      	blx	r3
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
  402574:	68bb      	ldr	r3, [r7, #8]
  402576:	3318      	adds	r3, #24
  402578:	4618      	mov	r0, r3
  40257a:	4b21      	ldr	r3, [pc, #132]	; (402600 <xTaskRemoveFromEventList+0xac>)
  40257c:	4798      	blx	r3

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  40257e:	4b21      	ldr	r3, [pc, #132]	; (402604 <xTaskRemoveFromEventList+0xb0>)
  402580:	681b      	ldr	r3, [r3, #0]
  402582:	2b00      	cmp	r3, #0
  402584:	d11c      	bne.n	4025c0 <xTaskRemoveFromEventList+0x6c>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
  402586:	68bb      	ldr	r3, [r7, #8]
  402588:	3304      	adds	r3, #4
  40258a:	4618      	mov	r0, r3
  40258c:	4b1c      	ldr	r3, [pc, #112]	; (402600 <xTaskRemoveFromEventList+0xac>)
  40258e:	4798      	blx	r3
		prvAddTaskToReadyList( pxUnblockedTCB );
  402590:	68bb      	ldr	r3, [r7, #8]
  402592:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402594:	2201      	movs	r2, #1
  402596:	409a      	lsls	r2, r3
  402598:	4b1b      	ldr	r3, [pc, #108]	; (402608 <xTaskRemoveFromEventList+0xb4>)
  40259a:	681b      	ldr	r3, [r3, #0]
  40259c:	431a      	orrs	r2, r3
  40259e:	4b1a      	ldr	r3, [pc, #104]	; (402608 <xTaskRemoveFromEventList+0xb4>)
  4025a0:	601a      	str	r2, [r3, #0]
  4025a2:	68bb      	ldr	r3, [r7, #8]
  4025a4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4025a6:	4613      	mov	r3, r2
  4025a8:	009b      	lsls	r3, r3, #2
  4025aa:	4413      	add	r3, r2
  4025ac:	009b      	lsls	r3, r3, #2
  4025ae:	4a17      	ldr	r2, [pc, #92]	; (40260c <xTaskRemoveFromEventList+0xb8>)
  4025b0:	441a      	add	r2, r3
  4025b2:	68bb      	ldr	r3, [r7, #8]
  4025b4:	3304      	adds	r3, #4
  4025b6:	4610      	mov	r0, r2
  4025b8:	4619      	mov	r1, r3
  4025ba:	4b15      	ldr	r3, [pc, #84]	; (402610 <xTaskRemoveFromEventList+0xbc>)
  4025bc:	4798      	blx	r3
  4025be:	e005      	b.n	4025cc <xTaskRemoveFromEventList+0x78>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  4025c0:	68bb      	ldr	r3, [r7, #8]
  4025c2:	3318      	adds	r3, #24
  4025c4:	4813      	ldr	r0, [pc, #76]	; (402614 <xTaskRemoveFromEventList+0xc0>)
  4025c6:	4619      	mov	r1, r3
  4025c8:	4b11      	ldr	r3, [pc, #68]	; (402610 <xTaskRemoveFromEventList+0xbc>)
  4025ca:	4798      	blx	r3
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
  4025cc:	68bb      	ldr	r3, [r7, #8]
  4025ce:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4025d0:	4b11      	ldr	r3, [pc, #68]	; (402618 <xTaskRemoveFromEventList+0xc4>)
  4025d2:	681b      	ldr	r3, [r3, #0]
  4025d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4025d6:	429a      	cmp	r2, r3
  4025d8:	d905      	bls.n	4025e6 <xTaskRemoveFromEventList+0x92>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
  4025da:	2301      	movs	r3, #1
  4025dc:	60fb      	str	r3, [r7, #12]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
  4025de:	4b0f      	ldr	r3, [pc, #60]	; (40261c <xTaskRemoveFromEventList+0xc8>)
  4025e0:	2201      	movs	r2, #1
  4025e2:	601a      	str	r2, [r3, #0]
  4025e4:	e001      	b.n	4025ea <xTaskRemoveFromEventList+0x96>
	}
	else
	{
		xReturn = pdFALSE;
  4025e6:	2300      	movs	r3, #0
  4025e8:	60fb      	str	r3, [r7, #12]
		normally left unchanged, because it is automatically get reset to a new
		value when the tick count equals xNextTaskUnblockTime.  However if
		tickless idling is used it might be more important to enter sleep mode
		at the earliest possible time - so reset xNextTaskUnblockTime here to
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
  4025ea:	4b0d      	ldr	r3, [pc, #52]	; (402620 <xTaskRemoveFromEventList+0xcc>)
  4025ec:	4798      	blx	r3
	}
	#endif

	return xReturn;
  4025ee:	68fb      	ldr	r3, [r7, #12]
}
  4025f0:	4618      	mov	r0, r3
  4025f2:	3710      	adds	r7, #16
  4025f4:	46bd      	mov	sp, r7
  4025f6:	bd80      	pop	{r7, pc}
  4025f8:	00404614 	.word	0x00404614
  4025fc:	004004d1 	.word	0x004004d1
  402600:	004006c9 	.word	0x004006c9
  402604:	2000c188 	.word	0x2000c188
  402608:	2000c170 	.word	0x2000c170
  40260c:	2000c094 	.word	0x2000c094
  402610:	00400611 	.word	0x00400611
  402614:	2000c128 	.word	0x2000c128
  402618:	2000c090 	.word	0x2000c090
  40261c:	2000c17c 	.word	0x2000c17c
  402620:	00402acd 	.word	0x00402acd

00402624 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
  402624:	b580      	push	{r7, lr}
  402626:	b082      	sub	sp, #8
  402628:	af00      	add	r7, sp, #0
  40262a:	6078      	str	r0, [r7, #4]
	configASSERT( pxTimeOut );
  40262c:	687b      	ldr	r3, [r7, #4]
  40262e:	2b00      	cmp	r3, #0
  402630:	d104      	bne.n	40263c <vTaskSetTimeOutState+0x18>
  402632:	f640 10ef 	movw	r0, #2543	; 0x9ef
  402636:	4907      	ldr	r1, [pc, #28]	; (402654 <vTaskSetTimeOutState+0x30>)
  402638:	4b07      	ldr	r3, [pc, #28]	; (402658 <vTaskSetTimeOutState+0x34>)
  40263a:	4798      	blx	r3
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  40263c:	4b07      	ldr	r3, [pc, #28]	; (40265c <vTaskSetTimeOutState+0x38>)
  40263e:	681a      	ldr	r2, [r3, #0]
  402640:	687b      	ldr	r3, [r7, #4]
  402642:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  402644:	4b06      	ldr	r3, [pc, #24]	; (402660 <vTaskSetTimeOutState+0x3c>)
  402646:	681a      	ldr	r2, [r3, #0]
  402648:	687b      	ldr	r3, [r7, #4]
  40264a:	605a      	str	r2, [r3, #4]
}
  40264c:	3708      	adds	r7, #8
  40264e:	46bd      	mov	sp, r7
  402650:	bd80      	pop	{r7, pc}
  402652:	bf00      	nop
  402654:	00404614 	.word	0x00404614
  402658:	004004d1 	.word	0x004004d1
  40265c:	2000c180 	.word	0x2000c180
  402660:	2000c16c 	.word	0x2000c16c

00402664 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
  402664:	b580      	push	{r7, lr}
  402666:	b084      	sub	sp, #16
  402668:	af00      	add	r7, sp, #0
  40266a:	6078      	str	r0, [r7, #4]
  40266c:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
  40266e:	687b      	ldr	r3, [r7, #4]
  402670:	2b00      	cmp	r3, #0
  402672:	d104      	bne.n	40267e <xTaskCheckForTimeOut+0x1a>
  402674:	f640 10f9 	movw	r0, #2553	; 0x9f9
  402678:	4922      	ldr	r1, [pc, #136]	; (402704 <xTaskCheckForTimeOut+0xa0>)
  40267a:	4b23      	ldr	r3, [pc, #140]	; (402708 <xTaskCheckForTimeOut+0xa4>)
  40267c:	4798      	blx	r3
	configASSERT( pxTicksToWait );
  40267e:	683b      	ldr	r3, [r7, #0]
  402680:	2b00      	cmp	r3, #0
  402682:	d104      	bne.n	40268e <xTaskCheckForTimeOut+0x2a>
  402684:	f640 10fa 	movw	r0, #2554	; 0x9fa
  402688:	491e      	ldr	r1, [pc, #120]	; (402704 <xTaskCheckForTimeOut+0xa0>)
  40268a:	4b1f      	ldr	r3, [pc, #124]	; (402708 <xTaskCheckForTimeOut+0xa4>)
  40268c:	4798      	blx	r3

	taskENTER_CRITICAL();
  40268e:	4b1f      	ldr	r3, [pc, #124]	; (40270c <xTaskCheckForTimeOut+0xa8>)
  402690:	4798      	blx	r3
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
  402692:	4b1f      	ldr	r3, [pc, #124]	; (402710 <xTaskCheckForTimeOut+0xac>)
  402694:	681b      	ldr	r3, [r3, #0]
  402696:	60bb      	str	r3, [r7, #8]

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
  402698:	683b      	ldr	r3, [r7, #0]
  40269a:	681b      	ldr	r3, [r3, #0]
  40269c:	f1b3 3fff 	cmp.w	r3, #4294967295
  4026a0:	d102      	bne.n	4026a8 <xTaskCheckForTimeOut+0x44>
			{
				xReturn = pdFALSE;
  4026a2:	2300      	movs	r3, #0
  4026a4:	60fb      	str	r3, [r7, #12]
  4026a6:	e026      	b.n	4026f6 <xTaskCheckForTimeOut+0x92>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
  4026a8:	687b      	ldr	r3, [r7, #4]
  4026aa:	681a      	ldr	r2, [r3, #0]
  4026ac:	4b19      	ldr	r3, [pc, #100]	; (402714 <xTaskCheckForTimeOut+0xb0>)
  4026ae:	681b      	ldr	r3, [r3, #0]
  4026b0:	429a      	cmp	r2, r3
  4026b2:	d007      	beq.n	4026c4 <xTaskCheckForTimeOut+0x60>
  4026b4:	687b      	ldr	r3, [r7, #4]
  4026b6:	685a      	ldr	r2, [r3, #4]
  4026b8:	68bb      	ldr	r3, [r7, #8]
  4026ba:	429a      	cmp	r2, r3
  4026bc:	d802      	bhi.n	4026c4 <xTaskCheckForTimeOut+0x60>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
  4026be:	2301      	movs	r3, #1
  4026c0:	60fb      	str	r3, [r7, #12]
  4026c2:	e018      	b.n	4026f6 <xTaskCheckForTimeOut+0x92>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
  4026c4:	687b      	ldr	r3, [r7, #4]
  4026c6:	685b      	ldr	r3, [r3, #4]
  4026c8:	68ba      	ldr	r2, [r7, #8]
  4026ca:	1ad2      	subs	r2, r2, r3
  4026cc:	683b      	ldr	r3, [r7, #0]
  4026ce:	681b      	ldr	r3, [r3, #0]
  4026d0:	429a      	cmp	r2, r3
  4026d2:	d20e      	bcs.n	4026f2 <xTaskCheckForTimeOut+0x8e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
  4026d4:	683b      	ldr	r3, [r7, #0]
  4026d6:	681a      	ldr	r2, [r3, #0]
  4026d8:	687b      	ldr	r3, [r7, #4]
  4026da:	6859      	ldr	r1, [r3, #4]
  4026dc:	68bb      	ldr	r3, [r7, #8]
  4026de:	1acb      	subs	r3, r1, r3
  4026e0:	441a      	add	r2, r3
  4026e2:	683b      	ldr	r3, [r7, #0]
  4026e4:	601a      	str	r2, [r3, #0]
			vTaskSetTimeOutState( pxTimeOut );
  4026e6:	6878      	ldr	r0, [r7, #4]
  4026e8:	4b0b      	ldr	r3, [pc, #44]	; (402718 <xTaskCheckForTimeOut+0xb4>)
  4026ea:	4798      	blx	r3
			xReturn = pdFALSE;
  4026ec:	2300      	movs	r3, #0
  4026ee:	60fb      	str	r3, [r7, #12]
  4026f0:	e001      	b.n	4026f6 <xTaskCheckForTimeOut+0x92>
		}
		else
		{
			xReturn = pdTRUE;
  4026f2:	2301      	movs	r3, #1
  4026f4:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
  4026f6:	4b09      	ldr	r3, [pc, #36]	; (40271c <xTaskCheckForTimeOut+0xb8>)
  4026f8:	4798      	blx	r3

	return xReturn;
  4026fa:	68fb      	ldr	r3, [r7, #12]
}
  4026fc:	4618      	mov	r0, r3
  4026fe:	3710      	adds	r7, #16
  402700:	46bd      	mov	sp, r7
  402702:	bd80      	pop	{r7, pc}
  402704:	00404614 	.word	0x00404614
  402708:	004004d1 	.word	0x004004d1
  40270c:	004008dd 	.word	0x004008dd
  402710:	2000c16c 	.word	0x2000c16c
  402714:	2000c180 	.word	0x2000c180
  402718:	00402625 	.word	0x00402625
  40271c:	00400931 	.word	0x00400931

00402720 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
  402720:	b480      	push	{r7}
  402722:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
  402724:	4b03      	ldr	r3, [pc, #12]	; (402734 <vTaskMissedYield+0x14>)
  402726:	2201      	movs	r2, #1
  402728:	601a      	str	r2, [r3, #0]
}
  40272a:	46bd      	mov	sp, r7
  40272c:	f85d 7b04 	ldr.w	r7, [sp], #4
  402730:	4770      	bx	lr
  402732:	bf00      	nop
  402734:	2000c17c 	.word	0x2000c17c

00402738 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
  402738:	b580      	push	{r7, lr}
  40273a:	b084      	sub	sp, #16
  40273c:	af00      	add	r7, sp, #0
  40273e:	6078      	str	r0, [r7, #4]
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
  402740:	4b16      	ldr	r3, [pc, #88]	; (40279c <prvIdleTask+0x64>)
  402742:	4798      	blx	r3

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
  402744:	4b16      	ldr	r3, [pc, #88]	; (4027a0 <prvIdleTask+0x68>)
  402746:	681b      	ldr	r3, [r3, #0]
  402748:	2b01      	cmp	r3, #1
  40274a:	d907      	bls.n	40275c <prvIdleTask+0x24>
			{
				taskYIELD();
  40274c:	4b15      	ldr	r3, [pc, #84]	; (4027a4 <prvIdleTask+0x6c>)
  40274e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  402752:	601a      	str	r2, [r3, #0]
  402754:	f3bf 8f4f 	dsb	sy
  402758:	f3bf 8f6f 	isb	sy
			/* It is not desirable to suspend then resume the scheduler on
			each iteration of the idle task.  Therefore, a preliminary
			test of the expected idle time is performed without the
			scheduler suspended.  The result here is not necessarily
			valid. */
			xExpectedIdleTime = prvGetExpectedIdleTime();
  40275c:	4b12      	ldr	r3, [pc, #72]	; (4027a8 <prvIdleTask+0x70>)
  40275e:	4798      	blx	r3
  402760:	60f8      	str	r0, [r7, #12]

			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
  402762:	68fb      	ldr	r3, [r7, #12]
  402764:	2b01      	cmp	r3, #1
  402766:	d917      	bls.n	402798 <prvIdleTask+0x60>
			{
				vTaskSuspendAll();
  402768:	4b10      	ldr	r3, [pc, #64]	; (4027ac <prvIdleTask+0x74>)
  40276a:	4798      	blx	r3
				{
					/* Now the scheduler is suspended, the expected idle
					time can be sampled again, and this time its value can
					be used. */
					configASSERT( xNextTaskUnblockTime >= xTickCount );
  40276c:	4b10      	ldr	r3, [pc, #64]	; (4027b0 <prvIdleTask+0x78>)
  40276e:	681a      	ldr	r2, [r3, #0]
  402770:	4b10      	ldr	r3, [pc, #64]	; (4027b4 <prvIdleTask+0x7c>)
  402772:	681b      	ldr	r3, [r3, #0]
  402774:	429a      	cmp	r2, r3
  402776:	d204      	bcs.n	402782 <prvIdleTask+0x4a>
  402778:	f640 20aa 	movw	r0, #2730	; 0xaaa
  40277c:	490e      	ldr	r1, [pc, #56]	; (4027b8 <prvIdleTask+0x80>)
  40277e:	4b0f      	ldr	r3, [pc, #60]	; (4027bc <prvIdleTask+0x84>)
  402780:	4798      	blx	r3
					xExpectedIdleTime = prvGetExpectedIdleTime();
  402782:	4b09      	ldr	r3, [pc, #36]	; (4027a8 <prvIdleTask+0x70>)
  402784:	4798      	blx	r3
  402786:	60f8      	str	r0, [r7, #12]

					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
  402788:	68fb      	ldr	r3, [r7, #12]
  40278a:	2b01      	cmp	r3, #1
  40278c:	d902      	bls.n	402794 <prvIdleTask+0x5c>
					{
						traceLOW_POWER_IDLE_BEGIN();
						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
  40278e:	68f8      	ldr	r0, [r7, #12]
  402790:	4b0b      	ldr	r3, [pc, #44]	; (4027c0 <prvIdleTask+0x88>)
  402792:	4798      	blx	r3
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}
				( void ) xTaskResumeAll();
  402794:	4b0b      	ldr	r3, [pc, #44]	; (4027c4 <prvIdleTask+0x8c>)
  402796:	4798      	blx	r3
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
  402798:	e7d2      	b.n	402740 <prvIdleTask+0x8>
  40279a:	bf00      	nop
  40279c:	00402931 	.word	0x00402931
  4027a0:	2000c094 	.word	0x2000c094
  4027a4:	e000ed04 	.word	0xe000ed04
  4027a8:	00401f75 	.word	0x00401f75
  4027ac:	00401f59 	.word	0x00401f59
  4027b0:	20000008 	.word	0x20000008
  4027b4:	2000c16c 	.word	0x2000c16c
  4027b8:	00404614 	.word	0x00404614
  4027bc:	004004d1 	.word	0x004004d1
  4027c0:	00400a21 	.word	0x00400a21
  4027c4:	00401fc5 	.word	0x00401fc5

004027c8 <eTaskConfirmSleepModeStatus>:
/*-----------------------------------------------------------*/

#if configUSE_TICKLESS_IDLE != 0

	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
	{
  4027c8:	b480      	push	{r7}
  4027ca:	b083      	sub	sp, #12
  4027cc:	af00      	add	r7, sp, #0
	eSleepModeStatus eReturn = eStandardSleep;
  4027ce:	2301      	movs	r3, #1
  4027d0:	71fb      	strb	r3, [r7, #7]

		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
  4027d2:	4b0a      	ldr	r3, [pc, #40]	; (4027fc <eTaskConfirmSleepModeStatus+0x34>)
  4027d4:	681b      	ldr	r3, [r3, #0]
  4027d6:	2b00      	cmp	r3, #0
  4027d8:	d002      	beq.n	4027e0 <eTaskConfirmSleepModeStatus+0x18>
		{
			/* A task was made ready while the scheduler was suspended. */
			eReturn = eAbortSleep;
  4027da:	2300      	movs	r3, #0
  4027dc:	71fb      	strb	r3, [r7, #7]
  4027de:	e005      	b.n	4027ec <eTaskConfirmSleepModeStatus+0x24>
		}
		else if( xYieldPending != pdFALSE )
  4027e0:	4b07      	ldr	r3, [pc, #28]	; (402800 <eTaskConfirmSleepModeStatus+0x38>)
  4027e2:	681b      	ldr	r3, [r3, #0]
  4027e4:	2b00      	cmp	r3, #0
  4027e6:	d001      	beq.n	4027ec <eTaskConfirmSleepModeStatus+0x24>
		{
			/* A yield was pended while the scheduler was suspended. */
			eReturn = eAbortSleep;
  4027e8:	2300      	movs	r3, #0
  4027ea:	71fb      	strb	r3, [r7, #7]
				}
			}
			#endif /* configUSE_TIMERS */
		}

		return eReturn;
  4027ec:	79fb      	ldrb	r3, [r7, #7]
	}
  4027ee:	4618      	mov	r0, r3
  4027f0:	370c      	adds	r7, #12
  4027f2:	46bd      	mov	sp, r7
  4027f4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4027f8:	4770      	bx	lr
  4027fa:	bf00      	nop
  4027fc:	2000c128 	.word	0x2000c128
  402800:	2000c17c 	.word	0x2000c17c

00402804 <prvInitialiseTCBVariables>:
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
  402804:	b580      	push	{r7, lr}
  402806:	b086      	sub	sp, #24
  402808:	af00      	add	r7, sp, #0
  40280a:	60f8      	str	r0, [r7, #12]
  40280c:	60b9      	str	r1, [r7, #8]
  40280e:	607a      	str	r2, [r7, #4]
  402810:	603b      	str	r3, [r7, #0]
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
  402812:	2300      	movs	r3, #0
  402814:	617b      	str	r3, [r7, #20]
  402816:	e012      	b.n	40283e <prvInitialiseTCBVariables+0x3a>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
  402818:	68ba      	ldr	r2, [r7, #8]
  40281a:	697b      	ldr	r3, [r7, #20]
  40281c:	4413      	add	r3, r2
  40281e:	781a      	ldrb	r2, [r3, #0]
  402820:	68f9      	ldr	r1, [r7, #12]
  402822:	697b      	ldr	r3, [r7, #20]
  402824:	440b      	add	r3, r1
  402826:	3330      	adds	r3, #48	; 0x30
  402828:	711a      	strb	r2, [r3, #4]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
  40282a:	68ba      	ldr	r2, [r7, #8]
  40282c:	697b      	ldr	r3, [r7, #20]
  40282e:	4413      	add	r3, r2
  402830:	781b      	ldrb	r3, [r3, #0]
  402832:	2b00      	cmp	r3, #0
  402834:	d100      	bne.n	402838 <prvInitialiseTCBVariables+0x34>
		{
			break;
  402836:	e005      	b.n	402844 <prvInitialiseTCBVariables+0x40>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
  402838:	697b      	ldr	r3, [r7, #20]
  40283a:	3301      	adds	r3, #1
  40283c:	617b      	str	r3, [r7, #20]
  40283e:	697b      	ldr	r3, [r7, #20]
  402840:	2b09      	cmp	r3, #9
  402842:	d9e9      	bls.n	402818 <prvInitialiseTCBVariables+0x14>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
  402844:	68fb      	ldr	r3, [r7, #12]
  402846:	2200      	movs	r2, #0
  402848:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
  40284c:	687b      	ldr	r3, [r7, #4]
  40284e:	2b04      	cmp	r3, #4
  402850:	d901      	bls.n	402856 <prvInitialiseTCBVariables+0x52>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
  402852:	2304      	movs	r3, #4
  402854:	607b      	str	r3, [r7, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
  402856:	68fb      	ldr	r3, [r7, #12]
  402858:	687a      	ldr	r2, [r7, #4]
  40285a:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
  40285c:	68fb      	ldr	r3, [r7, #12]
  40285e:	687a      	ldr	r2, [r7, #4]
  402860:	649a      	str	r2, [r3, #72]	; 0x48
		pxTCB->uxMutexesHeld = 0;
  402862:	68fb      	ldr	r3, [r7, #12]
  402864:	2200      	movs	r2, #0
  402866:	64da      	str	r2, [r3, #76]	; 0x4c
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
  402868:	68fb      	ldr	r3, [r7, #12]
  40286a:	3304      	adds	r3, #4
  40286c:	4618      	mov	r0, r3
  40286e:	4b0f      	ldr	r3, [pc, #60]	; (4028ac <prvInitialiseTCBVariables+0xa8>)
  402870:	4798      	blx	r3
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
  402872:	68fb      	ldr	r3, [r7, #12]
  402874:	3318      	adds	r3, #24
  402876:	4618      	mov	r0, r3
  402878:	4b0c      	ldr	r3, [pc, #48]	; (4028ac <prvInitialiseTCBVariables+0xa8>)
  40287a:	4798      	blx	r3

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
  40287c:	68fb      	ldr	r3, [r7, #12]
  40287e:	68fa      	ldr	r2, [r7, #12]
  402880:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  402882:	687b      	ldr	r3, [r7, #4]
  402884:	f1c3 0205 	rsb	r2, r3, #5
  402888:	68fb      	ldr	r3, [r7, #12]
  40288a:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
  40288c:	68fb      	ldr	r3, [r7, #12]
  40288e:	68fa      	ldr	r2, [r7, #12]
  402890:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif /* configUSE_APPLICATION_TASK_TAG */

	#if ( configGENERATE_RUN_TIME_STATS == 1 )
	{
		pxTCB->ulRunTimeCounter = 0UL;
  402892:	68fb      	ldr	r3, [r7, #12]
  402894:	2200      	movs	r2, #0
  402896:	651a      	str	r2, [r3, #80]	; 0x50
	}
	#endif /* portUSING_MPU_WRAPPERS */

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
  402898:	68fb      	ldr	r3, [r7, #12]
  40289a:	2200      	movs	r2, #0
  40289c:	655a      	str	r2, [r3, #84]	; 0x54
		pxTCB->eNotifyState = eNotWaitingNotification;
  40289e:	68fb      	ldr	r3, [r7, #12]
  4028a0:	2200      	movs	r2, #0
  4028a2:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
  4028a6:	3718      	adds	r7, #24
  4028a8:	46bd      	mov	sp, r7
  4028aa:	bd80      	pop	{r7, pc}
  4028ac:	004005f9 	.word	0x004005f9

004028b0 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
  4028b0:	b580      	push	{r7, lr}
  4028b2:	b082      	sub	sp, #8
  4028b4:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
  4028b6:	2300      	movs	r3, #0
  4028b8:	607b      	str	r3, [r7, #4]
  4028ba:	e00c      	b.n	4028d6 <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
  4028bc:	687a      	ldr	r2, [r7, #4]
  4028be:	4613      	mov	r3, r2
  4028c0:	009b      	lsls	r3, r3, #2
  4028c2:	4413      	add	r3, r2
  4028c4:	009b      	lsls	r3, r3, #2
  4028c6:	4a11      	ldr	r2, [pc, #68]	; (40290c <prvInitialiseTaskLists+0x5c>)
  4028c8:	4413      	add	r3, r2
  4028ca:	4618      	mov	r0, r3
  4028cc:	4b10      	ldr	r3, [pc, #64]	; (402910 <prvInitialiseTaskLists+0x60>)
  4028ce:	4798      	blx	r3

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
  4028d0:	687b      	ldr	r3, [r7, #4]
  4028d2:	3301      	adds	r3, #1
  4028d4:	607b      	str	r3, [r7, #4]
  4028d6:	687b      	ldr	r3, [r7, #4]
  4028d8:	2b04      	cmp	r3, #4
  4028da:	d9ef      	bls.n	4028bc <prvInitialiseTaskLists+0xc>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
  4028dc:	480d      	ldr	r0, [pc, #52]	; (402914 <prvInitialiseTaskLists+0x64>)
  4028de:	4b0c      	ldr	r3, [pc, #48]	; (402910 <prvInitialiseTaskLists+0x60>)
  4028e0:	4798      	blx	r3
	vListInitialise( &xDelayedTaskList2 );
  4028e2:	480d      	ldr	r0, [pc, #52]	; (402918 <prvInitialiseTaskLists+0x68>)
  4028e4:	4b0a      	ldr	r3, [pc, #40]	; (402910 <prvInitialiseTaskLists+0x60>)
  4028e6:	4798      	blx	r3
	vListInitialise( &xPendingReadyList );
  4028e8:	480c      	ldr	r0, [pc, #48]	; (40291c <prvInitialiseTaskLists+0x6c>)
  4028ea:	4b09      	ldr	r3, [pc, #36]	; (402910 <prvInitialiseTaskLists+0x60>)
  4028ec:	4798      	blx	r3

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
  4028ee:	480c      	ldr	r0, [pc, #48]	; (402920 <prvInitialiseTaskLists+0x70>)
  4028f0:	4b07      	ldr	r3, [pc, #28]	; (402910 <prvInitialiseTaskLists+0x60>)
  4028f2:	4798      	blx	r3
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
  4028f4:	480b      	ldr	r0, [pc, #44]	; (402924 <prvInitialiseTaskLists+0x74>)
  4028f6:	4b06      	ldr	r3, [pc, #24]	; (402910 <prvInitialiseTaskLists+0x60>)
  4028f8:	4798      	blx	r3
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
  4028fa:	4b0b      	ldr	r3, [pc, #44]	; (402928 <prvInitialiseTaskLists+0x78>)
  4028fc:	4a05      	ldr	r2, [pc, #20]	; (402914 <prvInitialiseTaskLists+0x64>)
  4028fe:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  402900:	4b0a      	ldr	r3, [pc, #40]	; (40292c <prvInitialiseTaskLists+0x7c>)
  402902:	4a05      	ldr	r2, [pc, #20]	; (402918 <prvInitialiseTaskLists+0x68>)
  402904:	601a      	str	r2, [r3, #0]
}
  402906:	3708      	adds	r7, #8
  402908:	46bd      	mov	sp, r7
  40290a:	bd80      	pop	{r7, pc}
  40290c:	2000c094 	.word	0x2000c094
  402910:	004005b9 	.word	0x004005b9
  402914:	2000c0f8 	.word	0x2000c0f8
  402918:	2000c10c 	.word	0x2000c10c
  40291c:	2000c128 	.word	0x2000c128
  402920:	2000c13c 	.word	0x2000c13c
  402924:	2000c154 	.word	0x2000c154
  402928:	2000c120 	.word	0x2000c120
  40292c:	2000c124 	.word	0x2000c124

00402930 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
  402930:	b580      	push	{r7, lr}
  402932:	b082      	sub	sp, #8
  402934:	af00      	add	r7, sp, #0
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
  402936:	e028      	b.n	40298a <prvCheckTasksWaitingTermination+0x5a>
		{
			vTaskSuspendAll();
  402938:	4b17      	ldr	r3, [pc, #92]	; (402998 <prvCheckTasksWaitingTermination+0x68>)
  40293a:	4798      	blx	r3
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
  40293c:	4b17      	ldr	r3, [pc, #92]	; (40299c <prvCheckTasksWaitingTermination+0x6c>)
  40293e:	681b      	ldr	r3, [r3, #0]
  402940:	2b00      	cmp	r3, #0
  402942:	bf14      	ite	ne
  402944:	2300      	movne	r3, #0
  402946:	2301      	moveq	r3, #1
  402948:	b2db      	uxtb	r3, r3
  40294a:	607b      	str	r3, [r7, #4]
			}
			( void ) xTaskResumeAll();
  40294c:	4b14      	ldr	r3, [pc, #80]	; (4029a0 <prvCheckTasksWaitingTermination+0x70>)
  40294e:	4798      	blx	r3

			if( xListIsEmpty == pdFALSE )
  402950:	687b      	ldr	r3, [r7, #4]
  402952:	2b00      	cmp	r3, #0
  402954:	d119      	bne.n	40298a <prvCheckTasksWaitingTermination+0x5a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
  402956:	4b13      	ldr	r3, [pc, #76]	; (4029a4 <prvCheckTasksWaitingTermination+0x74>)
  402958:	4798      	blx	r3
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
  40295a:	4b10      	ldr	r3, [pc, #64]	; (40299c <prvCheckTasksWaitingTermination+0x6c>)
  40295c:	68db      	ldr	r3, [r3, #12]
  40295e:	68db      	ldr	r3, [r3, #12]
  402960:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
  402962:	683b      	ldr	r3, [r7, #0]
  402964:	3304      	adds	r3, #4
  402966:	4618      	mov	r0, r3
  402968:	4b0f      	ldr	r3, [pc, #60]	; (4029a8 <prvCheckTasksWaitingTermination+0x78>)
  40296a:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
  40296c:	4b0f      	ldr	r3, [pc, #60]	; (4029ac <prvCheckTasksWaitingTermination+0x7c>)
  40296e:	681b      	ldr	r3, [r3, #0]
  402970:	1e5a      	subs	r2, r3, #1
  402972:	4b0e      	ldr	r3, [pc, #56]	; (4029ac <prvCheckTasksWaitingTermination+0x7c>)
  402974:	601a      	str	r2, [r3, #0]
					--uxTasksDeleted;
  402976:	4b0e      	ldr	r3, [pc, #56]	; (4029b0 <prvCheckTasksWaitingTermination+0x80>)
  402978:	681b      	ldr	r3, [r3, #0]
  40297a:	1e5a      	subs	r2, r3, #1
  40297c:	4b0c      	ldr	r3, [pc, #48]	; (4029b0 <prvCheckTasksWaitingTermination+0x80>)
  40297e:	601a      	str	r2, [r3, #0]
				}
				taskEXIT_CRITICAL();
  402980:	4b0c      	ldr	r3, [pc, #48]	; (4029b4 <prvCheckTasksWaitingTermination+0x84>)
  402982:	4798      	blx	r3

				prvDeleteTCB( pxTCB );
  402984:	6838      	ldr	r0, [r7, #0]
  402986:	4b0c      	ldr	r3, [pc, #48]	; (4029b8 <prvCheckTasksWaitingTermination+0x88>)
  402988:	4798      	blx	r3
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
  40298a:	4b09      	ldr	r3, [pc, #36]	; (4029b0 <prvCheckTasksWaitingTermination+0x80>)
  40298c:	681b      	ldr	r3, [r3, #0]
  40298e:	2b00      	cmp	r3, #0
  402990:	d1d2      	bne.n	402938 <prvCheckTasksWaitingTermination+0x8>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
  402992:	3708      	adds	r7, #8
  402994:	46bd      	mov	sp, r7
  402996:	bd80      	pop	{r7, pc}
  402998:	00401f59 	.word	0x00401f59
  40299c:	2000c13c 	.word	0x2000c13c
  4029a0:	00401fc5 	.word	0x00401fc5
  4029a4:	004008dd 	.word	0x004008dd
  4029a8:	004006c9 	.word	0x004006c9
  4029ac:	2000c168 	.word	0x2000c168
  4029b0:	2000c150 	.word	0x2000c150
  4029b4:	00400931 	.word	0x00400931
  4029b8:	00402aa9 	.word	0x00402aa9

004029bc <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
  4029bc:	b580      	push	{r7, lr}
  4029be:	b082      	sub	sp, #8
  4029c0:	af00      	add	r7, sp, #0
  4029c2:	6078      	str	r0, [r7, #4]
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  4029c4:	4b13      	ldr	r3, [pc, #76]	; (402a14 <prvAddCurrentTaskToDelayedList+0x58>)
  4029c6:	681b      	ldr	r3, [r3, #0]
  4029c8:	687a      	ldr	r2, [r7, #4]
  4029ca:	605a      	str	r2, [r3, #4]

	if( xTimeToWake < xTickCount )
  4029cc:	4b12      	ldr	r3, [pc, #72]	; (402a18 <prvAddCurrentTaskToDelayedList+0x5c>)
  4029ce:	681b      	ldr	r3, [r3, #0]
  4029d0:	687a      	ldr	r2, [r7, #4]
  4029d2:	429a      	cmp	r2, r3
  4029d4:	d209      	bcs.n	4029ea <prvAddCurrentTaskToDelayedList+0x2e>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
  4029d6:	4b11      	ldr	r3, [pc, #68]	; (402a1c <prvAddCurrentTaskToDelayedList+0x60>)
  4029d8:	681a      	ldr	r2, [r3, #0]
  4029da:	4b0e      	ldr	r3, [pc, #56]	; (402a14 <prvAddCurrentTaskToDelayedList+0x58>)
  4029dc:	681b      	ldr	r3, [r3, #0]
  4029de:	3304      	adds	r3, #4
  4029e0:	4610      	mov	r0, r2
  4029e2:	4619      	mov	r1, r3
  4029e4:	4b0e      	ldr	r3, [pc, #56]	; (402a20 <prvAddCurrentTaskToDelayedList+0x64>)
  4029e6:	4798      	blx	r3
  4029e8:	e010      	b.n	402a0c <prvAddCurrentTaskToDelayedList+0x50>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
  4029ea:	4b0e      	ldr	r3, [pc, #56]	; (402a24 <prvAddCurrentTaskToDelayedList+0x68>)
  4029ec:	681a      	ldr	r2, [r3, #0]
  4029ee:	4b09      	ldr	r3, [pc, #36]	; (402a14 <prvAddCurrentTaskToDelayedList+0x58>)
  4029f0:	681b      	ldr	r3, [r3, #0]
  4029f2:	3304      	adds	r3, #4
  4029f4:	4610      	mov	r0, r2
  4029f6:	4619      	mov	r1, r3
  4029f8:	4b09      	ldr	r3, [pc, #36]	; (402a20 <prvAddCurrentTaskToDelayedList+0x64>)
  4029fa:	4798      	blx	r3

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
  4029fc:	4b0a      	ldr	r3, [pc, #40]	; (402a28 <prvAddCurrentTaskToDelayedList+0x6c>)
  4029fe:	681b      	ldr	r3, [r3, #0]
  402a00:	687a      	ldr	r2, [r7, #4]
  402a02:	429a      	cmp	r2, r3
  402a04:	d202      	bcs.n	402a0c <prvAddCurrentTaskToDelayedList+0x50>
		{
			xNextTaskUnblockTime = xTimeToWake;
  402a06:	4b08      	ldr	r3, [pc, #32]	; (402a28 <prvAddCurrentTaskToDelayedList+0x6c>)
  402a08:	687a      	ldr	r2, [r7, #4]
  402a0a:	601a      	str	r2, [r3, #0]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
  402a0c:	3708      	adds	r7, #8
  402a0e:	46bd      	mov	sp, r7
  402a10:	bd80      	pop	{r7, pc}
  402a12:	bf00      	nop
  402a14:	2000c090 	.word	0x2000c090
  402a18:	2000c16c 	.word	0x2000c16c
  402a1c:	2000c124 	.word	0x2000c124
  402a20:	00400659 	.word	0x00400659
  402a24:	2000c120 	.word	0x2000c120
  402a28:	20000008 	.word	0x20000008

00402a2c <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
  402a2c:	b580      	push	{r7, lr}
  402a2e:	b084      	sub	sp, #16
  402a30:	af00      	add	r7, sp, #0
  402a32:	4603      	mov	r3, r0
  402a34:	6039      	str	r1, [r7, #0]
  402a36:	80fb      	strh	r3, [r7, #6]
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  402a38:	683b      	ldr	r3, [r7, #0]
  402a3a:	2b00      	cmp	r3, #0
  402a3c:	d106      	bne.n	402a4c <prvAllocateTCBAndStack+0x20>
  402a3e:	88fb      	ldrh	r3, [r7, #6]
  402a40:	009b      	lsls	r3, r3, #2
  402a42:	4618      	mov	r0, r3
  402a44:	4b15      	ldr	r3, [pc, #84]	; (402a9c <prvAllocateTCBAndStack+0x70>)
  402a46:	4798      	blx	r3
  402a48:	4603      	mov	r3, r0
  402a4a:	e000      	b.n	402a4e <prvAllocateTCBAndStack+0x22>
  402a4c:	683b      	ldr	r3, [r7, #0]
  402a4e:	60bb      	str	r3, [r7, #8]

		if( pxStack != NULL )
  402a50:	68bb      	ldr	r3, [r7, #8]
  402a52:	2b00      	cmp	r3, #0
  402a54:	d00e      	beq.n	402a74 <prvAllocateTCBAndStack+0x48>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
  402a56:	205c      	movs	r0, #92	; 0x5c
  402a58:	4b10      	ldr	r3, [pc, #64]	; (402a9c <prvAllocateTCBAndStack+0x70>)
  402a5a:	4798      	blx	r3
  402a5c:	60f8      	str	r0, [r7, #12]

			if( pxNewTCB != NULL )
  402a5e:	68fb      	ldr	r3, [r7, #12]
  402a60:	2b00      	cmp	r3, #0
  402a62:	d003      	beq.n	402a6c <prvAllocateTCBAndStack+0x40>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
  402a64:	68fb      	ldr	r3, [r7, #12]
  402a66:	68ba      	ldr	r2, [r7, #8]
  402a68:	631a      	str	r2, [r3, #48]	; 0x30
  402a6a:	e005      	b.n	402a78 <prvAllocateTCBAndStack+0x4c>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
  402a6c:	68b8      	ldr	r0, [r7, #8]
  402a6e:	4b0c      	ldr	r3, [pc, #48]	; (402aa0 <prvAllocateTCBAndStack+0x74>)
  402a70:	4798      	blx	r3
  402a72:	e001      	b.n	402a78 <prvAllocateTCBAndStack+0x4c>
			}
		}
		else
		{
			pxNewTCB = NULL;
  402a74:	2300      	movs	r3, #0
  402a76:	60fb      	str	r3, [r7, #12]
		}
	}
	#endif /* portSTACK_GROWTH */

	if( pxNewTCB != NULL )
  402a78:	68fb      	ldr	r3, [r7, #12]
  402a7a:	2b00      	cmp	r3, #0
  402a7c:	d008      	beq.n	402a90 <prvAllocateTCBAndStack+0x64>
	{
		/* Avoid dependency on memset() if it is not required. */
		#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
		{
			/* Just to help debugging. */
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
  402a7e:	68fb      	ldr	r3, [r7, #12]
  402a80:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  402a82:	88fb      	ldrh	r3, [r7, #6]
  402a84:	009b      	lsls	r3, r3, #2
  402a86:	4610      	mov	r0, r2
  402a88:	21a5      	movs	r1, #165	; 0xa5
  402a8a:	461a      	mov	r2, r3
  402a8c:	4b05      	ldr	r3, [pc, #20]	; (402aa4 <prvAllocateTCBAndStack+0x78>)
  402a8e:	4798      	blx	r3
		}
		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
	}

	return pxNewTCB;
  402a90:	68fb      	ldr	r3, [r7, #12]
}
  402a92:	4618      	mov	r0, r3
  402a94:	3710      	adds	r7, #16
  402a96:	46bd      	mov	sp, r7
  402a98:	bd80      	pop	{r7, pc}
  402a9a:	bf00      	nop
  402a9c:	00400c9d 	.word	0x00400c9d
  402aa0:	00400e15 	.word	0x00400e15
  402aa4:	0040436d 	.word	0x0040436d

00402aa8 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
  402aa8:	b580      	push	{r7, lr}
  402aaa:	b082      	sub	sp, #8
  402aac:	af00      	add	r7, sp, #0
  402aae:	6078      	str	r0, [r7, #4]
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
  402ab0:	687b      	ldr	r3, [r7, #4]
  402ab2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  402ab4:	4618      	mov	r0, r3
  402ab6:	4b04      	ldr	r3, [pc, #16]	; (402ac8 <prvDeleteTCB+0x20>)
  402ab8:	4798      	blx	r3
		}
		#endif

		vPortFree( pxTCB );
  402aba:	6878      	ldr	r0, [r7, #4]
  402abc:	4b02      	ldr	r3, [pc, #8]	; (402ac8 <prvDeleteTCB+0x20>)
  402abe:	4798      	blx	r3
	}
  402ac0:	3708      	adds	r7, #8
  402ac2:	46bd      	mov	sp, r7
  402ac4:	bd80      	pop	{r7, pc}
  402ac6:	bf00      	nop
  402ac8:	00400e15 	.word	0x00400e15

00402acc <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
  402acc:	b480      	push	{r7}
  402ace:	b083      	sub	sp, #12
  402ad0:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  402ad2:	4b0e      	ldr	r3, [pc, #56]	; (402b0c <prvResetNextTaskUnblockTime+0x40>)
  402ad4:	681b      	ldr	r3, [r3, #0]
  402ad6:	681b      	ldr	r3, [r3, #0]
  402ad8:	2b00      	cmp	r3, #0
  402ada:	d101      	bne.n	402ae0 <prvResetNextTaskUnblockTime+0x14>
  402adc:	2301      	movs	r3, #1
  402ade:	e000      	b.n	402ae2 <prvResetNextTaskUnblockTime+0x16>
  402ae0:	2300      	movs	r3, #0
  402ae2:	2b00      	cmp	r3, #0
  402ae4:	d004      	beq.n	402af0 <prvResetNextTaskUnblockTime+0x24>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
  402ae6:	4b0a      	ldr	r3, [pc, #40]	; (402b10 <prvResetNextTaskUnblockTime+0x44>)
  402ae8:	f04f 32ff 	mov.w	r2, #4294967295
  402aec:	601a      	str	r2, [r3, #0]
  402aee:	e008      	b.n	402b02 <prvResetNextTaskUnblockTime+0x36>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  402af0:	4b06      	ldr	r3, [pc, #24]	; (402b0c <prvResetNextTaskUnblockTime+0x40>)
  402af2:	681b      	ldr	r3, [r3, #0]
  402af4:	68db      	ldr	r3, [r3, #12]
  402af6:	68db      	ldr	r3, [r3, #12]
  402af8:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
  402afa:	687b      	ldr	r3, [r7, #4]
  402afc:	685a      	ldr	r2, [r3, #4]
  402afe:	4b04      	ldr	r3, [pc, #16]	; (402b10 <prvResetNextTaskUnblockTime+0x44>)
  402b00:	601a      	str	r2, [r3, #0]
	}
}
  402b02:	370c      	adds	r7, #12
  402b04:	46bd      	mov	sp, r7
  402b06:	f85d 7b04 	ldr.w	r7, [sp], #4
  402b0a:	4770      	bx	lr
  402b0c:	2000c120 	.word	0x2000c120
  402b10:	20000008 	.word	0x20000008

00402b14 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
  402b14:	b480      	push	{r7}
  402b16:	b083      	sub	sp, #12
  402b18:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
  402b1a:	4b0b      	ldr	r3, [pc, #44]	; (402b48 <xTaskGetSchedulerState+0x34>)
  402b1c:	681b      	ldr	r3, [r3, #0]
  402b1e:	2b00      	cmp	r3, #0
  402b20:	d102      	bne.n	402b28 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
  402b22:	2301      	movs	r3, #1
  402b24:	607b      	str	r3, [r7, #4]
  402b26:	e008      	b.n	402b3a <xTaskGetSchedulerState+0x26>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  402b28:	4b08      	ldr	r3, [pc, #32]	; (402b4c <xTaskGetSchedulerState+0x38>)
  402b2a:	681b      	ldr	r3, [r3, #0]
  402b2c:	2b00      	cmp	r3, #0
  402b2e:	d102      	bne.n	402b36 <xTaskGetSchedulerState+0x22>
			{
				xReturn = taskSCHEDULER_RUNNING;
  402b30:	2302      	movs	r3, #2
  402b32:	607b      	str	r3, [r7, #4]
  402b34:	e001      	b.n	402b3a <xTaskGetSchedulerState+0x26>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
  402b36:	2300      	movs	r3, #0
  402b38:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
  402b3a:	687b      	ldr	r3, [r7, #4]
	}
  402b3c:	4618      	mov	r0, r3
  402b3e:	370c      	adds	r7, #12
  402b40:	46bd      	mov	sp, r7
  402b42:	f85d 7b04 	ldr.w	r7, [sp], #4
  402b46:	4770      	bx	lr
  402b48:	2000c174 	.word	0x2000c174
  402b4c:	2000c188 	.word	0x2000c188

00402b50 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
  402b50:	b580      	push	{r7, lr}
  402b52:	b084      	sub	sp, #16
  402b54:	af00      	add	r7, sp, #0
  402b56:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
  402b58:	687b      	ldr	r3, [r7, #4]
  402b5a:	60fb      	str	r3, [r7, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
  402b5c:	687b      	ldr	r3, [r7, #4]
  402b5e:	2b00      	cmp	r3, #0
  402b60:	d062      	beq.n	402c28 <vTaskPriorityInherit+0xd8>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
  402b62:	68fb      	ldr	r3, [r7, #12]
  402b64:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402b66:	4b32      	ldr	r3, [pc, #200]	; (402c30 <vTaskPriorityInherit+0xe0>)
  402b68:	681b      	ldr	r3, [r3, #0]
  402b6a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402b6c:	429a      	cmp	r2, r3
  402b6e:	d25b      	bcs.n	402c28 <vTaskPriorityInherit+0xd8>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  402b70:	68fb      	ldr	r3, [r7, #12]
  402b72:	699b      	ldr	r3, [r3, #24]
  402b74:	2b00      	cmp	r3, #0
  402b76:	db06      	blt.n	402b86 <vTaskPriorityInherit+0x36>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  402b78:	4b2d      	ldr	r3, [pc, #180]	; (402c30 <vTaskPriorityInherit+0xe0>)
  402b7a:	681b      	ldr	r3, [r3, #0]
  402b7c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402b7e:	f1c3 0205 	rsb	r2, r3, #5
  402b82:	68fb      	ldr	r3, [r7, #12]
  402b84:	619a      	str	r2, [r3, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
  402b86:	68fb      	ldr	r3, [r7, #12]
  402b88:	6959      	ldr	r1, [r3, #20]
  402b8a:	68fb      	ldr	r3, [r7, #12]
  402b8c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402b8e:	4613      	mov	r3, r2
  402b90:	009b      	lsls	r3, r3, #2
  402b92:	4413      	add	r3, r2
  402b94:	009b      	lsls	r3, r3, #2
  402b96:	4a27      	ldr	r2, [pc, #156]	; (402c34 <vTaskPriorityInherit+0xe4>)
  402b98:	4413      	add	r3, r2
  402b9a:	4299      	cmp	r1, r3
  402b9c:	d101      	bne.n	402ba2 <vTaskPriorityInherit+0x52>
  402b9e:	2301      	movs	r3, #1
  402ba0:	e000      	b.n	402ba4 <vTaskPriorityInherit+0x54>
  402ba2:	2300      	movs	r3, #0
  402ba4:	2b00      	cmp	r3, #0
  402ba6:	d03a      	beq.n	402c1e <vTaskPriorityInherit+0xce>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
  402ba8:	68fb      	ldr	r3, [r7, #12]
  402baa:	3304      	adds	r3, #4
  402bac:	4618      	mov	r0, r3
  402bae:	4b22      	ldr	r3, [pc, #136]	; (402c38 <vTaskPriorityInherit+0xe8>)
  402bb0:	4798      	blx	r3
  402bb2:	4603      	mov	r3, r0
  402bb4:	2b00      	cmp	r3, #0
  402bb6:	d115      	bne.n	402be4 <vTaskPriorityInherit+0x94>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  402bb8:	68fb      	ldr	r3, [r7, #12]
  402bba:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402bbc:	491d      	ldr	r1, [pc, #116]	; (402c34 <vTaskPriorityInherit+0xe4>)
  402bbe:	4613      	mov	r3, r2
  402bc0:	009b      	lsls	r3, r3, #2
  402bc2:	4413      	add	r3, r2
  402bc4:	009b      	lsls	r3, r3, #2
  402bc6:	440b      	add	r3, r1
  402bc8:	681b      	ldr	r3, [r3, #0]
  402bca:	2b00      	cmp	r3, #0
  402bcc:	d10a      	bne.n	402be4 <vTaskPriorityInherit+0x94>
  402bce:	68fb      	ldr	r3, [r7, #12]
  402bd0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402bd2:	2201      	movs	r2, #1
  402bd4:	fa02 f303 	lsl.w	r3, r2, r3
  402bd8:	43da      	mvns	r2, r3
  402bda:	4b18      	ldr	r3, [pc, #96]	; (402c3c <vTaskPriorityInherit+0xec>)
  402bdc:	681b      	ldr	r3, [r3, #0]
  402bde:	401a      	ands	r2, r3
  402be0:	4b16      	ldr	r3, [pc, #88]	; (402c3c <vTaskPriorityInherit+0xec>)
  402be2:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  402be4:	4b12      	ldr	r3, [pc, #72]	; (402c30 <vTaskPriorityInherit+0xe0>)
  402be6:	681b      	ldr	r3, [r3, #0]
  402be8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402bea:	68fb      	ldr	r3, [r7, #12]
  402bec:	62da      	str	r2, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
  402bee:	68fb      	ldr	r3, [r7, #12]
  402bf0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402bf2:	2201      	movs	r2, #1
  402bf4:	409a      	lsls	r2, r3
  402bf6:	4b11      	ldr	r3, [pc, #68]	; (402c3c <vTaskPriorityInherit+0xec>)
  402bf8:	681b      	ldr	r3, [r3, #0]
  402bfa:	431a      	orrs	r2, r3
  402bfc:	4b0f      	ldr	r3, [pc, #60]	; (402c3c <vTaskPriorityInherit+0xec>)
  402bfe:	601a      	str	r2, [r3, #0]
  402c00:	68fb      	ldr	r3, [r7, #12]
  402c02:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402c04:	4613      	mov	r3, r2
  402c06:	009b      	lsls	r3, r3, #2
  402c08:	4413      	add	r3, r2
  402c0a:	009b      	lsls	r3, r3, #2
  402c0c:	4a09      	ldr	r2, [pc, #36]	; (402c34 <vTaskPriorityInherit+0xe4>)
  402c0e:	441a      	add	r2, r3
  402c10:	68fb      	ldr	r3, [r7, #12]
  402c12:	3304      	adds	r3, #4
  402c14:	4610      	mov	r0, r2
  402c16:	4619      	mov	r1, r3
  402c18:	4b09      	ldr	r3, [pc, #36]	; (402c40 <vTaskPriorityInherit+0xf0>)
  402c1a:	4798      	blx	r3
  402c1c:	e004      	b.n	402c28 <vTaskPriorityInherit+0xd8>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  402c1e:	4b04      	ldr	r3, [pc, #16]	; (402c30 <vTaskPriorityInherit+0xe0>)
  402c20:	681b      	ldr	r3, [r3, #0]
  402c22:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402c24:	68fb      	ldr	r3, [r7, #12]
  402c26:	62da      	str	r2, [r3, #44]	; 0x2c
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  402c28:	3710      	adds	r7, #16
  402c2a:	46bd      	mov	sp, r7
  402c2c:	bd80      	pop	{r7, pc}
  402c2e:	bf00      	nop
  402c30:	2000c090 	.word	0x2000c090
  402c34:	2000c094 	.word	0x2000c094
  402c38:	004006c9 	.word	0x004006c9
  402c3c:	2000c170 	.word	0x2000c170
  402c40:	00400611 	.word	0x00400611

00402c44 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
  402c44:	b580      	push	{r7, lr}
  402c46:	b084      	sub	sp, #16
  402c48:	af00      	add	r7, sp, #0
  402c4a:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
  402c4c:	687b      	ldr	r3, [r7, #4]
  402c4e:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn = pdFALSE;
  402c50:	2300      	movs	r3, #0
  402c52:	60fb      	str	r3, [r7, #12]

		if( pxMutexHolder != NULL )
  402c54:	687b      	ldr	r3, [r7, #4]
  402c56:	2b00      	cmp	r3, #0
  402c58:	d058      	beq.n	402d0c <xTaskPriorityDisinherit+0xc8>
		{
			configASSERT( pxTCB->uxMutexesHeld );
  402c5a:	68bb      	ldr	r3, [r7, #8]
  402c5c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  402c5e:	2b00      	cmp	r3, #0
  402c60:	d104      	bne.n	402c6c <xTaskPriorityDisinherit+0x28>
  402c62:	f640 504f 	movw	r0, #3407	; 0xd4f
  402c66:	492c      	ldr	r1, [pc, #176]	; (402d18 <xTaskPriorityDisinherit+0xd4>)
  402c68:	4b2c      	ldr	r3, [pc, #176]	; (402d1c <xTaskPriorityDisinherit+0xd8>)
  402c6a:	4798      	blx	r3
			( pxTCB->uxMutexesHeld )--;
  402c6c:	68bb      	ldr	r3, [r7, #8]
  402c6e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  402c70:	1e5a      	subs	r2, r3, #1
  402c72:	68bb      	ldr	r3, [r7, #8]
  402c74:	64da      	str	r2, [r3, #76]	; 0x4c

			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  402c76:	68bb      	ldr	r3, [r7, #8]
  402c78:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402c7a:	68bb      	ldr	r3, [r7, #8]
  402c7c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  402c7e:	429a      	cmp	r2, r3
  402c80:	d044      	beq.n	402d0c <xTaskPriorityDisinherit+0xc8>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
  402c82:	68bb      	ldr	r3, [r7, #8]
  402c84:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  402c86:	2b00      	cmp	r3, #0
  402c88:	d140      	bne.n	402d0c <xTaskPriorityDisinherit+0xc8>
					/* A task can only have an inhertied priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
  402c8a:	68bb      	ldr	r3, [r7, #8]
  402c8c:	3304      	adds	r3, #4
  402c8e:	4618      	mov	r0, r3
  402c90:	4b23      	ldr	r3, [pc, #140]	; (402d20 <xTaskPriorityDisinherit+0xdc>)
  402c92:	4798      	blx	r3
  402c94:	4603      	mov	r3, r0
  402c96:	2b00      	cmp	r3, #0
  402c98:	d115      	bne.n	402cc6 <xTaskPriorityDisinherit+0x82>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  402c9a:	68bb      	ldr	r3, [r7, #8]
  402c9c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402c9e:	4921      	ldr	r1, [pc, #132]	; (402d24 <xTaskPriorityDisinherit+0xe0>)
  402ca0:	4613      	mov	r3, r2
  402ca2:	009b      	lsls	r3, r3, #2
  402ca4:	4413      	add	r3, r2
  402ca6:	009b      	lsls	r3, r3, #2
  402ca8:	440b      	add	r3, r1
  402caa:	681b      	ldr	r3, [r3, #0]
  402cac:	2b00      	cmp	r3, #0
  402cae:	d10a      	bne.n	402cc6 <xTaskPriorityDisinherit+0x82>
  402cb0:	68bb      	ldr	r3, [r7, #8]
  402cb2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402cb4:	2201      	movs	r2, #1
  402cb6:	fa02 f303 	lsl.w	r3, r2, r3
  402cba:	43da      	mvns	r2, r3
  402cbc:	4b1a      	ldr	r3, [pc, #104]	; (402d28 <xTaskPriorityDisinherit+0xe4>)
  402cbe:	681b      	ldr	r3, [r3, #0]
  402cc0:	401a      	ands	r2, r3
  402cc2:	4b19      	ldr	r3, [pc, #100]	; (402d28 <xTaskPriorityDisinherit+0xe4>)
  402cc4:	601a      	str	r2, [r3, #0]
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
  402cc6:	68bb      	ldr	r3, [r7, #8]
  402cc8:	6c9a      	ldr	r2, [r3, #72]	; 0x48
  402cca:	68bb      	ldr	r3, [r7, #8]
  402ccc:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  402cce:	68bb      	ldr	r3, [r7, #8]
  402cd0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402cd2:	f1c3 0205 	rsb	r2, r3, #5
  402cd6:	68bb      	ldr	r3, [r7, #8]
  402cd8:	619a      	str	r2, [r3, #24]
					prvAddTaskToReadyList( pxTCB );
  402cda:	68bb      	ldr	r3, [r7, #8]
  402cdc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402cde:	2201      	movs	r2, #1
  402ce0:	409a      	lsls	r2, r3
  402ce2:	4b11      	ldr	r3, [pc, #68]	; (402d28 <xTaskPriorityDisinherit+0xe4>)
  402ce4:	681b      	ldr	r3, [r3, #0]
  402ce6:	431a      	orrs	r2, r3
  402ce8:	4b0f      	ldr	r3, [pc, #60]	; (402d28 <xTaskPriorityDisinherit+0xe4>)
  402cea:	601a      	str	r2, [r3, #0]
  402cec:	68bb      	ldr	r3, [r7, #8]
  402cee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402cf0:	4613      	mov	r3, r2
  402cf2:	009b      	lsls	r3, r3, #2
  402cf4:	4413      	add	r3, r2
  402cf6:	009b      	lsls	r3, r3, #2
  402cf8:	4a0a      	ldr	r2, [pc, #40]	; (402d24 <xTaskPriorityDisinherit+0xe0>)
  402cfa:	441a      	add	r2, r3
  402cfc:	68bb      	ldr	r3, [r7, #8]
  402cfe:	3304      	adds	r3, #4
  402d00:	4610      	mov	r0, r2
  402d02:	4619      	mov	r1, r3
  402d04:	4b09      	ldr	r3, [pc, #36]	; (402d2c <xTaskPriorityDisinherit+0xe8>)
  402d06:	4798      	blx	r3
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
  402d08:	2301      	movs	r3, #1
  402d0a:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
  402d0c:	68fb      	ldr	r3, [r7, #12]
	}
  402d0e:	4618      	mov	r0, r3
  402d10:	3710      	adds	r7, #16
  402d12:	46bd      	mov	sp, r7
  402d14:	bd80      	pop	{r7, pc}
  402d16:	bf00      	nop
  402d18:	00404614 	.word	0x00404614
  402d1c:	004004d1 	.word	0x004004d1
  402d20:	004006c9 	.word	0x004006c9
  402d24:	2000c094 	.word	0x2000c094
  402d28:	2000c170 	.word	0x2000c170
  402d2c:	00400611 	.word	0x00400611

00402d30 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
  402d30:	b480      	push	{r7}
  402d32:	af00      	add	r7, sp, #0
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
  402d34:	4b07      	ldr	r3, [pc, #28]	; (402d54 <pvTaskIncrementMutexHeldCount+0x24>)
  402d36:	681b      	ldr	r3, [r3, #0]
  402d38:	2b00      	cmp	r3, #0
  402d3a:	d004      	beq.n	402d46 <pvTaskIncrementMutexHeldCount+0x16>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
  402d3c:	4b05      	ldr	r3, [pc, #20]	; (402d54 <pvTaskIncrementMutexHeldCount+0x24>)
  402d3e:	681b      	ldr	r3, [r3, #0]
  402d40:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  402d42:	3201      	adds	r2, #1
  402d44:	64da      	str	r2, [r3, #76]	; 0x4c
		}

		return pxCurrentTCB;
  402d46:	4b03      	ldr	r3, [pc, #12]	; (402d54 <pvTaskIncrementMutexHeldCount+0x24>)
  402d48:	681b      	ldr	r3, [r3, #0]
	}
  402d4a:	4618      	mov	r0, r3
  402d4c:	46bd      	mov	sp, r7
  402d4e:	f85d 7b04 	ldr.w	r7, [sp], #4
  402d52:	4770      	bx	lr
  402d54:	2000c090 	.word	0x2000c090

00402d58 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
  402d58:	b590      	push	{r4, r7, lr}
  402d5a:	b087      	sub	sp, #28
  402d5c:	af04      	add	r7, sp, #16
BaseType_t xReturn = pdFAIL;
  402d5e:	2300      	movs	r3, #0
  402d60:	607b      	str	r3, [r7, #4]

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
  402d62:	4b11      	ldr	r3, [pc, #68]	; (402da8 <xTimerCreateTimerTask+0x50>)
  402d64:	4798      	blx	r3

	if( xTimerQueue != NULL )
  402d66:	4b11      	ldr	r3, [pc, #68]	; (402dac <xTimerCreateTimerTask+0x54>)
  402d68:	681b      	ldr	r3, [r3, #0]
  402d6a:	2b00      	cmp	r3, #0
  402d6c:	d00e      	beq.n	402d8c <xTimerCreateTimerTask+0x34>
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
  402d6e:	2302      	movs	r3, #2
  402d70:	9300      	str	r3, [sp, #0]
  402d72:	2300      	movs	r3, #0
  402d74:	9301      	str	r3, [sp, #4]
  402d76:	2300      	movs	r3, #0
  402d78:	9302      	str	r3, [sp, #8]
  402d7a:	2300      	movs	r3, #0
  402d7c:	9303      	str	r3, [sp, #12]
  402d7e:	480c      	ldr	r0, [pc, #48]	; (402db0 <xTimerCreateTimerTask+0x58>)
  402d80:	490c      	ldr	r1, [pc, #48]	; (402db4 <xTimerCreateTimerTask+0x5c>)
  402d82:	2278      	movs	r2, #120	; 0x78
  402d84:	2300      	movs	r3, #0
  402d86:	4c0c      	ldr	r4, [pc, #48]	; (402db8 <xTimerCreateTimerTask+0x60>)
  402d88:	47a0      	blx	r4
  402d8a:	6078      	str	r0, [r7, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
  402d8c:	687b      	ldr	r3, [r7, #4]
  402d8e:	2b00      	cmp	r3, #0
  402d90:	d104      	bne.n	402d9c <xTimerCreateTimerTask+0x44>
  402d92:	f44f 7087 	mov.w	r0, #270	; 0x10e
  402d96:	4909      	ldr	r1, [pc, #36]	; (402dbc <xTimerCreateTimerTask+0x64>)
  402d98:	4b09      	ldr	r3, [pc, #36]	; (402dc0 <xTimerCreateTimerTask+0x68>)
  402d9a:	4798      	blx	r3
	return xReturn;
  402d9c:	687b      	ldr	r3, [r7, #4]
}
  402d9e:	4618      	mov	r0, r3
  402da0:	370c      	adds	r7, #12
  402da2:	46bd      	mov	sp, r7
  402da4:	bd90      	pop	{r4, r7, pc}
  402da6:	bf00      	nop
  402da8:	004032f1 	.word	0x004032f1
  402dac:	2000c1c4 	.word	0x2000c1c4
  402db0:	00402ee5 	.word	0x00402ee5
  402db4:	00404680 	.word	0x00404680
  402db8:	00401c01 	.word	0x00401c01
  402dbc:	00404688 	.word	0x00404688
  402dc0:	004004d1 	.word	0x004004d1

00402dc4 <xTimerGenericCommand>:
	return ( TimerHandle_t ) pxNewTimer;
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
  402dc4:	b590      	push	{r4, r7, lr}
  402dc6:	b08b      	sub	sp, #44	; 0x2c
  402dc8:	af00      	add	r7, sp, #0
  402dca:	60f8      	str	r0, [r7, #12]
  402dcc:	60b9      	str	r1, [r7, #8]
  402dce:	607a      	str	r2, [r7, #4]
  402dd0:	603b      	str	r3, [r7, #0]
BaseType_t xReturn = pdFAIL;
  402dd2:	2300      	movs	r3, #0
  402dd4:	627b      	str	r3, [r7, #36]	; 0x24
DaemonTaskMessage_t xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
  402dd6:	4b1d      	ldr	r3, [pc, #116]	; (402e4c <xTimerGenericCommand+0x88>)
  402dd8:	681b      	ldr	r3, [r3, #0]
  402dda:	2b00      	cmp	r3, #0
  402ddc:	d030      	beq.n	402e40 <xTimerGenericCommand+0x7c>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
  402dde:	68bb      	ldr	r3, [r7, #8]
  402de0:	617b      	str	r3, [r7, #20]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
  402de2:	687b      	ldr	r3, [r7, #4]
  402de4:	61bb      	str	r3, [r7, #24]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
  402de6:	68fb      	ldr	r3, [r7, #12]
  402de8:	61fb      	str	r3, [r7, #28]

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
  402dea:	68bb      	ldr	r3, [r7, #8]
  402dec:	2b05      	cmp	r3, #5
  402dee:	dc1c      	bgt.n	402e2a <xTimerGenericCommand+0x66>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
  402df0:	4b17      	ldr	r3, [pc, #92]	; (402e50 <xTimerGenericCommand+0x8c>)
  402df2:	4798      	blx	r3
  402df4:	4603      	mov	r3, r0
  402df6:	2b02      	cmp	r3, #2
  402df8:	d10b      	bne.n	402e12 <xTimerGenericCommand+0x4e>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
  402dfa:	4b14      	ldr	r3, [pc, #80]	; (402e4c <xTimerGenericCommand+0x88>)
  402dfc:	681a      	ldr	r2, [r3, #0]
  402dfe:	f107 0314 	add.w	r3, r7, #20
  402e02:	4610      	mov	r0, r2
  402e04:	4619      	mov	r1, r3
  402e06:	6bba      	ldr	r2, [r7, #56]	; 0x38
  402e08:	2300      	movs	r3, #0
  402e0a:	4c12      	ldr	r4, [pc, #72]	; (402e54 <xTimerGenericCommand+0x90>)
  402e0c:	47a0      	blx	r4
  402e0e:	6278      	str	r0, [r7, #36]	; 0x24
  402e10:	e016      	b.n	402e40 <xTimerGenericCommand+0x7c>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
  402e12:	4b0e      	ldr	r3, [pc, #56]	; (402e4c <xTimerGenericCommand+0x88>)
  402e14:	681a      	ldr	r2, [r3, #0]
  402e16:	f107 0314 	add.w	r3, r7, #20
  402e1a:	4610      	mov	r0, r2
  402e1c:	4619      	mov	r1, r3
  402e1e:	2200      	movs	r2, #0
  402e20:	2300      	movs	r3, #0
  402e22:	4c0c      	ldr	r4, [pc, #48]	; (402e54 <xTimerGenericCommand+0x90>)
  402e24:	47a0      	blx	r4
  402e26:	6278      	str	r0, [r7, #36]	; 0x24
  402e28:	e00a      	b.n	402e40 <xTimerGenericCommand+0x7c>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
  402e2a:	4b08      	ldr	r3, [pc, #32]	; (402e4c <xTimerGenericCommand+0x88>)
  402e2c:	681a      	ldr	r2, [r3, #0]
  402e2e:	f107 0314 	add.w	r3, r7, #20
  402e32:	4610      	mov	r0, r2
  402e34:	4619      	mov	r1, r3
  402e36:	683a      	ldr	r2, [r7, #0]
  402e38:	2300      	movs	r3, #0
  402e3a:	4c07      	ldr	r4, [pc, #28]	; (402e58 <xTimerGenericCommand+0x94>)
  402e3c:	47a0      	blx	r4
  402e3e:	6278      	str	r0, [r7, #36]	; 0x24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
  402e40:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
  402e42:	4618      	mov	r0, r3
  402e44:	372c      	adds	r7, #44	; 0x2c
  402e46:	46bd      	mov	sp, r7
  402e48:	bd90      	pop	{r4, r7, pc}
  402e4a:	bf00      	nop
  402e4c:	2000c1c4 	.word	0x2000c1c4
  402e50:	00402b15 	.word	0x00402b15
  402e54:	004011cd 	.word	0x004011cd
  402e58:	004013f5 	.word	0x004013f5

00402e5c <prvProcessExpiredTimer>:
	return pxTimer->pcTimerName;
}
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
  402e5c:	b590      	push	{r4, r7, lr}
  402e5e:	b087      	sub	sp, #28
  402e60:	af02      	add	r7, sp, #8
  402e62:	6078      	str	r0, [r7, #4]
  402e64:	6039      	str	r1, [r7, #0]
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  402e66:	4b19      	ldr	r3, [pc, #100]	; (402ecc <prvProcessExpiredTimer+0x70>)
  402e68:	681b      	ldr	r3, [r3, #0]
  402e6a:	68db      	ldr	r3, [r3, #12]
  402e6c:	68db      	ldr	r3, [r3, #12]
  402e6e:	60fb      	str	r3, [r7, #12]

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  402e70:	68fb      	ldr	r3, [r7, #12]
  402e72:	3304      	adds	r3, #4
  402e74:	4618      	mov	r0, r3
  402e76:	4b16      	ldr	r3, [pc, #88]	; (402ed0 <prvProcessExpiredTimer+0x74>)
  402e78:	4798      	blx	r3
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
  402e7a:	68fb      	ldr	r3, [r7, #12]
  402e7c:	69db      	ldr	r3, [r3, #28]
  402e7e:	2b01      	cmp	r3, #1
  402e80:	d11d      	bne.n	402ebe <prvProcessExpiredTimer+0x62>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
  402e82:	68fb      	ldr	r3, [r7, #12]
  402e84:	699a      	ldr	r2, [r3, #24]
  402e86:	687b      	ldr	r3, [r7, #4]
  402e88:	4413      	add	r3, r2
  402e8a:	68f8      	ldr	r0, [r7, #12]
  402e8c:	4619      	mov	r1, r3
  402e8e:	683a      	ldr	r2, [r7, #0]
  402e90:	687b      	ldr	r3, [r7, #4]
  402e92:	4c10      	ldr	r4, [pc, #64]	; (402ed4 <prvProcessExpiredTimer+0x78>)
  402e94:	47a0      	blx	r4
  402e96:	4603      	mov	r3, r0
  402e98:	2b01      	cmp	r3, #1
  402e9a:	d110      	bne.n	402ebe <prvProcessExpiredTimer+0x62>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
  402e9c:	2300      	movs	r3, #0
  402e9e:	9300      	str	r3, [sp, #0]
  402ea0:	68f8      	ldr	r0, [r7, #12]
  402ea2:	2100      	movs	r1, #0
  402ea4:	687a      	ldr	r2, [r7, #4]
  402ea6:	2300      	movs	r3, #0
  402ea8:	4c0b      	ldr	r4, [pc, #44]	; (402ed8 <prvProcessExpiredTimer+0x7c>)
  402eaa:	47a0      	blx	r4
  402eac:	60b8      	str	r0, [r7, #8]
			configASSERT( xResult );
  402eae:	68bb      	ldr	r3, [r7, #8]
  402eb0:	2b00      	cmp	r3, #0
  402eb2:	d104      	bne.n	402ebe <prvProcessExpiredTimer+0x62>
  402eb4:	f44f 70c8 	mov.w	r0, #400	; 0x190
  402eb8:	4908      	ldr	r1, [pc, #32]	; (402edc <prvProcessExpiredTimer+0x80>)
  402eba:	4b09      	ldr	r3, [pc, #36]	; (402ee0 <prvProcessExpiredTimer+0x84>)
  402ebc:	4798      	blx	r3
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
  402ebe:	68fb      	ldr	r3, [r7, #12]
  402ec0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  402ec2:	68f8      	ldr	r0, [r7, #12]
  402ec4:	4798      	blx	r3
}
  402ec6:	3714      	adds	r7, #20
  402ec8:	46bd      	mov	sp, r7
  402eca:	bd90      	pop	{r4, r7, pc}
  402ecc:	2000c1bc 	.word	0x2000c1bc
  402ed0:	004006c9 	.word	0x004006c9
  402ed4:	00403035 	.word	0x00403035
  402ed8:	00402dc5 	.word	0x00402dc5
  402edc:	00404688 	.word	0x00404688
  402ee0:	004004d1 	.word	0x004004d1

00402ee4 <prvTimerTask>:
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
  402ee4:	b580      	push	{r7, lr}
  402ee6:	b084      	sub	sp, #16
  402ee8:	af00      	add	r7, sp, #0
  402eea:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
  402eec:	f107 0308 	add.w	r3, r7, #8
  402ef0:	4618      	mov	r0, r3
  402ef2:	4b05      	ldr	r3, [pc, #20]	; (402f08 <prvTimerTask+0x24>)
  402ef4:	4798      	blx	r3
  402ef6:	60f8      	str	r0, [r7, #12]

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
  402ef8:	68bb      	ldr	r3, [r7, #8]
  402efa:	68f8      	ldr	r0, [r7, #12]
  402efc:	4619      	mov	r1, r3
  402efe:	4b03      	ldr	r3, [pc, #12]	; (402f0c <prvTimerTask+0x28>)
  402f00:	4798      	blx	r3

		/* Empty the command queue. */
		prvProcessReceivedCommands();
  402f02:	4b03      	ldr	r3, [pc, #12]	; (402f10 <prvTimerTask+0x2c>)
  402f04:	4798      	blx	r3
	}
  402f06:	e7f1      	b.n	402eec <prvTimerTask+0x8>
  402f08:	00402fa5 	.word	0x00402fa5
  402f0c:	00402f15 	.word	0x00402f15
  402f10:	004030bd 	.word	0x004030bd

00402f14 <prvProcessTimerOrBlockTask>:
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
{
  402f14:	b580      	push	{r7, lr}
  402f16:	b084      	sub	sp, #16
  402f18:	af00      	add	r7, sp, #0
  402f1a:	6078      	str	r0, [r7, #4]
  402f1c:	6039      	str	r1, [r7, #0]
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
  402f1e:	4b1a      	ldr	r3, [pc, #104]	; (402f88 <prvProcessTimerOrBlockTask+0x74>)
  402f20:	4798      	blx	r3
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  402f22:	f107 0308 	add.w	r3, r7, #8
  402f26:	4618      	mov	r0, r3
  402f28:	4b18      	ldr	r3, [pc, #96]	; (402f8c <prvProcessTimerOrBlockTask+0x78>)
  402f2a:	4798      	blx	r3
  402f2c:	60f8      	str	r0, [r7, #12]
		if( xTimerListsWereSwitched == pdFALSE )
  402f2e:	68bb      	ldr	r3, [r7, #8]
  402f30:	2b00      	cmp	r3, #0
  402f32:	d124      	bne.n	402f7e <prvProcessTimerOrBlockTask+0x6a>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
  402f34:	683b      	ldr	r3, [r7, #0]
  402f36:	2b00      	cmp	r3, #0
  402f38:	d10a      	bne.n	402f50 <prvProcessTimerOrBlockTask+0x3c>
  402f3a:	687a      	ldr	r2, [r7, #4]
  402f3c:	68fb      	ldr	r3, [r7, #12]
  402f3e:	429a      	cmp	r2, r3
  402f40:	d806      	bhi.n	402f50 <prvProcessTimerOrBlockTask+0x3c>
			{
				( void ) xTaskResumeAll();
  402f42:	4b13      	ldr	r3, [pc, #76]	; (402f90 <prvProcessTimerOrBlockTask+0x7c>)
  402f44:	4798      	blx	r3
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
  402f46:	6878      	ldr	r0, [r7, #4]
  402f48:	68f9      	ldr	r1, [r7, #12]
  402f4a:	4b12      	ldr	r3, [pc, #72]	; (402f94 <prvProcessTimerOrBlockTask+0x80>)
  402f4c:	4798      	blx	r3
  402f4e:	e018      	b.n	402f82 <prvProcessTimerOrBlockTask+0x6e>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
  402f50:	4b11      	ldr	r3, [pc, #68]	; (402f98 <prvProcessTimerOrBlockTask+0x84>)
  402f52:	681a      	ldr	r2, [r3, #0]
  402f54:	6879      	ldr	r1, [r7, #4]
  402f56:	68fb      	ldr	r3, [r7, #12]
  402f58:	1acb      	subs	r3, r1, r3
  402f5a:	4610      	mov	r0, r2
  402f5c:	4619      	mov	r1, r3
  402f5e:	4b0f      	ldr	r3, [pc, #60]	; (402f9c <prvProcessTimerOrBlockTask+0x88>)
  402f60:	4798      	blx	r3

				if( xTaskResumeAll() == pdFALSE )
  402f62:	4b0b      	ldr	r3, [pc, #44]	; (402f90 <prvProcessTimerOrBlockTask+0x7c>)
  402f64:	4798      	blx	r3
  402f66:	4603      	mov	r3, r0
  402f68:	2b00      	cmp	r3, #0
  402f6a:	d10a      	bne.n	402f82 <prvProcessTimerOrBlockTask+0x6e>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
  402f6c:	4b0c      	ldr	r3, [pc, #48]	; (402fa0 <prvProcessTimerOrBlockTask+0x8c>)
  402f6e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  402f72:	601a      	str	r2, [r3, #0]
  402f74:	f3bf 8f4f 	dsb	sy
  402f78:	f3bf 8f6f 	isb	sy
  402f7c:	e001      	b.n	402f82 <prvProcessTimerOrBlockTask+0x6e>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
  402f7e:	4b04      	ldr	r3, [pc, #16]	; (402f90 <prvProcessTimerOrBlockTask+0x7c>)
  402f80:	4798      	blx	r3
		}
	}
}
  402f82:	3710      	adds	r7, #16
  402f84:	46bd      	mov	sp, r7
  402f86:	bd80      	pop	{r7, pc}
  402f88:	00401f59 	.word	0x00401f59
  402f8c:	00402fed 	.word	0x00402fed
  402f90:	00401fc5 	.word	0x00401fc5
  402f94:	00402e5d 	.word	0x00402e5d
  402f98:	2000c1c4 	.word	0x2000c1c4
  402f9c:	00401b0d 	.word	0x00401b0d
  402fa0:	e000ed04 	.word	0xe000ed04

00402fa4 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
  402fa4:	b480      	push	{r7}
  402fa6:	b085      	sub	sp, #20
  402fa8:	af00      	add	r7, sp, #0
  402faa:	6078      	str	r0, [r7, #4]
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
  402fac:	4b0e      	ldr	r3, [pc, #56]	; (402fe8 <prvGetNextExpireTime+0x44>)
  402fae:	681b      	ldr	r3, [r3, #0]
  402fb0:	681b      	ldr	r3, [r3, #0]
  402fb2:	2b00      	cmp	r3, #0
  402fb4:	bf14      	ite	ne
  402fb6:	2300      	movne	r3, #0
  402fb8:	2301      	moveq	r3, #1
  402fba:	b2db      	uxtb	r3, r3
  402fbc:	461a      	mov	r2, r3
  402fbe:	687b      	ldr	r3, [r7, #4]
  402fc0:	601a      	str	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
  402fc2:	687b      	ldr	r3, [r7, #4]
  402fc4:	681b      	ldr	r3, [r3, #0]
  402fc6:	2b00      	cmp	r3, #0
  402fc8:	d105      	bne.n	402fd6 <prvGetNextExpireTime+0x32>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  402fca:	4b07      	ldr	r3, [pc, #28]	; (402fe8 <prvGetNextExpireTime+0x44>)
  402fcc:	681b      	ldr	r3, [r3, #0]
  402fce:	68db      	ldr	r3, [r3, #12]
  402fd0:	681b      	ldr	r3, [r3, #0]
  402fd2:	60fb      	str	r3, [r7, #12]
  402fd4:	e001      	b.n	402fda <prvGetNextExpireTime+0x36>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
  402fd6:	2300      	movs	r3, #0
  402fd8:	60fb      	str	r3, [r7, #12]
	}

	return xNextExpireTime;
  402fda:	68fb      	ldr	r3, [r7, #12]
}
  402fdc:	4618      	mov	r0, r3
  402fde:	3714      	adds	r7, #20
  402fe0:	46bd      	mov	sp, r7
  402fe2:	f85d 7b04 	ldr.w	r7, [sp], #4
  402fe6:	4770      	bx	lr
  402fe8:	2000c1bc 	.word	0x2000c1bc

00402fec <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
  402fec:	b580      	push	{r7, lr}
  402fee:	b084      	sub	sp, #16
  402ff0:	af00      	add	r7, sp, #0
  402ff2:	6078      	str	r0, [r7, #4]
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
  402ff4:	4b0c      	ldr	r3, [pc, #48]	; (403028 <prvSampleTimeNow+0x3c>)
  402ff6:	4798      	blx	r3
  402ff8:	60f8      	str	r0, [r7, #12]

	if( xTimeNow < xLastTime )
  402ffa:	4b0c      	ldr	r3, [pc, #48]	; (40302c <prvSampleTimeNow+0x40>)
  402ffc:	681b      	ldr	r3, [r3, #0]
  402ffe:	68fa      	ldr	r2, [r7, #12]
  403000:	429a      	cmp	r2, r3
  403002:	d205      	bcs.n	403010 <prvSampleTimeNow+0x24>
	{
		prvSwitchTimerLists();
  403004:	4b0a      	ldr	r3, [pc, #40]	; (403030 <prvSampleTimeNow+0x44>)
  403006:	4798      	blx	r3
		*pxTimerListsWereSwitched = pdTRUE;
  403008:	687b      	ldr	r3, [r7, #4]
  40300a:	2201      	movs	r2, #1
  40300c:	601a      	str	r2, [r3, #0]
  40300e:	e002      	b.n	403016 <prvSampleTimeNow+0x2a>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
  403010:	687b      	ldr	r3, [r7, #4]
  403012:	2200      	movs	r2, #0
  403014:	601a      	str	r2, [r3, #0]
	}

	xLastTime = xTimeNow;
  403016:	4b05      	ldr	r3, [pc, #20]	; (40302c <prvSampleTimeNow+0x40>)
  403018:	68fa      	ldr	r2, [r7, #12]
  40301a:	601a      	str	r2, [r3, #0]

	return xTimeNow;
  40301c:	68fb      	ldr	r3, [r7, #12]
}
  40301e:	4618      	mov	r0, r3
  403020:	3710      	adds	r7, #16
  403022:	46bd      	mov	sp, r7
  403024:	bd80      	pop	{r7, pc}
  403026:	bf00      	nop
  403028:	004020fd 	.word	0x004020fd
  40302c:	2000c1c8 	.word	0x2000c1c8
  403030:	00403229 	.word	0x00403229

00403034 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
  403034:	b580      	push	{r7, lr}
  403036:	b086      	sub	sp, #24
  403038:	af00      	add	r7, sp, #0
  40303a:	60f8      	str	r0, [r7, #12]
  40303c:	60b9      	str	r1, [r7, #8]
  40303e:	607a      	str	r2, [r7, #4]
  403040:	603b      	str	r3, [r7, #0]
BaseType_t xProcessTimerNow = pdFALSE;
  403042:	2300      	movs	r3, #0
  403044:	617b      	str	r3, [r7, #20]

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
  403046:	68fb      	ldr	r3, [r7, #12]
  403048:	68ba      	ldr	r2, [r7, #8]
  40304a:	605a      	str	r2, [r3, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  40304c:	68fb      	ldr	r3, [r7, #12]
  40304e:	68fa      	ldr	r2, [r7, #12]
  403050:	611a      	str	r2, [r3, #16]

	if( xNextExpiryTime <= xTimeNow )
  403052:	68ba      	ldr	r2, [r7, #8]
  403054:	687b      	ldr	r3, [r7, #4]
  403056:	429a      	cmp	r2, r3
  403058:	d812      	bhi.n	403080 <prvInsertTimerInActiveList+0x4c>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
  40305a:	687a      	ldr	r2, [r7, #4]
  40305c:	683b      	ldr	r3, [r7, #0]
  40305e:	1ad2      	subs	r2, r2, r3
  403060:	68fb      	ldr	r3, [r7, #12]
  403062:	699b      	ldr	r3, [r3, #24]
  403064:	429a      	cmp	r2, r3
  403066:	d302      	bcc.n	40306e <prvInsertTimerInActiveList+0x3a>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
  403068:	2301      	movs	r3, #1
  40306a:	617b      	str	r3, [r7, #20]
  40306c:	e01b      	b.n	4030a6 <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
  40306e:	4b10      	ldr	r3, [pc, #64]	; (4030b0 <prvInsertTimerInActiveList+0x7c>)
  403070:	681a      	ldr	r2, [r3, #0]
  403072:	68fb      	ldr	r3, [r7, #12]
  403074:	3304      	adds	r3, #4
  403076:	4610      	mov	r0, r2
  403078:	4619      	mov	r1, r3
  40307a:	4b0e      	ldr	r3, [pc, #56]	; (4030b4 <prvInsertTimerInActiveList+0x80>)
  40307c:	4798      	blx	r3
  40307e:	e012      	b.n	4030a6 <prvInsertTimerInActiveList+0x72>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
  403080:	687a      	ldr	r2, [r7, #4]
  403082:	683b      	ldr	r3, [r7, #0]
  403084:	429a      	cmp	r2, r3
  403086:	d206      	bcs.n	403096 <prvInsertTimerInActiveList+0x62>
  403088:	68ba      	ldr	r2, [r7, #8]
  40308a:	683b      	ldr	r3, [r7, #0]
  40308c:	429a      	cmp	r2, r3
  40308e:	d302      	bcc.n	403096 <prvInsertTimerInActiveList+0x62>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
  403090:	2301      	movs	r3, #1
  403092:	617b      	str	r3, [r7, #20]
  403094:	e007      	b.n	4030a6 <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  403096:	4b08      	ldr	r3, [pc, #32]	; (4030b8 <prvInsertTimerInActiveList+0x84>)
  403098:	681a      	ldr	r2, [r3, #0]
  40309a:	68fb      	ldr	r3, [r7, #12]
  40309c:	3304      	adds	r3, #4
  40309e:	4610      	mov	r0, r2
  4030a0:	4619      	mov	r1, r3
  4030a2:	4b04      	ldr	r3, [pc, #16]	; (4030b4 <prvInsertTimerInActiveList+0x80>)
  4030a4:	4798      	blx	r3
		}
	}

	return xProcessTimerNow;
  4030a6:	697b      	ldr	r3, [r7, #20]
}
  4030a8:	4618      	mov	r0, r3
  4030aa:	3718      	adds	r7, #24
  4030ac:	46bd      	mov	sp, r7
  4030ae:	bd80      	pop	{r7, pc}
  4030b0:	2000c1c0 	.word	0x2000c1c0
  4030b4:	00400659 	.word	0x00400659
  4030b8:	2000c1bc 	.word	0x2000c1bc

004030bc <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
  4030bc:	b590      	push	{r4, r7, lr}
  4030be:	b08d      	sub	sp, #52	; 0x34
  4030c0:	af02      	add	r7, sp, #8
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
  4030c2:	e08d      	b.n	4031e0 <prvProcessReceivedCommands+0x124>
	{
		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
		{
			/* Negative commands are pended function calls rather than timer
			commands. */
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
  4030c4:	68bb      	ldr	r3, [r7, #8]
  4030c6:	2b00      	cmp	r3, #0
  4030c8:	da14      	bge.n	4030f4 <prvProcessReceivedCommands+0x38>
			{
				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
  4030ca:	f107 0308 	add.w	r3, r7, #8
  4030ce:	3304      	adds	r3, #4
  4030d0:	627b      	str	r3, [r7, #36]	; 0x24

				/* The timer uses the xCallbackParameters member to request a
				callback be executed.  Check the callback is not NULL. */
				configASSERT( pxCallback );
  4030d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4030d4:	2b00      	cmp	r3, #0
  4030d6:	d104      	bne.n	4030e2 <prvProcessReceivedCommands+0x26>
  4030d8:	f44f 7017 	mov.w	r0, #604	; 0x25c
  4030dc:	4949      	ldr	r1, [pc, #292]	; (403204 <prvProcessReceivedCommands+0x148>)
  4030de:	4b4a      	ldr	r3, [pc, #296]	; (403208 <prvProcessReceivedCommands+0x14c>)
  4030e0:	4798      	blx	r3

				/* Call the function. */
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
  4030e2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4030e4:	681b      	ldr	r3, [r3, #0]
  4030e6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4030e8:	6851      	ldr	r1, [r2, #4]
  4030ea:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4030ec:	6892      	ldr	r2, [r2, #8]
  4030ee:	4608      	mov	r0, r1
  4030f0:	4611      	mov	r1, r2
  4030f2:	4798      	blx	r3
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
  4030f4:	68bb      	ldr	r3, [r7, #8]
  4030f6:	2b00      	cmp	r3, #0
  4030f8:	db72      	blt.n	4031e0 <prvProcessReceivedCommands+0x124>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
  4030fa:	693b      	ldr	r3, [r7, #16]
  4030fc:	623b      	str	r3, [r7, #32]

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
  4030fe:	6a3b      	ldr	r3, [r7, #32]
  403100:	695b      	ldr	r3, [r3, #20]
  403102:	2b00      	cmp	r3, #0
  403104:	d004      	beq.n	403110 <prvProcessReceivedCommands+0x54>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  403106:	6a3b      	ldr	r3, [r7, #32]
  403108:	3304      	adds	r3, #4
  40310a:	4618      	mov	r0, r3
  40310c:	4b3f      	ldr	r3, [pc, #252]	; (40320c <prvProcessReceivedCommands+0x150>)
  40310e:	4798      	blx	r3
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  403110:	1d3b      	adds	r3, r7, #4
  403112:	4618      	mov	r0, r3
  403114:	4b3e      	ldr	r3, [pc, #248]	; (403210 <prvProcessReceivedCommands+0x154>)
  403116:	4798      	blx	r3
  403118:	61f8      	str	r0, [r7, #28]

			switch( xMessage.xMessageID )
  40311a:	68bb      	ldr	r3, [r7, #8]
  40311c:	2b09      	cmp	r3, #9
  40311e:	d85e      	bhi.n	4031de <prvProcessReceivedCommands+0x122>
  403120:	a201      	add	r2, pc, #4	; (adr r2, 403128 <prvProcessReceivedCommands+0x6c>)
  403122:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  403126:	bf00      	nop
  403128:	00403151 	.word	0x00403151
  40312c:	00403151 	.word	0x00403151
  403130:	00403151 	.word	0x00403151
  403134:	004031df 	.word	0x004031df
  403138:	004031a9 	.word	0x004031a9
  40313c:	004031d7 	.word	0x004031d7
  403140:	00403151 	.word	0x00403151
  403144:	00403151 	.word	0x00403151
  403148:	004031df 	.word	0x004031df
  40314c:	004031a9 	.word	0x004031a9
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
  403150:	68fa      	ldr	r2, [r7, #12]
  403152:	6a3b      	ldr	r3, [r7, #32]
  403154:	699b      	ldr	r3, [r3, #24]
  403156:	441a      	add	r2, r3
  403158:	68fb      	ldr	r3, [r7, #12]
  40315a:	6a38      	ldr	r0, [r7, #32]
  40315c:	4611      	mov	r1, r2
  40315e:	69fa      	ldr	r2, [r7, #28]
  403160:	4c2c      	ldr	r4, [pc, #176]	; (403214 <prvProcessReceivedCommands+0x158>)
  403162:	47a0      	blx	r4
  403164:	4603      	mov	r3, r0
  403166:	2b01      	cmp	r3, #1
  403168:	d11d      	bne.n	4031a6 <prvProcessReceivedCommands+0xea>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
  40316a:	6a3b      	ldr	r3, [r7, #32]
  40316c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  40316e:	6a38      	ldr	r0, [r7, #32]
  403170:	4798      	blx	r3
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
  403172:	6a3b      	ldr	r3, [r7, #32]
  403174:	69db      	ldr	r3, [r3, #28]
  403176:	2b01      	cmp	r3, #1
  403178:	d115      	bne.n	4031a6 <prvProcessReceivedCommands+0xea>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
  40317a:	68fa      	ldr	r2, [r7, #12]
  40317c:	6a3b      	ldr	r3, [r7, #32]
  40317e:	699b      	ldr	r3, [r3, #24]
  403180:	4413      	add	r3, r2
  403182:	2200      	movs	r2, #0
  403184:	9200      	str	r2, [sp, #0]
  403186:	6a38      	ldr	r0, [r7, #32]
  403188:	2100      	movs	r1, #0
  40318a:	461a      	mov	r2, r3
  40318c:	2300      	movs	r3, #0
  40318e:	4c22      	ldr	r4, [pc, #136]	; (403218 <prvProcessReceivedCommands+0x15c>)
  403190:	47a0      	blx	r4
  403192:	61b8      	str	r0, [r7, #24]
							configASSERT( xResult );
  403194:	69bb      	ldr	r3, [r7, #24]
  403196:	2b00      	cmp	r3, #0
  403198:	d105      	bne.n	4031a6 <prvProcessReceivedCommands+0xea>
  40319a:	f240 2096 	movw	r0, #662	; 0x296
  40319e:	4919      	ldr	r1, [pc, #100]	; (403204 <prvProcessReceivedCommands+0x148>)
  4031a0:	4b19      	ldr	r3, [pc, #100]	; (403208 <prvProcessReceivedCommands+0x14c>)
  4031a2:	4798      	blx	r3
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					break;
  4031a4:	e01c      	b.n	4031e0 <prvProcessReceivedCommands+0x124>
  4031a6:	e01b      	b.n	4031e0 <prvProcessReceivedCommands+0x124>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
  4031a8:	68fa      	ldr	r2, [r7, #12]
  4031aa:	6a3b      	ldr	r3, [r7, #32]
  4031ac:	619a      	str	r2, [r3, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
  4031ae:	6a3b      	ldr	r3, [r7, #32]
  4031b0:	699b      	ldr	r3, [r3, #24]
  4031b2:	2b00      	cmp	r3, #0
  4031b4:	d104      	bne.n	4031c0 <prvProcessReceivedCommands+0x104>
  4031b6:	f240 20ad 	movw	r0, #685	; 0x2ad
  4031ba:	4912      	ldr	r1, [pc, #72]	; (403204 <prvProcessReceivedCommands+0x148>)
  4031bc:	4b12      	ldr	r3, [pc, #72]	; (403208 <prvProcessReceivedCommands+0x14c>)
  4031be:	4798      	blx	r3
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
  4031c0:	6a3b      	ldr	r3, [r7, #32]
  4031c2:	699a      	ldr	r2, [r3, #24]
  4031c4:	69fb      	ldr	r3, [r7, #28]
  4031c6:	4413      	add	r3, r2
  4031c8:	6a38      	ldr	r0, [r7, #32]
  4031ca:	4619      	mov	r1, r3
  4031cc:	69fa      	ldr	r2, [r7, #28]
  4031ce:	69fb      	ldr	r3, [r7, #28]
  4031d0:	4c10      	ldr	r4, [pc, #64]	; (403214 <prvProcessReceivedCommands+0x158>)
  4031d2:	47a0      	blx	r4
					break;
  4031d4:	e004      	b.n	4031e0 <prvProcessReceivedCommands+0x124>

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
  4031d6:	6a38      	ldr	r0, [r7, #32]
  4031d8:	4b10      	ldr	r3, [pc, #64]	; (40321c <prvProcessReceivedCommands+0x160>)
  4031da:	4798      	blx	r3
					break;
  4031dc:	e000      	b.n	4031e0 <prvProcessReceivedCommands+0x124>

				default	:
					/* Don't expect to get here. */
					break;
  4031de:	bf00      	nop
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
  4031e0:	4b0f      	ldr	r3, [pc, #60]	; (403220 <prvProcessReceivedCommands+0x164>)
  4031e2:	681a      	ldr	r2, [r3, #0]
  4031e4:	f107 0308 	add.w	r3, r7, #8
  4031e8:	4610      	mov	r0, r2
  4031ea:	4619      	mov	r1, r3
  4031ec:	2200      	movs	r2, #0
  4031ee:	2300      	movs	r3, #0
  4031f0:	4c0c      	ldr	r4, [pc, #48]	; (403224 <prvProcessReceivedCommands+0x168>)
  4031f2:	47a0      	blx	r4
  4031f4:	4603      	mov	r3, r0
  4031f6:	2b00      	cmp	r3, #0
  4031f8:	f47f af64 	bne.w	4030c4 <prvProcessReceivedCommands+0x8>
					/* Don't expect to get here. */
					break;
			}
		}
	}
}
  4031fc:	372c      	adds	r7, #44	; 0x2c
  4031fe:	46bd      	mov	sp, r7
  403200:	bd90      	pop	{r4, r7, pc}
  403202:	bf00      	nop
  403204:	00404688 	.word	0x00404688
  403208:	004004d1 	.word	0x004004d1
  40320c:	004006c9 	.word	0x004006c9
  403210:	00402fed 	.word	0x00402fed
  403214:	00403035 	.word	0x00403035
  403218:	00402dc5 	.word	0x00402dc5
  40321c:	00400e15 	.word	0x00400e15
  403220:	2000c1c4 	.word	0x2000c1c4
  403224:	00401625 	.word	0x00401625

00403228 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
  403228:	b590      	push	{r4, r7, lr}
  40322a:	b089      	sub	sp, #36	; 0x24
  40322c:	af02      	add	r7, sp, #8

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  40322e:	e03f      	b.n	4032b0 <prvSwitchTimerLists+0x88>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  403230:	4b28      	ldr	r3, [pc, #160]	; (4032d4 <prvSwitchTimerLists+0xac>)
  403232:	681b      	ldr	r3, [r3, #0]
  403234:	68db      	ldr	r3, [r3, #12]
  403236:	681b      	ldr	r3, [r3, #0]
  403238:	617b      	str	r3, [r7, #20]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  40323a:	4b26      	ldr	r3, [pc, #152]	; (4032d4 <prvSwitchTimerLists+0xac>)
  40323c:	681b      	ldr	r3, [r3, #0]
  40323e:	68db      	ldr	r3, [r3, #12]
  403240:	68db      	ldr	r3, [r3, #12]
  403242:	613b      	str	r3, [r7, #16]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  403244:	693b      	ldr	r3, [r7, #16]
  403246:	3304      	adds	r3, #4
  403248:	4618      	mov	r0, r3
  40324a:	4b23      	ldr	r3, [pc, #140]	; (4032d8 <prvSwitchTimerLists+0xb0>)
  40324c:	4798      	blx	r3
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
  40324e:	693b      	ldr	r3, [r7, #16]
  403250:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  403252:	6938      	ldr	r0, [r7, #16]
  403254:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
  403256:	693b      	ldr	r3, [r7, #16]
  403258:	69db      	ldr	r3, [r3, #28]
  40325a:	2b01      	cmp	r3, #1
  40325c:	d128      	bne.n	4032b0 <prvSwitchTimerLists+0x88>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
  40325e:	693b      	ldr	r3, [r7, #16]
  403260:	699a      	ldr	r2, [r3, #24]
  403262:	697b      	ldr	r3, [r7, #20]
  403264:	4413      	add	r3, r2
  403266:	60fb      	str	r3, [r7, #12]
			if( xReloadTime > xNextExpireTime )
  403268:	68fa      	ldr	r2, [r7, #12]
  40326a:	697b      	ldr	r3, [r7, #20]
  40326c:	429a      	cmp	r2, r3
  40326e:	d90e      	bls.n	40328e <prvSwitchTimerLists+0x66>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
  403270:	693b      	ldr	r3, [r7, #16]
  403272:	68fa      	ldr	r2, [r7, #12]
  403274:	605a      	str	r2, [r3, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  403276:	693b      	ldr	r3, [r7, #16]
  403278:	693a      	ldr	r2, [r7, #16]
  40327a:	611a      	str	r2, [r3, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  40327c:	4b15      	ldr	r3, [pc, #84]	; (4032d4 <prvSwitchTimerLists+0xac>)
  40327e:	681a      	ldr	r2, [r3, #0]
  403280:	693b      	ldr	r3, [r7, #16]
  403282:	3304      	adds	r3, #4
  403284:	4610      	mov	r0, r2
  403286:	4619      	mov	r1, r3
  403288:	4b14      	ldr	r3, [pc, #80]	; (4032dc <prvSwitchTimerLists+0xb4>)
  40328a:	4798      	blx	r3
  40328c:	e010      	b.n	4032b0 <prvSwitchTimerLists+0x88>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
  40328e:	2300      	movs	r3, #0
  403290:	9300      	str	r3, [sp, #0]
  403292:	6938      	ldr	r0, [r7, #16]
  403294:	2100      	movs	r1, #0
  403296:	697a      	ldr	r2, [r7, #20]
  403298:	2300      	movs	r3, #0
  40329a:	4c11      	ldr	r4, [pc, #68]	; (4032e0 <prvSwitchTimerLists+0xb8>)
  40329c:	47a0      	blx	r4
  40329e:	60b8      	str	r0, [r7, #8]
				configASSERT( xResult );
  4032a0:	68bb      	ldr	r3, [r7, #8]
  4032a2:	2b00      	cmp	r3, #0
  4032a4:	d104      	bne.n	4032b0 <prvSwitchTimerLists+0x88>
  4032a6:	f240 20f2 	movw	r0, #754	; 0x2f2
  4032aa:	490e      	ldr	r1, [pc, #56]	; (4032e4 <prvSwitchTimerLists+0xbc>)
  4032ac:	4b0e      	ldr	r3, [pc, #56]	; (4032e8 <prvSwitchTimerLists+0xc0>)
  4032ae:	4798      	blx	r3

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  4032b0:	4b08      	ldr	r3, [pc, #32]	; (4032d4 <prvSwitchTimerLists+0xac>)
  4032b2:	681b      	ldr	r3, [r3, #0]
  4032b4:	681b      	ldr	r3, [r3, #0]
  4032b6:	2b00      	cmp	r3, #0
  4032b8:	d1ba      	bne.n	403230 <prvSwitchTimerLists+0x8>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
  4032ba:	4b06      	ldr	r3, [pc, #24]	; (4032d4 <prvSwitchTimerLists+0xac>)
  4032bc:	681b      	ldr	r3, [r3, #0]
  4032be:	607b      	str	r3, [r7, #4]
	pxCurrentTimerList = pxOverflowTimerList;
  4032c0:	4b0a      	ldr	r3, [pc, #40]	; (4032ec <prvSwitchTimerLists+0xc4>)
  4032c2:	681a      	ldr	r2, [r3, #0]
  4032c4:	4b03      	ldr	r3, [pc, #12]	; (4032d4 <prvSwitchTimerLists+0xac>)
  4032c6:	601a      	str	r2, [r3, #0]
	pxOverflowTimerList = pxTemp;
  4032c8:	4b08      	ldr	r3, [pc, #32]	; (4032ec <prvSwitchTimerLists+0xc4>)
  4032ca:	687a      	ldr	r2, [r7, #4]
  4032cc:	601a      	str	r2, [r3, #0]
}
  4032ce:	371c      	adds	r7, #28
  4032d0:	46bd      	mov	sp, r7
  4032d2:	bd90      	pop	{r4, r7, pc}
  4032d4:	2000c1bc 	.word	0x2000c1bc
  4032d8:	004006c9 	.word	0x004006c9
  4032dc:	00400659 	.word	0x00400659
  4032e0:	00402dc5 	.word	0x00402dc5
  4032e4:	00404688 	.word	0x00404688
  4032e8:	004004d1 	.word	0x004004d1
  4032ec:	2000c1c0 	.word	0x2000c1c0

004032f0 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
  4032f0:	b580      	push	{r7, lr}
  4032f2:	af00      	add	r7, sp, #0
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
  4032f4:	4b17      	ldr	r3, [pc, #92]	; (403354 <prvCheckForValidListAndQueue+0x64>)
  4032f6:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
  4032f8:	4b17      	ldr	r3, [pc, #92]	; (403358 <prvCheckForValidListAndQueue+0x68>)
  4032fa:	681b      	ldr	r3, [r3, #0]
  4032fc:	2b00      	cmp	r3, #0
  4032fe:	d126      	bne.n	40334e <prvCheckForValidListAndQueue+0x5e>
		{
			vListInitialise( &xActiveTimerList1 );
  403300:	4816      	ldr	r0, [pc, #88]	; (40335c <prvCheckForValidListAndQueue+0x6c>)
  403302:	4b17      	ldr	r3, [pc, #92]	; (403360 <prvCheckForValidListAndQueue+0x70>)
  403304:	4798      	blx	r3
			vListInitialise( &xActiveTimerList2 );
  403306:	4817      	ldr	r0, [pc, #92]	; (403364 <prvCheckForValidListAndQueue+0x74>)
  403308:	4b15      	ldr	r3, [pc, #84]	; (403360 <prvCheckForValidListAndQueue+0x70>)
  40330a:	4798      	blx	r3
			pxCurrentTimerList = &xActiveTimerList1;
  40330c:	4b16      	ldr	r3, [pc, #88]	; (403368 <prvCheckForValidListAndQueue+0x78>)
  40330e:	4a13      	ldr	r2, [pc, #76]	; (40335c <prvCheckForValidListAndQueue+0x6c>)
  403310:	601a      	str	r2, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
  403312:	4b16      	ldr	r3, [pc, #88]	; (40336c <prvCheckForValidListAndQueue+0x7c>)
  403314:	4a13      	ldr	r2, [pc, #76]	; (403364 <prvCheckForValidListAndQueue+0x74>)
  403316:	601a      	str	r2, [r3, #0]
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
  403318:	2005      	movs	r0, #5
  40331a:	2110      	movs	r1, #16
  40331c:	2200      	movs	r2, #0
  40331e:	4b14      	ldr	r3, [pc, #80]	; (403370 <prvCheckForValidListAndQueue+0x80>)
  403320:	4798      	blx	r3
  403322:	4602      	mov	r2, r0
  403324:	4b0c      	ldr	r3, [pc, #48]	; (403358 <prvCheckForValidListAndQueue+0x68>)
  403326:	601a      	str	r2, [r3, #0]
			configASSERT( xTimerQueue );
  403328:	4b0b      	ldr	r3, [pc, #44]	; (403358 <prvCheckForValidListAndQueue+0x68>)
  40332a:	681b      	ldr	r3, [r3, #0]
  40332c:	2b00      	cmp	r3, #0
  40332e:	d104      	bne.n	40333a <prvCheckForValidListAndQueue+0x4a>
  403330:	f44f 7044 	mov.w	r0, #784	; 0x310
  403334:	490f      	ldr	r1, [pc, #60]	; (403374 <prvCheckForValidListAndQueue+0x84>)
  403336:	4b10      	ldr	r3, [pc, #64]	; (403378 <prvCheckForValidListAndQueue+0x88>)
  403338:	4798      	blx	r3

			#if ( configQUEUE_REGISTRY_SIZE > 0 )
			{
				if( xTimerQueue != NULL )
  40333a:	4b07      	ldr	r3, [pc, #28]	; (403358 <prvCheckForValidListAndQueue+0x68>)
  40333c:	681b      	ldr	r3, [r3, #0]
  40333e:	2b00      	cmp	r3, #0
  403340:	d005      	beq.n	40334e <prvCheckForValidListAndQueue+0x5e>
				{
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
  403342:	4b05      	ldr	r3, [pc, #20]	; (403358 <prvCheckForValidListAndQueue+0x68>)
  403344:	681b      	ldr	r3, [r3, #0]
  403346:	4618      	mov	r0, r3
  403348:	490c      	ldr	r1, [pc, #48]	; (40337c <prvCheckForValidListAndQueue+0x8c>)
  40334a:	4b0d      	ldr	r3, [pc, #52]	; (403380 <prvCheckForValidListAndQueue+0x90>)
  40334c:	4798      	blx	r3
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
  40334e:	4b0d      	ldr	r3, [pc, #52]	; (403384 <prvCheckForValidListAndQueue+0x94>)
  403350:	4798      	blx	r3
}
  403352:	bd80      	pop	{r7, pc}
  403354:	004008dd 	.word	0x004008dd
  403358:	2000c1c4 	.word	0x2000c1c4
  40335c:	2000c194 	.word	0x2000c194
  403360:	004005b9 	.word	0x004005b9
  403364:	2000c1a8 	.word	0x2000c1a8
  403368:	2000c1bc 	.word	0x2000c1bc
  40336c:	2000c1c0 	.word	0x2000c1c0
  403370:	00401115 	.word	0x00401115
  403374:	00404688 	.word	0x00404688
  403378:	004004d1 	.word	0x004004d1
  40337c:	004046b0 	.word	0x004046b0
  403380:	00401abd 	.word	0x00401abd
  403384:	00400931 	.word	0x00400931

00403388 <can_writeProtectionEnable>:
	{25, (7 + 1), (7 + 1), (7 + 1), (3 + 1), 68}
};

void can_enableRXInterrupt(Can *can);

void can_writeProtectionEnable(Can *can){
  403388:	b480      	push	{r7}
  40338a:	b083      	sub	sp, #12
  40338c:	af00      	add	r7, sp, #0
  40338e:	6078      	str	r0, [r7, #4]
	can->CAN_WPMR = CAN_WPMR_WPKEY_PASSWD | CAN_WPMR_WPEN;
  403390:	687b      	ldr	r3, [r7, #4]
  403392:	4a04      	ldr	r2, [pc, #16]	; (4033a4 <can_writeProtectionEnable+0x1c>)
  403394:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
}
  403398:	370c      	adds	r7, #12
  40339a:	46bd      	mov	sp, r7
  40339c:	f85d 7b04 	ldr.w	r7, [sp], #4
  4033a0:	4770      	bx	lr
  4033a2:	bf00      	nop
  4033a4:	43414e01 	.word	0x43414e01

004033a8 <can_writeProtectionDisable>:

void can_writeProtectionDisable(Can *can){
  4033a8:	b480      	push	{r7}
  4033aa:	b083      	sub	sp, #12
  4033ac:	af00      	add	r7, sp, #0
  4033ae:	6078      	str	r0, [r7, #4]
	can->CAN_WPMR = CAN_WPMR_WPKEY_PASSWD;
  4033b0:	687b      	ldr	r3, [r7, #4]
  4033b2:	4a04      	ldr	r2, [pc, #16]	; (4033c4 <can_writeProtectionDisable+0x1c>)
  4033b4:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
}
  4033b8:	370c      	adds	r7, #12
  4033ba:	46bd      	mov	sp, r7
  4033bc:	f85d 7b04 	ldr.w	r7, [sp], #4
  4033c0:	4770      	bx	lr
  4033c2:	bf00      	nop
  4033c4:	43414e00 	.word	0x43414e00

004033c8 <can_enable>:

void can_enable(Can *can)
{
  4033c8:	b580      	push	{r7, lr}
  4033ca:	b082      	sub	sp, #8
  4033cc:	af00      	add	r7, sp, #0
  4033ce:	6078      	str	r0, [r7, #4]
	can_writeProtectionDisable(can);	
  4033d0:	6878      	ldr	r0, [r7, #4]
  4033d2:	4b07      	ldr	r3, [pc, #28]	; (4033f0 <can_enable+0x28>)
  4033d4:	4798      	blx	r3
	can->CAN_MR |= CAN_MR_CANEN;
  4033d6:	687b      	ldr	r3, [r7, #4]
  4033d8:	681b      	ldr	r3, [r3, #0]
  4033da:	f043 0201 	orr.w	r2, r3, #1
  4033de:	687b      	ldr	r3, [r7, #4]
  4033e0:	601a      	str	r2, [r3, #0]
	can_writeProtectionEnable(can);
  4033e2:	6878      	ldr	r0, [r7, #4]
  4033e4:	4b03      	ldr	r3, [pc, #12]	; (4033f4 <can_enable+0x2c>)
  4033e6:	4798      	blx	r3
}
  4033e8:	3708      	adds	r7, #8
  4033ea:	46bd      	mov	sp, r7
  4033ec:	bd80      	pop	{r7, pc}
  4033ee:	bf00      	nop
  4033f0:	004033a9 	.word	0x004033a9
  4033f4:	00403389 	.word	0x00403389

004033f8 <can_disable>:

void can_disable(Can *can)
{
  4033f8:	b580      	push	{r7, lr}
  4033fa:	b082      	sub	sp, #8
  4033fc:	af00      	add	r7, sp, #0
  4033fe:	6078      	str	r0, [r7, #4]
	can_writeProtectionEnable(can);
  403400:	6878      	ldr	r0, [r7, #4]
  403402:	4b07      	ldr	r3, [pc, #28]	; (403420 <can_disable+0x28>)
  403404:	4798      	blx	r3
	can->CAN_MR &= ~CAN_MR_CANEN;
  403406:	687b      	ldr	r3, [r7, #4]
  403408:	681b      	ldr	r3, [r3, #0]
  40340a:	f023 0201 	bic.w	r2, r3, #1
  40340e:	687b      	ldr	r3, [r7, #4]
  403410:	601a      	str	r2, [r3, #0]
	can_writeProtectionDisable(can);
  403412:	6878      	ldr	r0, [r7, #4]
  403414:	4b03      	ldr	r3, [pc, #12]	; (403424 <can_disable+0x2c>)
  403416:	4798      	blx	r3
}
  403418:	3708      	adds	r7, #8
  40341a:	46bd      	mov	sp, r7
  40341c:	bd80      	pop	{r7, pc}
  40341e:	bf00      	nop
  403420:	00403389 	.word	0x00403389
  403424:	004033a9 	.word	0x004033a9

00403428 <can_setBaudrate>:



//ASF-stuff
static uint32_t can_setBaudrate(Can *can, uint32_t mck, uint32_t baudrate)
{
  403428:	b580      	push	{r7, lr}
  40342a:	b08a      	sub	sp, #40	; 0x28
  40342c:	af00      	add	r7, sp, #0
  40342e:	60f8      	str	r0, [r7, #12]
  403430:	60b9      	str	r1, [r7, #8]
  403432:	607a      	str	r2, [r7, #4]
	can_writeProtectionDisable(can);
  403434:	68f8      	ldr	r0, [r7, #12]
  403436:	4b51      	ldr	r3, [pc, #324]	; (40357c <can_setBaudrate+0x154>)
  403438:	4798      	blx	r3
	uint32_t cur_mod;
	can_bit_timing_t *bitTime;

	/* Check whether the baudrate prescale will be greater than the max
	 * divide value. */
	if (((mck + (baudrate * CAN_MAX_TQ_NUM * 1000 - 1)) /
  40343a:	687b      	ldr	r3, [r7, #4]
  40343c:	f246 12a8 	movw	r2, #25000	; 0x61a8
  403440:	fb02 f203 	mul.w	r2, r2, r3
  403444:	68bb      	ldr	r3, [r7, #8]
  403446:	4413      	add	r3, r2
  403448:	1e5a      	subs	r2, r3, #1
			(baudrate * CAN_MAX_TQ_NUM * 1000)) >
  40344a:	687b      	ldr	r3, [r7, #4]
  40344c:	f246 11a8 	movw	r1, #25000	; 0x61a8
  403450:	fb01 f303 	mul.w	r3, r1, r3
	uint32_t cur_mod;
	can_bit_timing_t *bitTime;

	/* Check whether the baudrate prescale will be greater than the max
	 * divide value. */
	if (((mck + (baudrate * CAN_MAX_TQ_NUM * 1000 - 1)) /
  403454:	fbb2 f3f3 	udiv	r3, r2, r3
  403458:	2b80      	cmp	r3, #128	; 0x80
  40345a:	d901      	bls.n	403460 <can_setBaudrate+0x38>
			(baudrate * CAN_MAX_TQ_NUM * 1000)) >
			CAN_BAUDRATE_MAX_DIV) {
		return 0;
  40345c:	2300      	movs	r3, #0
  40345e:	e088      	b.n	403572 <can_setBaudrate+0x14a>
	}

	/* Check whether the input MCK is too small. */
	if ((mck / 2)  < baudrate * CAN_MIN_TQ_NUM * 1000) {
  403460:	68bb      	ldr	r3, [r7, #8]
  403462:	085a      	lsrs	r2, r3, #1
  403464:	687b      	ldr	r3, [r7, #4]
  403466:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
  40346a:	fb01 f303 	mul.w	r3, r1, r3
  40346e:	429a      	cmp	r2, r3
  403470:	d201      	bcs.n	403476 <can_setBaudrate+0x4e>
		return 0;
  403472:	2300      	movs	r3, #0
  403474:	e07d      	b.n	403572 <can_setBaudrate+0x14a>
	}

	/* Initialize it as the minimum Time Quantum. */
	tq = CAN_MIN_TQ_NUM;
  403476:	2308      	movs	r3, #8
  403478:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

	/* Initialize the remainder as the max value. When the remainder is 0,
	 *get the right TQ number. */
	mod = 0xffffffff;
  40347c:	f04f 33ff 	mov.w	r3, #4294967295
  403480:	623b      	str	r3, [r7, #32]
	/* Find out the approximate Time Quantum according to the baudrate. */
	for (uint8_t i = CAN_MIN_TQ_NUM; i <= CAN_MAX_TQ_NUM; i++) {
  403482:	2308      	movs	r3, #8
  403484:	77fb      	strb	r3, [r7, #31]
  403486:	e02b      	b.n	4034e0 <can_setBaudrate+0xb8>
		if ((mck / (baudrate * i * 1000)) <=
  403488:	7ffb      	ldrb	r3, [r7, #31]
  40348a:	687a      	ldr	r2, [r7, #4]
  40348c:	fb02 f303 	mul.w	r3, r2, r3
  403490:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  403494:	fb02 f303 	mul.w	r3, r2, r3
  403498:	68ba      	ldr	r2, [r7, #8]
  40349a:	fbb2 f3f3 	udiv	r3, r2, r3
  40349e:	2b80      	cmp	r3, #128	; 0x80
  4034a0:	d81b      	bhi.n	4034da <can_setBaudrate+0xb2>
				CAN_BAUDRATE_MAX_DIV) {
			cur_mod = mck % (baudrate * i * 1000);
  4034a2:	7ffb      	ldrb	r3, [r7, #31]
  4034a4:	687a      	ldr	r2, [r7, #4]
  4034a6:	fb02 f303 	mul.w	r3, r2, r3
  4034aa:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  4034ae:	fb02 f203 	mul.w	r2, r2, r3
  4034b2:	68bb      	ldr	r3, [r7, #8]
  4034b4:	fbb3 f1f2 	udiv	r1, r3, r2
  4034b8:	fb02 f201 	mul.w	r2, r2, r1
  4034bc:	1a9b      	subs	r3, r3, r2
  4034be:	61bb      	str	r3, [r7, #24]
			if (cur_mod < mod) {
  4034c0:	69ba      	ldr	r2, [r7, #24]
  4034c2:	6a3b      	ldr	r3, [r7, #32]
  4034c4:	429a      	cmp	r2, r3
  4034c6:	d208      	bcs.n	4034da <can_setBaudrate+0xb2>
				mod = cur_mod;
  4034c8:	69bb      	ldr	r3, [r7, #24]
  4034ca:	623b      	str	r3, [r7, #32]
				tq = i;
  4034cc:	7ffb      	ldrb	r3, [r7, #31]
  4034ce:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
				if (!mod) {
  4034d2:	6a3b      	ldr	r3, [r7, #32]
  4034d4:	2b00      	cmp	r3, #0
  4034d6:	d100      	bne.n	4034da <can_setBaudrate+0xb2>
					break;
  4034d8:	e005      	b.n	4034e6 <can_setBaudrate+0xbe>

	/* Initialize the remainder as the max value. When the remainder is 0,
	 *get the right TQ number. */
	mod = 0xffffffff;
	/* Find out the approximate Time Quantum according to the baudrate. */
	for (uint8_t i = CAN_MIN_TQ_NUM; i <= CAN_MAX_TQ_NUM; i++) {
  4034da:	7ffb      	ldrb	r3, [r7, #31]
  4034dc:	3301      	adds	r3, #1
  4034de:	77fb      	strb	r3, [r7, #31]
  4034e0:	7ffb      	ldrb	r3, [r7, #31]
  4034e2:	2b19      	cmp	r3, #25
  4034e4:	d9d0      	bls.n	403488 <can_setBaudrate+0x60>
			}
		}
	}

	/* Calculate the baudrate prescale value. */
	prescale = mck / (baudrate * tq * 1000);
  4034e6:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  4034ea:	687a      	ldr	r2, [r7, #4]
  4034ec:	fb02 f303 	mul.w	r3, r2, r3
  4034f0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  4034f4:	fb02 f303 	mul.w	r3, r2, r3
  4034f8:	68ba      	ldr	r2, [r7, #8]
  4034fa:	fbb2 f3f3 	udiv	r3, r2, r3
  4034fe:	75fb      	strb	r3, [r7, #23]
	if (prescale < 2) {
  403500:	7dfb      	ldrb	r3, [r7, #23]
  403502:	2b01      	cmp	r3, #1
  403504:	d801      	bhi.n	40350a <can_setBaudrate+0xe2>
		return 0;
  403506:	2300      	movs	r3, #0
  403508:	e033      	b.n	403572 <can_setBaudrate+0x14a>
	}

	/* Get the right CAN BIT Timing group. */
	bitTime = (can_bit_timing_t *)&can_bit_time[tq - CAN_MIN_TQ_NUM];
  40350a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  40350e:	f1a3 0208 	sub.w	r2, r3, #8
  403512:	4613      	mov	r3, r2
  403514:	005b      	lsls	r3, r3, #1
  403516:	4413      	add	r3, r2
  403518:	005b      	lsls	r3, r3, #1
  40351a:	4a19      	ldr	r2, [pc, #100]	; (403580 <can_setBaudrate+0x158>)
  40351c:	4413      	add	r3, r2
  40351e:	613b      	str	r3, [r7, #16]

	/* Before modifying the CANBR register, disable the CAN controller. */
	can_disable(can);
  403520:	68f8      	ldr	r0, [r7, #12]
  403522:	4b18      	ldr	r3, [pc, #96]	; (403584 <can_setBaudrate+0x15c>)
  403524:	4798      	blx	r3

	/* Write into the CAN baudrate register. */
	can->CAN_BR = CAN_BR_PHASE2(bitTime->phase2 - 1) |
  403526:	693b      	ldr	r3, [r7, #16]
  403528:	78db      	ldrb	r3, [r3, #3]
  40352a:	3b01      	subs	r3, #1
  40352c:	f003 0207 	and.w	r2, r3, #7
			CAN_BR_PHASE1(bitTime->phase1 - 1) |
  403530:	693b      	ldr	r3, [r7, #16]
  403532:	789b      	ldrb	r3, [r3, #2]
  403534:	3b01      	subs	r3, #1
  403536:	011b      	lsls	r3, r3, #4
  403538:	f003 0370 	and.w	r3, r3, #112	; 0x70

	/* Before modifying the CANBR register, disable the CAN controller. */
	can_disable(can);

	/* Write into the CAN baudrate register. */
	can->CAN_BR = CAN_BR_PHASE2(bitTime->phase2 - 1) |
  40353c:	431a      	orrs	r2, r3
			CAN_BR_PHASE1(bitTime->phase1 - 1) |
			CAN_BR_PROPAG(bitTime->prog - 1) |
  40353e:	693b      	ldr	r3, [r7, #16]
  403540:	785b      	ldrb	r3, [r3, #1]
  403542:	3b01      	subs	r3, #1
  403544:	021b      	lsls	r3, r3, #8
  403546:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
	/* Before modifying the CANBR register, disable the CAN controller. */
	can_disable(can);

	/* Write into the CAN baudrate register. */
	can->CAN_BR = CAN_BR_PHASE2(bitTime->phase2 - 1) |
			CAN_BR_PHASE1(bitTime->phase1 - 1) |
  40354a:	431a      	orrs	r2, r3
			CAN_BR_PROPAG(bitTime->prog - 1) |
			CAN_BR_SJW(bitTime->sjw - 1) |
  40354c:	693b      	ldr	r3, [r7, #16]
  40354e:	791b      	ldrb	r3, [r3, #4]
  403550:	3b01      	subs	r3, #1
  403552:	031b      	lsls	r3, r3, #12
  403554:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
	can_disable(can);

	/* Write into the CAN baudrate register. */
	can->CAN_BR = CAN_BR_PHASE2(bitTime->phase2 - 1) |
			CAN_BR_PHASE1(bitTime->phase1 - 1) |
			CAN_BR_PROPAG(bitTime->prog - 1) |
  403558:	431a      	orrs	r2, r3
			CAN_BR_SJW(bitTime->sjw - 1) |
			CAN_BR_BRP(prescale - 1);
  40355a:	7dfb      	ldrb	r3, [r7, #23]
  40355c:	3b01      	subs	r3, #1
  40355e:	041b      	lsls	r3, r3, #16
  403560:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000

	/* Write into the CAN baudrate register. */
	can->CAN_BR = CAN_BR_PHASE2(bitTime->phase2 - 1) |
			CAN_BR_PHASE1(bitTime->phase1 - 1) |
			CAN_BR_PROPAG(bitTime->prog - 1) |
			CAN_BR_SJW(bitTime->sjw - 1) |
  403564:	431a      	orrs	r2, r3

	/* Before modifying the CANBR register, disable the CAN controller. */
	can_disable(can);

	/* Write into the CAN baudrate register. */
	can->CAN_BR = CAN_BR_PHASE2(bitTime->phase2 - 1) |
  403566:	68fb      	ldr	r3, [r7, #12]
  403568:	615a      	str	r2, [r3, #20]
			CAN_BR_PHASE1(bitTime->phase1 - 1) |
			CAN_BR_PROPAG(bitTime->prog - 1) |
			CAN_BR_SJW(bitTime->sjw - 1) |
			CAN_BR_BRP(prescale - 1);
	can_writeProtectionEnable(can);
  40356a:	68f8      	ldr	r0, [r7, #12]
  40356c:	4b06      	ldr	r3, [pc, #24]	; (403588 <can_setBaudrate+0x160>)
  40356e:	4798      	blx	r3
	return 1;
  403570:	2301      	movs	r3, #1
}
  403572:	4618      	mov	r0, r3
  403574:	3728      	adds	r7, #40	; 0x28
  403576:	46bd      	mov	sp, r7
  403578:	bd80      	pop	{r7, pc}
  40357a:	bf00      	nop
  40357c:	004033a9 	.word	0x004033a9
  403580:	004046b8 	.word	0x004046b8
  403584:	004033f9 	.word	0x004033f9
  403588:	00403389 	.word	0x00403389

0040358c <can_setPeripheralMux>:


void can_setPeripheralMux(Can *can){
  40358c:	b580      	push	{r7, lr}
  40358e:	b082      	sub	sp, #8
  403590:	af00      	add	r7, sp, #0
  403592:	6078      	str	r0, [r7, #4]
	if(can == CAN0){
  403594:	687a      	ldr	r2, [r7, #4]
  403596:	4b0f      	ldr	r3, [pc, #60]	; (4035d4 <can_setPeripheralMux+0x48>)
  403598:	429a      	cmp	r2, r3
  40359a:	d10a      	bne.n	4035b2 <can_setPeripheralMux+0x26>
		pio_setMux(PIOB, 3, A);
  40359c:	480e      	ldr	r0, [pc, #56]	; (4035d8 <can_setPeripheralMux+0x4c>)
  40359e:	2103      	movs	r1, #3
  4035a0:	2201      	movs	r2, #1
  4035a2:	4b0e      	ldr	r3, [pc, #56]	; (4035dc <can_setPeripheralMux+0x50>)
  4035a4:	4798      	blx	r3
		pio_setMux(PIOB, 2, A);
  4035a6:	480c      	ldr	r0, [pc, #48]	; (4035d8 <can_setPeripheralMux+0x4c>)
  4035a8:	2102      	movs	r1, #2
  4035aa:	2201      	movs	r2, #1
  4035ac:	4b0b      	ldr	r3, [pc, #44]	; (4035dc <can_setPeripheralMux+0x50>)
  4035ae:	4798      	blx	r3
  4035b0:	e00d      	b.n	4035ce <can_setPeripheralMux+0x42>
	}
	else if(can == CAN1){
  4035b2:	687a      	ldr	r2, [r7, #4]
  4035b4:	4b0a      	ldr	r3, [pc, #40]	; (4035e0 <can_setPeripheralMux+0x54>)
  4035b6:	429a      	cmp	r2, r3
  4035b8:	d109      	bne.n	4035ce <can_setPeripheralMux+0x42>
		pio_setMux(PIOC, 12, C);
  4035ba:	480a      	ldr	r0, [pc, #40]	; (4035e4 <can_setPeripheralMux+0x58>)
  4035bc:	210c      	movs	r1, #12
  4035be:	2203      	movs	r2, #3
  4035c0:	4b06      	ldr	r3, [pc, #24]	; (4035dc <can_setPeripheralMux+0x50>)
  4035c2:	4798      	blx	r3
		pio_setMux(PIOC, 15, C);
  4035c4:	4807      	ldr	r0, [pc, #28]	; (4035e4 <can_setPeripheralMux+0x58>)
  4035c6:	210f      	movs	r1, #15
  4035c8:	2203      	movs	r2, #3
  4035ca:	4b04      	ldr	r3, [pc, #16]	; (4035dc <can_setPeripheralMux+0x50>)
  4035cc:	4798      	blx	r3
	}
}
  4035ce:	3708      	adds	r7, #8
  4035d0:	46bd      	mov	sp, r7
  4035d2:	bd80      	pop	{r7, pc}
  4035d4:	40010000 	.word	0x40010000
  4035d8:	400e1000 	.word	0x400e1000
  4035dc:	00403961 	.word	0x00403961
  4035e0:	40014000 	.word	0x40014000
  4035e4:	400e1200 	.word	0x400e1200

004035e8 <can_enablePMC>:

void can_enablePMC(Can *can){
  4035e8:	b580      	push	{r7, lr}
  4035ea:	b082      	sub	sp, #8
  4035ec:	af00      	add	r7, sp, #0
  4035ee:	6078      	str	r0, [r7, #4]
	can_writeProtectionDisable(can);
  4035f0:	6878      	ldr	r0, [r7, #4]
  4035f2:	4b0b      	ldr	r3, [pc, #44]	; (403620 <can_enablePMC+0x38>)
  4035f4:	4798      	blx	r3
	if(can == CAN0){
  4035f6:	687a      	ldr	r2, [r7, #4]
  4035f8:	4b0a      	ldr	r3, [pc, #40]	; (403624 <can_enablePMC+0x3c>)
  4035fa:	429a      	cmp	r2, r3
  4035fc:	d103      	bne.n	403606 <can_enablePMC+0x1e>
		pmc_enable_periph_clk(37);
  4035fe:	2025      	movs	r0, #37	; 0x25
  403600:	4b09      	ldr	r3, [pc, #36]	; (403628 <can_enablePMC+0x40>)
  403602:	4798      	blx	r3
  403604:	e006      	b.n	403614 <can_enablePMC+0x2c>
		//PMC->PMC_PCER1 |= 1<<5;			//ENABLE CLOCK, PID = 37
	}
	else if(can == CAN1){
  403606:	687a      	ldr	r2, [r7, #4]
  403608:	4b08      	ldr	r3, [pc, #32]	; (40362c <can_enablePMC+0x44>)
  40360a:	429a      	cmp	r2, r3
  40360c:	d102      	bne.n	403614 <can_enablePMC+0x2c>
		pmc_enable_periph_clk(38);
  40360e:	2026      	movs	r0, #38	; 0x26
  403610:	4b05      	ldr	r3, [pc, #20]	; (403628 <can_enablePMC+0x40>)
  403612:	4798      	blx	r3
		//PMC->PMC_PCER1 |= 1<<6;			//ENABLE CLOCK, PID = 38
	}
	can_writeProtectionEnable(can);
  403614:	6878      	ldr	r0, [r7, #4]
  403616:	4b06      	ldr	r3, [pc, #24]	; (403630 <can_enablePMC+0x48>)
  403618:	4798      	blx	r3
}
  40361a:	3708      	adds	r7, #8
  40361c:	46bd      	mov	sp, r7
  40361e:	bd80      	pop	{r7, pc}
  403620:	004033a9 	.word	0x004033a9
  403624:	40010000 	.word	0x40010000
  403628:	00404035 	.word	0x00404035
  40362c:	40014000 	.word	0x40014000
  403630:	00403389 	.word	0x00403389

00403634 <can_setupTXMailbox>:

void can_setupTXMailbox(Can *can, uint8_t mailbox_id, uint8_t priority){
  403634:	b580      	push	{r7, lr}
  403636:	b082      	sub	sp, #8
  403638:	af00      	add	r7, sp, #0
  40363a:	6078      	str	r0, [r7, #4]
  40363c:	4613      	mov	r3, r2
  40363e:	460a      	mov	r2, r1
  403640:	70fa      	strb	r2, [r7, #3]
  403642:	70bb      	strb	r3, [r7, #2]
	can_writeProtectionDisable(can);
  403644:	6878      	ldr	r0, [r7, #4]
  403646:	4b14      	ldr	r3, [pc, #80]	; (403698 <can_setupTXMailbox+0x64>)
  403648:	4798      	blx	r3
	/* Set the priority in Transmit mode. */
	can->CAN_MB[mailbox_id].CAN_MMR = 
  40364a:	78fb      	ldrb	r3, [r7, #3]
		(can->CAN_MB[mailbox_id].CAN_MMR & ~CAN_MMR_PRIOR_Msk) |
  40364c:	78fa      	ldrb	r2, [r7, #3]
  40364e:	6879      	ldr	r1, [r7, #4]
  403650:	3210      	adds	r2, #16
  403652:	0152      	lsls	r2, r2, #5
  403654:	440a      	add	r2, r1
  403656:	6812      	ldr	r2, [r2, #0]
  403658:	f422 2170 	bic.w	r1, r2, #983040	; 0xf0000
		(priority << CAN_MMR_PRIOR_Pos);
  40365c:	78ba      	ldrb	r2, [r7, #2]
  40365e:	0412      	lsls	r2, r2, #16

void can_setupTXMailbox(Can *can, uint8_t mailbox_id, uint8_t priority){
	can_writeProtectionDisable(can);
	/* Set the priority in Transmit mode. */
	can->CAN_MB[mailbox_id].CAN_MMR = 
		(can->CAN_MB[mailbox_id].CAN_MMR & ~CAN_MMR_PRIOR_Msk) |
  403660:	430a      	orrs	r2, r1
}

void can_setupTXMailbox(Can *can, uint8_t mailbox_id, uint8_t priority){
	can_writeProtectionDisable(can);
	/* Set the priority in Transmit mode. */
	can->CAN_MB[mailbox_id].CAN_MMR = 
  403662:	6879      	ldr	r1, [r7, #4]
  403664:	3310      	adds	r3, #16
  403666:	015b      	lsls	r3, r3, #5
  403668:	440b      	add	r3, r1
  40366a:	601a      	str	r2, [r3, #0]
		(can->CAN_MB[mailbox_id].CAN_MMR & ~CAN_MMR_PRIOR_Msk) |
		(priority << CAN_MMR_PRIOR_Pos);
	
	/* Set box into TX mode*/
	can->CAN_MB[mailbox_id].CAN_MMR = 
  40366c:	78fb      	ldrb	r3, [r7, #3]
		(can->CAN_MB[mailbox_id].CAN_MMR & ~CAN_MMR_MOT_Msk) |
  40366e:	78fa      	ldrb	r2, [r7, #3]
  403670:	6879      	ldr	r1, [r7, #4]
  403672:	3210      	adds	r2, #16
  403674:	0152      	lsls	r2, r2, #5
  403676:	440a      	add	r2, r1
  403678:	6812      	ldr	r2, [r2, #0]
  40367a:	f022 62e0 	bic.w	r2, r2, #117440512	; 0x7000000
  40367e:	f042 7240 	orr.w	r2, r2, #50331648	; 0x3000000
	can->CAN_MB[mailbox_id].CAN_MMR = 
		(can->CAN_MB[mailbox_id].CAN_MMR & ~CAN_MMR_PRIOR_Msk) |
		(priority << CAN_MMR_PRIOR_Pos);
	
	/* Set box into TX mode*/
	can->CAN_MB[mailbox_id].CAN_MMR = 
  403682:	6879      	ldr	r1, [r7, #4]
  403684:	3310      	adds	r3, #16
  403686:	015b      	lsls	r3, r3, #5
  403688:	440b      	add	r3, r1
  40368a:	601a      	str	r2, [r3, #0]
		(can->CAN_MB[mailbox_id].CAN_MMR & ~CAN_MMR_MOT_Msk) |
		(CAN_MB_TX_MODE << CAN_MMR_MOT_Pos);
	can_writeProtectionEnable(can);
  40368c:	6878      	ldr	r0, [r7, #4]
  40368e:	4b03      	ldr	r3, [pc, #12]	; (40369c <can_setupTXMailbox+0x68>)
  403690:	4798      	blx	r3
}
  403692:	3708      	adds	r7, #8
  403694:	46bd      	mov	sp, r7
  403696:	bd80      	pop	{r7, pc}
  403698:	004033a9 	.word	0x004033a9
  40369c:	00403389 	.word	0x00403389

004036a0 <can_disableMailbox>:
		(can->CAN_MB[mailbox_id].CAN_MMR & ~CAN_MMR_MOT_Msk) |
		(CAN_MB_RX_MODE << CAN_MMR_MOT_Pos);
	can_writeProtectionEnable(can);
}

void can_disableMailbox(Can *can, uint8_t mailbox_id){
  4036a0:	b580      	push	{r7, lr}
  4036a2:	b082      	sub	sp, #8
  4036a4:	af00      	add	r7, sp, #0
  4036a6:	6078      	str	r0, [r7, #4]
  4036a8:	460b      	mov	r3, r1
  4036aa:	70fb      	strb	r3, [r7, #3]
	can_writeProtectionDisable(can);
  4036ac:	6878      	ldr	r0, [r7, #4]
  4036ae:	4b1b      	ldr	r3, [pc, #108]	; (40371c <can_disableMailbox+0x7c>)
  4036b0:	4798      	blx	r3
	can->CAN_MB[mailbox_id].CAN_MMR = 0;
  4036b2:	78fb      	ldrb	r3, [r7, #3]
  4036b4:	687a      	ldr	r2, [r7, #4]
  4036b6:	3310      	adds	r3, #16
  4036b8:	015b      	lsls	r3, r3, #5
  4036ba:	4413      	add	r3, r2
  4036bc:	2200      	movs	r2, #0
  4036be:	601a      	str	r2, [r3, #0]
	can->CAN_MB[mailbox_id].CAN_MAM = 0;
  4036c0:	78fb      	ldrb	r3, [r7, #3]
  4036c2:	687a      	ldr	r2, [r7, #4]
  4036c4:	3310      	adds	r3, #16
  4036c6:	015b      	lsls	r3, r3, #5
  4036c8:	4413      	add	r3, r2
  4036ca:	2200      	movs	r2, #0
  4036cc:	605a      	str	r2, [r3, #4]
	can->CAN_MB[mailbox_id].CAN_MID = 0;
  4036ce:	78fb      	ldrb	r3, [r7, #3]
  4036d0:	687a      	ldr	r2, [r7, #4]
  4036d2:	015b      	lsls	r3, r3, #5
  4036d4:	4413      	add	r3, r2
  4036d6:	f503 7302 	add.w	r3, r3, #520	; 0x208
  4036da:	2200      	movs	r2, #0
  4036dc:	601a      	str	r2, [r3, #0]
	can->CAN_MB[mailbox_id].CAN_MDL = 0;
  4036de:	78fb      	ldrb	r3, [r7, #3]
  4036e0:	687a      	ldr	r2, [r7, #4]
  4036e2:	015b      	lsls	r3, r3, #5
  4036e4:	4413      	add	r3, r2
  4036e6:	f503 7304 	add.w	r3, r3, #528	; 0x210
  4036ea:	2200      	movs	r2, #0
  4036ec:	605a      	str	r2, [r3, #4]
	can->CAN_MB[mailbox_id].CAN_MDH = 0;
  4036ee:	78fb      	ldrb	r3, [r7, #3]
  4036f0:	687a      	ldr	r2, [r7, #4]
  4036f2:	015b      	lsls	r3, r3, #5
  4036f4:	4413      	add	r3, r2
  4036f6:	f503 7306 	add.w	r3, r3, #536	; 0x218
  4036fa:	2200      	movs	r2, #0
  4036fc:	601a      	str	r2, [r3, #0]
	can->CAN_MB[mailbox_id].CAN_MCR = 0;
  4036fe:	78fb      	ldrb	r3, [r7, #3]
  403700:	687a      	ldr	r2, [r7, #4]
  403702:	015b      	lsls	r3, r3, #5
  403704:	4413      	add	r3, r2
  403706:	f503 7306 	add.w	r3, r3, #536	; 0x218
  40370a:	2200      	movs	r2, #0
  40370c:	605a      	str	r2, [r3, #4]
	can_writeProtectionEnable(can);
  40370e:	6878      	ldr	r0, [r7, #4]
  403710:	4b03      	ldr	r3, [pc, #12]	; (403720 <can_disableMailbox+0x80>)
  403712:	4798      	blx	r3
}
  403714:	3708      	adds	r7, #8
  403716:	46bd      	mov	sp, r7
  403718:	bd80      	pop	{r7, pc}
  40371a:	bf00      	nop
  40371c:	004033a9 	.word	0x004033a9
  403720:	00403389 	.word	0x00403389

00403724 <can_init>:

void can_init(Can *can, uint32_t peripheral_clock_hz, uint32_t baudrate_kbps){
  403724:	b580      	push	{r7, lr}
  403726:	b086      	sub	sp, #24
  403728:	af00      	add	r7, sp, #0
  40372a:	60f8      	str	r0, [r7, #12]
  40372c:	60b9      	str	r1, [r7, #8]
  40372e:	607a      	str	r2, [r7, #4]
	can_writeProtectionDisable(can);
  403730:	68f8      	ldr	r0, [r7, #12]
  403732:	4b1c      	ldr	r3, [pc, #112]	; (4037a4 <can_init+0x80>)
  403734:	4798      	blx	r3
	can_disable(can);
  403736:	68f8      	ldr	r0, [r7, #12]
  403738:	4b1b      	ldr	r3, [pc, #108]	; (4037a8 <can_init+0x84>)
  40373a:	4798      	blx	r3
	can_setPeripheralMux(can);
  40373c:	68f8      	ldr	r0, [r7, #12]
  40373e:	4b1b      	ldr	r3, [pc, #108]	; (4037ac <can_init+0x88>)
  403740:	4798      	blx	r3
	can_enablePMC(can);
  403742:	68f8      	ldr	r0, [r7, #12]
  403744:	4b1a      	ldr	r3, [pc, #104]	; (4037b0 <can_init+0x8c>)
  403746:	4798      	blx	r3
	if(!can_setBaudrate(can, peripheral_clock_hz, baudrate_kbps)){
  403748:	68f8      	ldr	r0, [r7, #12]
  40374a:	68b9      	ldr	r1, [r7, #8]
  40374c:	687a      	ldr	r2, [r7, #4]
  40374e:	4b19      	ldr	r3, [pc, #100]	; (4037b4 <can_init+0x90>)
  403750:	4798      	blx	r3
  403752:	4603      	mov	r3, r0
  403754:	2b00      	cmp	r3, #0
  403756:	d100      	bne.n	40375a <can_init+0x36>
		return; //Illegal combination of peripheral_clock_hz and baudrate_kbps
  403758:	e020      	b.n	40379c <can_init+0x78>
	}
	
	//Reset 8 all mailboxes
	for (int i = 0; i<8; i++)
  40375a:	2300      	movs	r3, #0
  40375c:	617b      	str	r3, [r7, #20]
  40375e:	e008      	b.n	403772 <can_init+0x4e>
	{
		can_disableMailbox(can, i);
  403760:	697b      	ldr	r3, [r7, #20]
  403762:	b2db      	uxtb	r3, r3
  403764:	68f8      	ldr	r0, [r7, #12]
  403766:	4619      	mov	r1, r3
  403768:	4b13      	ldr	r3, [pc, #76]	; (4037b8 <can_init+0x94>)
  40376a:	4798      	blx	r3
	if(!can_setBaudrate(can, peripheral_clock_hz, baudrate_kbps)){
		return; //Illegal combination of peripheral_clock_hz and baudrate_kbps
	}
	
	//Reset 8 all mailboxes
	for (int i = 0; i<8; i++)
  40376c:	697b      	ldr	r3, [r7, #20]
  40376e:	3301      	adds	r3, #1
  403770:	617b      	str	r3, [r7, #20]
  403772:	697b      	ldr	r3, [r7, #20]
  403774:	2b07      	cmp	r3, #7
  403776:	ddf3      	ble.n	403760 <can_init+0x3c>
	{
		can_disableMailbox(can, i);
	}
	can_enable(can);
  403778:	68f8      	ldr	r0, [r7, #12]
  40377a:	4b10      	ldr	r3, [pc, #64]	; (4037bc <can_init+0x98>)
  40377c:	4798      	blx	r3
	/* Wait until the CAN is synchronized with the bus activity. */
	while(!(can->CAN_SR & CAN_SR_WAKEUP));
  40377e:	bf00      	nop
  403780:	68fb      	ldr	r3, [r7, #12]
  403782:	691b      	ldr	r3, [r3, #16]
  403784:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
  403788:	2b00      	cmp	r3, #0
  40378a:	d0f9      	beq.n	403780 <can_init+0x5c>
	
	//init TX mailbox:
	can_setupTXMailbox(can, TX_BOX_ID, 0);
  40378c:	68f8      	ldr	r0, [r7, #12]
  40378e:	2100      	movs	r1, #0
  403790:	2200      	movs	r2, #0
  403792:	4b0b      	ldr	r3, [pc, #44]	; (4037c0 <can_init+0x9c>)
  403794:	4798      	blx	r3
	can_writeProtectionEnable(can);
  403796:	68f8      	ldr	r0, [r7, #12]
  403798:	4b0a      	ldr	r3, [pc, #40]	; (4037c4 <can_init+0xa0>)
  40379a:	4798      	blx	r3
}
  40379c:	3718      	adds	r7, #24
  40379e:	46bd      	mov	sp, r7
  4037a0:	bd80      	pop	{r7, pc}
  4037a2:	bf00      	nop
  4037a4:	004033a9 	.word	0x004033a9
  4037a8:	004033f9 	.word	0x004033f9
  4037ac:	0040358d 	.word	0x0040358d
  4037b0:	004035e9 	.word	0x004035e9
  4037b4:	00403429 	.word	0x00403429
  4037b8:	004036a1 	.word	0x004036a1
  4037bc:	004033c9 	.word	0x004033c9
  4037c0:	00403635 	.word	0x00403635
  4037c4:	00403389 	.word	0x00403389

004037c8 <can_sendMessage>:
	}
	can_enableRXInterrupt(can);
	can_writeProtectionEnable(can);
}

enum CanTXstatus can_sendMessage(Can *can, struct CanMessage message){
  4037c8:	b082      	sub	sp, #8
  4037ca:	b580      	push	{r7, lr}
  4037cc:	b082      	sub	sp, #8
  4037ce:	af00      	add	r7, sp, #0
  4037d0:	6078      	str	r0, [r7, #4]
  4037d2:	f107 0110 	add.w	r1, r7, #16
  4037d6:	e881 000c 	stmia.w	r1, {r2, r3}
	//check if mailbox is ready
	if ( !(can->CAN_MB[TX_BOX_ID].CAN_MSR & CAN_MSR_MRDY) )
  4037da:	687b      	ldr	r3, [r7, #4]
  4037dc:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
  4037e0:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
  4037e4:	2b00      	cmp	r3, #0
  4037e6:	d101      	bne.n	4037ec <can_sendMessage+0x24>
	{
		return TRANSFER_BUSY;
  4037e8:	2301      	movs	r3, #1
  4037ea:	e021      	b.n	403830 <can_sendMessage+0x68>
	}
	can_writeProtectionDisable(can);
  4037ec:	6878      	ldr	r0, [r7, #4]
  4037ee:	4b14      	ldr	r3, [pc, #80]	; (403840 <can_sendMessage+0x78>)
  4037f0:	4798      	blx	r3
	//write message id to mailboxz
	can->CAN_MB[TX_BOX_ID].CAN_MID = CAN_MID_MIDvA(message.messageID);
  4037f2:	69fb      	ldr	r3, [r7, #28]
  4037f4:	049a      	lsls	r2, r3, #18
  4037f6:	4b13      	ldr	r3, [pc, #76]	; (403844 <can_sendMessage+0x7c>)
  4037f8:	4013      	ands	r3, r2
  4037fa:	687a      	ldr	r2, [r7, #4]
  4037fc:	f8c2 3208 	str.w	r3, [r2, #520]	; 0x208
	
	//write data
	can->CAN_MB[TX_BOX_ID].CAN_MDL = message.data.u32[0];
  403800:	693a      	ldr	r2, [r7, #16]
  403802:	687b      	ldr	r3, [r7, #4]
  403804:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
	if (message.dataLength > 4)
  403808:	7e3b      	ldrb	r3, [r7, #24]
  40380a:	2b04      	cmp	r3, #4
  40380c:	d903      	bls.n	403816 <can_sendMessage+0x4e>
	{
		can->CAN_MB[TX_BOX_ID].CAN_MDH = message.data.u32[1];
  40380e:	697a      	ldr	r2, [r7, #20]
  403810:	687b      	ldr	r3, [r7, #4]
  403812:	f8c3 2218 	str.w	r2, [r3, #536]	; 0x218
	}
	
	//write data length and initate transfer
	can->CAN_MB[TX_BOX_ID].CAN_MCR = CAN_MCR_MTCR | CAN_MCR_MDLC(message.dataLength);
  403816:	7e3b      	ldrb	r3, [r7, #24]
  403818:	041b      	lsls	r3, r3, #16
  40381a:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
  40381e:	f443 0200 	orr.w	r2, r3, #8388608	; 0x800000
  403822:	687b      	ldr	r3, [r7, #4]
  403824:	f8c3 221c 	str.w	r2, [r3, #540]	; 0x21c
	can_writeProtectionEnable(can);
  403828:	6878      	ldr	r0, [r7, #4]
  40382a:	4b07      	ldr	r3, [pc, #28]	; (403848 <can_sendMessage+0x80>)
  40382c:	4798      	blx	r3
	return TRANSFER_OK;	
  40382e:	2300      	movs	r3, #0
}
  403830:	4618      	mov	r0, r3
  403832:	3708      	adds	r7, #8
  403834:	46bd      	mov	sp, r7
  403836:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
  40383a:	b002      	add	sp, #8
  40383c:	4770      	bx	lr
  40383e:	bf00      	nop
  403840:	004033a9 	.word	0x004033a9
  403844:	1ffc0000 	.word	0x1ffc0000
  403848:	00403389 	.word	0x00403389

0040384c <init_flash>:
#define MASTER_CLOCK_FREQ 120000000

#include "sam.h"

void init_flash(void)
{	
  40384c:	b480      	push	{r7}
  40384e:	af00      	add	r7, sp, #0
					EFC->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
					} else {
					if ( MASTER_CLOCK_FREQ < CHIP_FREQ_FWS_4 ) {
						EFC->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
						} else {
						EFC->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  403850:	4b03      	ldr	r3, [pc, #12]	; (403860 <init_flash+0x14>)
  403852:	4a04      	ldr	r2, [pc, #16]	; (403864 <init_flash+0x18>)
  403854:	601a      	str	r2, [r3, #0]
					}
				}
			}
		}
	}
  403856:	46bd      	mov	sp, r7
  403858:	f85d 7b04 	ldr.w	r7, [sp], #4
  40385c:	4770      	bx	lr
  40385e:	bf00      	nop
  403860:	400e0a00 	.word	0x400e0a00
  403864:	04000500 	.word	0x04000500

00403868 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  403868:	b480      	push	{r7}
  40386a:	b083      	sub	sp, #12
  40386c:	af00      	add	r7, sp, #0
  40386e:	4603      	mov	r3, r0
  403870:	71fb      	strb	r3, [r7, #7]
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  403872:	4b08      	ldr	r3, [pc, #32]	; (403894 <NVIC_EnableIRQ+0x2c>)
  403874:	f997 2007 	ldrsb.w	r2, [r7, #7]
  403878:	0952      	lsrs	r2, r2, #5
  40387a:	79f9      	ldrb	r1, [r7, #7]
  40387c:	f001 011f 	and.w	r1, r1, #31
  403880:	2001      	movs	r0, #1
  403882:	fa00 f101 	lsl.w	r1, r0, r1
  403886:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
  40388a:	370c      	adds	r7, #12
  40388c:	46bd      	mov	sp, r7
  40388e:	f85d 7b04 	ldr.w	r7, [sp], #4
  403892:	4770      	bx	lr
  403894:	e000e100 	.word	0xe000e100

00403898 <pio_init>:
static void (*piodInterruptHooks[32])();
static void (*pioeInterruptHooks[32])();


void pio_init()
{
  403898:	b580      	push	{r7, lr}
  40389a:	af00      	add	r7, sp, #0
	pmc_enable_periph_clk(PIOA_IRQn);
  40389c:	2009      	movs	r0, #9
  40389e:	4b0f      	ldr	r3, [pc, #60]	; (4038dc <pio_init+0x44>)
  4038a0:	4798      	blx	r3
	pmc_enable_periph_clk(PIOB_IRQn);
  4038a2:	200a      	movs	r0, #10
  4038a4:	4b0d      	ldr	r3, [pc, #52]	; (4038dc <pio_init+0x44>)
  4038a6:	4798      	blx	r3
	pmc_enable_periph_clk(PIOC_IRQn);
  4038a8:	200b      	movs	r0, #11
  4038aa:	4b0c      	ldr	r3, [pc, #48]	; (4038dc <pio_init+0x44>)
  4038ac:	4798      	blx	r3
	pmc_enable_periph_clk(PIOD_IRQn);
  4038ae:	200c      	movs	r0, #12
  4038b0:	4b0a      	ldr	r3, [pc, #40]	; (4038dc <pio_init+0x44>)
  4038b2:	4798      	blx	r3
	pmc_enable_periph_clk(PIOE_IRQn);
  4038b4:	200d      	movs	r0, #13
  4038b6:	4b09      	ldr	r3, [pc, #36]	; (4038dc <pio_init+0x44>)
  4038b8:	4798      	blx	r3
	
	NVIC_EnableIRQ(PIOA_IRQn);
  4038ba:	2009      	movs	r0, #9
  4038bc:	4b08      	ldr	r3, [pc, #32]	; (4038e0 <pio_init+0x48>)
  4038be:	4798      	blx	r3
	NVIC_EnableIRQ(PIOB_IRQn);
  4038c0:	200a      	movs	r0, #10
  4038c2:	4b07      	ldr	r3, [pc, #28]	; (4038e0 <pio_init+0x48>)
  4038c4:	4798      	blx	r3
	NVIC_EnableIRQ(PIOC_IRQn);
  4038c6:	200b      	movs	r0, #11
  4038c8:	4b05      	ldr	r3, [pc, #20]	; (4038e0 <pio_init+0x48>)
  4038ca:	4798      	blx	r3
	NVIC_EnableIRQ(PIOD_IRQn);
  4038cc:	200c      	movs	r0, #12
  4038ce:	4b04      	ldr	r3, [pc, #16]	; (4038e0 <pio_init+0x48>)
  4038d0:	4798      	blx	r3
	NVIC_EnableIRQ(PIOE_IRQn);
  4038d2:	200d      	movs	r0, #13
  4038d4:	4b02      	ldr	r3, [pc, #8]	; (4038e0 <pio_init+0x48>)
  4038d6:	4798      	blx	r3
}
  4038d8:	bd80      	pop	{r7, pc}
  4038da:	bf00      	nop
  4038dc:	00404035 	.word	0x00404035
  4038e0:	00403869 	.word	0x00403869

004038e4 <pio_enableOutput>:


void pio_enableOutput(Pio * pio, uint8_t pin ){
  4038e4:	b580      	push	{r7, lr}
  4038e6:	b082      	sub	sp, #8
  4038e8:	af00      	add	r7, sp, #0
  4038ea:	6078      	str	r0, [r7, #4]
  4038ec:	460b      	mov	r3, r1
  4038ee:	70fb      	strb	r3, [r7, #3]
	
	pio_disableWriteProtection(pio);
  4038f0:	6878      	ldr	r0, [r7, #4]
  4038f2:	4b07      	ldr	r3, [pc, #28]	; (403910 <pio_enableOutput+0x2c>)
  4038f4:	4798      	blx	r3
	pio->PIO_OER = ( 1 << pin );
  4038f6:	78fb      	ldrb	r3, [r7, #3]
  4038f8:	2201      	movs	r2, #1
  4038fa:	fa02 f303 	lsl.w	r3, r2, r3
  4038fe:	461a      	mov	r2, r3
  403900:	687b      	ldr	r3, [r7, #4]
  403902:	611a      	str	r2, [r3, #16]
	pio_enableWriteProtection(pio);
  403904:	6878      	ldr	r0, [r7, #4]
  403906:	4b03      	ldr	r3, [pc, #12]	; (403914 <pio_enableOutput+0x30>)
  403908:	4798      	blx	r3
}
  40390a:	3708      	adds	r7, #8
  40390c:	46bd      	mov	sp, r7
  40390e:	bd80      	pop	{r7, pc}
  403910:	00403ae5 	.word	0x00403ae5
  403914:	00403ac5 	.word	0x00403ac5

00403918 <pio_setOutput>:
	pio_disableWriteProtection(pio);
	pio->PIO_ODR = ( 1 << pin );
	pio_enableWriteProtection(pio);
}

void pio_setOutput(Pio * pio, uint8_t pin, enum PinLevel pinlevel ){
  403918:	b480      	push	{r7}
  40391a:	b083      	sub	sp, #12
  40391c:	af00      	add	r7, sp, #0
  40391e:	6078      	str	r0, [r7, #4]
  403920:	4613      	mov	r3, r2
  403922:	460a      	mov	r2, r1
  403924:	70fa      	strb	r2, [r7, #3]
  403926:	70bb      	strb	r3, [r7, #2]
		
	switch(pinlevel){
  403928:	78bb      	ldrb	r3, [r7, #2]
  40392a:	2b00      	cmp	r3, #0
  40392c:	d002      	beq.n	403934 <pio_setOutput+0x1c>
  40392e:	2b01      	cmp	r3, #1
  403930:	d008      	beq.n	403944 <pio_setOutput+0x2c>
  403932:	e00f      	b.n	403954 <pio_setOutput+0x3c>
		case(LOW):
			pio->PIO_CODR = (1<<pin);
  403934:	78fb      	ldrb	r3, [r7, #3]
  403936:	2201      	movs	r2, #1
  403938:	fa02 f303 	lsl.w	r3, r2, r3
  40393c:	461a      	mov	r2, r3
  40393e:	687b      	ldr	r3, [r7, #4]
  403940:	635a      	str	r2, [r3, #52]	; 0x34
			break;
  403942:	e007      	b.n	403954 <pio_setOutput+0x3c>
		case(HIGH):
			pio->PIO_SODR = (1<<pin);
  403944:	78fb      	ldrb	r3, [r7, #3]
  403946:	2201      	movs	r2, #1
  403948:	fa02 f303 	lsl.w	r3, r2, r3
  40394c:	461a      	mov	r2, r3
  40394e:	687b      	ldr	r3, [r7, #4]
  403950:	631a      	str	r2, [r3, #48]	; 0x30
			break;
  403952:	bf00      	nop
	}
}
  403954:	370c      	adds	r7, #12
  403956:	46bd      	mov	sp, r7
  403958:	f85d 7b04 	ldr.w	r7, [sp], #4
  40395c:	4770      	bx	lr
  40395e:	bf00      	nop

00403960 <pio_setMux>:



void pio_setMux(Pio * pio, uint8_t pin, enum Peripheral mux)
{
  403960:	b580      	push	{r7, lr}
  403962:	b082      	sub	sp, #8
  403964:	af00      	add	r7, sp, #0
  403966:	6078      	str	r0, [r7, #4]
  403968:	4613      	mov	r3, r2
  40396a:	460a      	mov	r2, r1
  40396c:	70fa      	strb	r2, [r7, #3]
  40396e:	70bb      	strb	r3, [r7, #2]
	pio_disableWriteProtection(pio);
  403970:	6878      	ldr	r0, [r7, #4]
  403972:	4b46      	ldr	r3, [pc, #280]	; (403a8c <pio_setMux+0x12c>)
  403974:	4798      	blx	r3
	switch(mux){
  403976:	78bb      	ldrb	r3, [r7, #2]
  403978:	2b04      	cmp	r3, #4
  40397a:	f200 8081 	bhi.w	403a80 <pio_setMux+0x120>
  40397e:	a201      	add	r2, pc, #4	; (adr r2, 403984 <pio_setMux+0x24>)
  403980:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  403984:	00403999 	.word	0x00403999
  403988:	004039a9 	.word	0x004039a9
  40398c:	004039e1 	.word	0x004039e1
  403990:	00403a17 	.word	0x00403a17
  403994:	00403a4d 	.word	0x00403a4d
		case PIO:
			pio->PIO_PER = (1<<pin);
  403998:	78fb      	ldrb	r3, [r7, #3]
  40399a:	2201      	movs	r2, #1
  40399c:	fa02 f303 	lsl.w	r3, r2, r3
  4039a0:	461a      	mov	r2, r3
  4039a2:	687b      	ldr	r3, [r7, #4]
  4039a4:	601a      	str	r2, [r3, #0]
			break; 
  4039a6:	e06b      	b.n	403a80 <pio_setMux+0x120>
		case A:
			pio->PIO_PDR = (1<<pin);
  4039a8:	78fb      	ldrb	r3, [r7, #3]
  4039aa:	2201      	movs	r2, #1
  4039ac:	fa02 f303 	lsl.w	r3, r2, r3
  4039b0:	461a      	mov	r2, r3
  4039b2:	687b      	ldr	r3, [r7, #4]
  4039b4:	605a      	str	r2, [r3, #4]
			pio->PIO_ABCDSR[0] &= ~(1<<pin);
  4039b6:	687b      	ldr	r3, [r7, #4]
  4039b8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  4039ba:	78fb      	ldrb	r3, [r7, #3]
  4039bc:	2101      	movs	r1, #1
  4039be:	fa01 f303 	lsl.w	r3, r1, r3
  4039c2:	43db      	mvns	r3, r3
  4039c4:	401a      	ands	r2, r3
  4039c6:	687b      	ldr	r3, [r7, #4]
  4039c8:	671a      	str	r2, [r3, #112]	; 0x70
			pio->PIO_ABCDSR[1] &= ~(1<<pin);
  4039ca:	687b      	ldr	r3, [r7, #4]
  4039cc:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  4039ce:	78fb      	ldrb	r3, [r7, #3]
  4039d0:	2101      	movs	r1, #1
  4039d2:	fa01 f303 	lsl.w	r3, r1, r3
  4039d6:	43db      	mvns	r3, r3
  4039d8:	401a      	ands	r2, r3
  4039da:	687b      	ldr	r3, [r7, #4]
  4039dc:	675a      	str	r2, [r3, #116]	; 0x74
			break;
  4039de:	e04f      	b.n	403a80 <pio_setMux+0x120>
		case B: 
			pio->PIO_PDR = (1<<pin); 
  4039e0:	78fb      	ldrb	r3, [r7, #3]
  4039e2:	2201      	movs	r2, #1
  4039e4:	fa02 f303 	lsl.w	r3, r2, r3
  4039e8:	461a      	mov	r2, r3
  4039ea:	687b      	ldr	r3, [r7, #4]
  4039ec:	605a      	str	r2, [r3, #4]
			pio->PIO_ABCDSR[0] |= (1<<pin);
  4039ee:	687b      	ldr	r3, [r7, #4]
  4039f0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  4039f2:	78fb      	ldrb	r3, [r7, #3]
  4039f4:	2101      	movs	r1, #1
  4039f6:	fa01 f303 	lsl.w	r3, r1, r3
  4039fa:	431a      	orrs	r2, r3
  4039fc:	687b      	ldr	r3, [r7, #4]
  4039fe:	671a      	str	r2, [r3, #112]	; 0x70
			pio->PIO_ABCDSR[1] &= ~(1<<pin);
  403a00:	687b      	ldr	r3, [r7, #4]
  403a02:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  403a04:	78fb      	ldrb	r3, [r7, #3]
  403a06:	2101      	movs	r1, #1
  403a08:	fa01 f303 	lsl.w	r3, r1, r3
  403a0c:	43db      	mvns	r3, r3
  403a0e:	401a      	ands	r2, r3
  403a10:	687b      	ldr	r3, [r7, #4]
  403a12:	675a      	str	r2, [r3, #116]	; 0x74
			break;
  403a14:	e034      	b.n	403a80 <pio_setMux+0x120>
		case C:
			pio->PIO_PDR = (1<<pin);
  403a16:	78fb      	ldrb	r3, [r7, #3]
  403a18:	2201      	movs	r2, #1
  403a1a:	fa02 f303 	lsl.w	r3, r2, r3
  403a1e:	461a      	mov	r2, r3
  403a20:	687b      	ldr	r3, [r7, #4]
  403a22:	605a      	str	r2, [r3, #4]
			pio->PIO_ABCDSR[0] &= ~(1<<pin);
  403a24:	687b      	ldr	r3, [r7, #4]
  403a26:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  403a28:	78fb      	ldrb	r3, [r7, #3]
  403a2a:	2101      	movs	r1, #1
  403a2c:	fa01 f303 	lsl.w	r3, r1, r3
  403a30:	43db      	mvns	r3, r3
  403a32:	401a      	ands	r2, r3
  403a34:	687b      	ldr	r3, [r7, #4]
  403a36:	671a      	str	r2, [r3, #112]	; 0x70
			pio->PIO_ABCDSR[1] |= (1<<pin);
  403a38:	687b      	ldr	r3, [r7, #4]
  403a3a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  403a3c:	78fb      	ldrb	r3, [r7, #3]
  403a3e:	2101      	movs	r1, #1
  403a40:	fa01 f303 	lsl.w	r3, r1, r3
  403a44:	431a      	orrs	r2, r3
  403a46:	687b      	ldr	r3, [r7, #4]
  403a48:	675a      	str	r2, [r3, #116]	; 0x74
			break;
  403a4a:	e019      	b.n	403a80 <pio_setMux+0x120>
		case D:
			pio->PIO_PDR = (1<<pin);
  403a4c:	78fb      	ldrb	r3, [r7, #3]
  403a4e:	2201      	movs	r2, #1
  403a50:	fa02 f303 	lsl.w	r3, r2, r3
  403a54:	461a      	mov	r2, r3
  403a56:	687b      	ldr	r3, [r7, #4]
  403a58:	605a      	str	r2, [r3, #4]
			pio->PIO_ABCDSR[0] |= (1<<pin);
  403a5a:	687b      	ldr	r3, [r7, #4]
  403a5c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  403a5e:	78fb      	ldrb	r3, [r7, #3]
  403a60:	2101      	movs	r1, #1
  403a62:	fa01 f303 	lsl.w	r3, r1, r3
  403a66:	431a      	orrs	r2, r3
  403a68:	687b      	ldr	r3, [r7, #4]
  403a6a:	671a      	str	r2, [r3, #112]	; 0x70
			pio->PIO_ABCDSR[1] |= (1<<pin);
  403a6c:	687b      	ldr	r3, [r7, #4]
  403a6e:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  403a70:	78fb      	ldrb	r3, [r7, #3]
  403a72:	2101      	movs	r1, #1
  403a74:	fa01 f303 	lsl.w	r3, r1, r3
  403a78:	431a      	orrs	r2, r3
  403a7a:	687b      	ldr	r3, [r7, #4]
  403a7c:	675a      	str	r2, [r3, #116]	; 0x74
			break;
  403a7e:	bf00      	nop
	}
	pio_enableWriteProtection(pio);
  403a80:	6878      	ldr	r0, [r7, #4]
  403a82:	4b03      	ldr	r3, [pc, #12]	; (403a90 <pio_setMux+0x130>)
  403a84:	4798      	blx	r3
}
  403a86:	3708      	adds	r7, #8
  403a88:	46bd      	mov	sp, r7
  403a8a:	bd80      	pop	{r7, pc}
  403a8c:	00403ae5 	.word	0x00403ae5
  403a90:	00403ac5 	.word	0x00403ac5

00403a94 <pio_readPin>:
};



bool pio_readPin(Pio * pio, uint8_t pin)
{
  403a94:	b480      	push	{r7}
  403a96:	b083      	sub	sp, #12
  403a98:	af00      	add	r7, sp, #0
  403a9a:	6078      	str	r0, [r7, #4]
  403a9c:	460b      	mov	r3, r1
  403a9e:	70fb      	strb	r3, [r7, #3]
	if(pio->PIO_PDSR & (1<<pin))
  403aa0:	687b      	ldr	r3, [r7, #4]
  403aa2:	6bda      	ldr	r2, [r3, #60]	; 0x3c
  403aa4:	78fb      	ldrb	r3, [r7, #3]
  403aa6:	2101      	movs	r1, #1
  403aa8:	fa01 f303 	lsl.w	r3, r1, r3
  403aac:	4013      	ands	r3, r2
  403aae:	2b00      	cmp	r3, #0
  403ab0:	d001      	beq.n	403ab6 <pio_readPin+0x22>
		return true;
  403ab2:	2301      	movs	r3, #1
  403ab4:	e000      	b.n	403ab8 <pio_readPin+0x24>
	else
		return false;
  403ab6:	2300      	movs	r3, #0
}
  403ab8:	4618      	mov	r0, r3
  403aba:	370c      	adds	r7, #12
  403abc:	46bd      	mov	sp, r7
  403abe:	f85d 7b04 	ldr.w	r7, [sp], #4
  403ac2:	4770      	bx	lr

00403ac4 <pio_enableWriteProtection>:
	pio->PIO_PPDDR = (1<<pin); // disable pulldown
	pio_enableWriteProtection(pio);
}


void pio_enableWriteProtection( Pio * pio ){
  403ac4:	b480      	push	{r7}
  403ac6:	b083      	sub	sp, #12
  403ac8:	af00      	add	r7, sp, #0
  403aca:	6078      	str	r0, [r7, #4]
	pio->PIO_WPMR = WPKEY_ENABLE;
  403acc:	687b      	ldr	r3, [r7, #4]
  403ace:	4a04      	ldr	r2, [pc, #16]	; (403ae0 <pio_enableWriteProtection+0x1c>)
  403ad0:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
}
  403ad4:	370c      	adds	r7, #12
  403ad6:	46bd      	mov	sp, r7
  403ad8:	f85d 7b04 	ldr.w	r7, [sp], #4
  403adc:	4770      	bx	lr
  403ade:	bf00      	nop
  403ae0:	50494f01 	.word	0x50494f01

00403ae4 <pio_disableWriteProtection>:

void pio_disableWriteProtection( Pio * pio ){
  403ae4:	b480      	push	{r7}
  403ae6:	b083      	sub	sp, #12
  403ae8:	af00      	add	r7, sp, #0
  403aea:	6078      	str	r0, [r7, #4]
	pio->PIO_WPMR = WPKEY_DISABLE;
  403aec:	687b      	ldr	r3, [r7, #4]
  403aee:	4a04      	ldr	r2, [pc, #16]	; (403b00 <pio_disableWriteProtection+0x1c>)
  403af0:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
}
  403af4:	370c      	adds	r7, #12
  403af6:	46bd      	mov	sp, r7
  403af8:	f85d 7b04 	ldr.w	r7, [sp], #4
  403afc:	4770      	bx	lr
  403afe:	bf00      	nop
  403b00:	50494f00 	.word	0x50494f00

00403b04 <PIOA_Handler>:



void PIOA_Handler()
{
  403b04:	b580      	push	{r7, lr}
  403b06:	b082      	sub	sp, #8
  403b08:	af00      	add	r7, sp, #0
	uint32_t interruptMask = PIOA->PIO_ISR & PIOA->PIO_IMR;
  403b0a:	4b10      	ldr	r3, [pc, #64]	; (403b4c <PIOA_Handler+0x48>)
  403b0c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  403b0e:	4b0f      	ldr	r3, [pc, #60]	; (403b4c <PIOA_Handler+0x48>)
  403b10:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  403b12:	4013      	ands	r3, r2
  403b14:	603b      	str	r3, [r7, #0]
	
	for(int i = 0; i < 32; i++){
  403b16:	2300      	movs	r3, #0
  403b18:	607b      	str	r3, [r7, #4]
  403b1a:	e010      	b.n	403b3e <PIOA_Handler+0x3a>
		if(interruptMask & (1<<i)){
  403b1c:	2201      	movs	r2, #1
  403b1e:	687b      	ldr	r3, [r7, #4]
  403b20:	fa02 f303 	lsl.w	r3, r2, r3
  403b24:	461a      	mov	r2, r3
  403b26:	683b      	ldr	r3, [r7, #0]
  403b28:	4013      	ands	r3, r2
  403b2a:	2b00      	cmp	r3, #0
  403b2c:	d004      	beq.n	403b38 <PIOA_Handler+0x34>
			(*pioaInterruptHooks[i])();
  403b2e:	4b08      	ldr	r3, [pc, #32]	; (403b50 <PIOA_Handler+0x4c>)
  403b30:	687a      	ldr	r2, [r7, #4]
  403b32:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  403b36:	4798      	blx	r3

void PIOA_Handler()
{
	uint32_t interruptMask = PIOA->PIO_ISR & PIOA->PIO_IMR;
	
	for(int i = 0; i < 32; i++){
  403b38:	687b      	ldr	r3, [r7, #4]
  403b3a:	3301      	adds	r3, #1
  403b3c:	607b      	str	r3, [r7, #4]
  403b3e:	687b      	ldr	r3, [r7, #4]
  403b40:	2b1f      	cmp	r3, #31
  403b42:	ddeb      	ble.n	403b1c <PIOA_Handler+0x18>
		if(interruptMask & (1<<i)){
			(*pioaInterruptHooks[i])();
		}
	}
}
  403b44:	3708      	adds	r7, #8
  403b46:	46bd      	mov	sp, r7
  403b48:	bd80      	pop	{r7, pc}
  403b4a:	bf00      	nop
  403b4c:	400e0e00 	.word	0x400e0e00
  403b50:	2000c1cc 	.word	0x2000c1cc

00403b54 <PIOB_Handler>:

void PIOB_Handler()
{
  403b54:	b580      	push	{r7, lr}
  403b56:	b082      	sub	sp, #8
  403b58:	af00      	add	r7, sp, #0
	uint32_t interruptMask = PIOB->PIO_ISR & PIOB->PIO_IMR;
  403b5a:	4b10      	ldr	r3, [pc, #64]	; (403b9c <PIOB_Handler+0x48>)
  403b5c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  403b5e:	4b0f      	ldr	r3, [pc, #60]	; (403b9c <PIOB_Handler+0x48>)
  403b60:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  403b62:	4013      	ands	r3, r2
  403b64:	603b      	str	r3, [r7, #0]
	
	for(int i = 0; i < 32; i++){
  403b66:	2300      	movs	r3, #0
  403b68:	607b      	str	r3, [r7, #4]
  403b6a:	e010      	b.n	403b8e <PIOB_Handler+0x3a>
		if(interruptMask & (1<<i)){
  403b6c:	2201      	movs	r2, #1
  403b6e:	687b      	ldr	r3, [r7, #4]
  403b70:	fa02 f303 	lsl.w	r3, r2, r3
  403b74:	461a      	mov	r2, r3
  403b76:	683b      	ldr	r3, [r7, #0]
  403b78:	4013      	ands	r3, r2
  403b7a:	2b00      	cmp	r3, #0
  403b7c:	d004      	beq.n	403b88 <PIOB_Handler+0x34>
			(*piobInterruptHooks[i])();
  403b7e:	4b08      	ldr	r3, [pc, #32]	; (403ba0 <PIOB_Handler+0x4c>)
  403b80:	687a      	ldr	r2, [r7, #4]
  403b82:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  403b86:	4798      	blx	r3

void PIOB_Handler()
{
	uint32_t interruptMask = PIOB->PIO_ISR & PIOB->PIO_IMR;
	
	for(int i = 0; i < 32; i++){
  403b88:	687b      	ldr	r3, [r7, #4]
  403b8a:	3301      	adds	r3, #1
  403b8c:	607b      	str	r3, [r7, #4]
  403b8e:	687b      	ldr	r3, [r7, #4]
  403b90:	2b1f      	cmp	r3, #31
  403b92:	ddeb      	ble.n	403b6c <PIOB_Handler+0x18>
		if(interruptMask & (1<<i)){
			(*piobInterruptHooks[i])();
		}
	}
}
  403b94:	3708      	adds	r7, #8
  403b96:	46bd      	mov	sp, r7
  403b98:	bd80      	pop	{r7, pc}
  403b9a:	bf00      	nop
  403b9c:	400e1000 	.word	0x400e1000
  403ba0:	2000c24c 	.word	0x2000c24c

00403ba4 <PIOC_Handler>:

void PIOC_Handler()
{
  403ba4:	b580      	push	{r7, lr}
  403ba6:	b082      	sub	sp, #8
  403ba8:	af00      	add	r7, sp, #0
	uint32_t interruptMask = PIOC->PIO_ISR & PIOC->PIO_IMR;
  403baa:	4b10      	ldr	r3, [pc, #64]	; (403bec <PIOC_Handler+0x48>)
  403bac:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  403bae:	4b0f      	ldr	r3, [pc, #60]	; (403bec <PIOC_Handler+0x48>)
  403bb0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  403bb2:	4013      	ands	r3, r2
  403bb4:	603b      	str	r3, [r7, #0]
	
	for(int i = 0; i < 32; i++){
  403bb6:	2300      	movs	r3, #0
  403bb8:	607b      	str	r3, [r7, #4]
  403bba:	e010      	b.n	403bde <PIOC_Handler+0x3a>
		if(interruptMask & (1<<i)){
  403bbc:	2201      	movs	r2, #1
  403bbe:	687b      	ldr	r3, [r7, #4]
  403bc0:	fa02 f303 	lsl.w	r3, r2, r3
  403bc4:	461a      	mov	r2, r3
  403bc6:	683b      	ldr	r3, [r7, #0]
  403bc8:	4013      	ands	r3, r2
  403bca:	2b00      	cmp	r3, #0
  403bcc:	d004      	beq.n	403bd8 <PIOC_Handler+0x34>
			(*piocInterruptHooks[i])();
  403bce:	4b08      	ldr	r3, [pc, #32]	; (403bf0 <PIOC_Handler+0x4c>)
  403bd0:	687a      	ldr	r2, [r7, #4]
  403bd2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  403bd6:	4798      	blx	r3

void PIOC_Handler()
{
	uint32_t interruptMask = PIOC->PIO_ISR & PIOC->PIO_IMR;
	
	for(int i = 0; i < 32; i++){
  403bd8:	687b      	ldr	r3, [r7, #4]
  403bda:	3301      	adds	r3, #1
  403bdc:	607b      	str	r3, [r7, #4]
  403bde:	687b      	ldr	r3, [r7, #4]
  403be0:	2b1f      	cmp	r3, #31
  403be2:	ddeb      	ble.n	403bbc <PIOC_Handler+0x18>
		if(interruptMask & (1<<i)){
			(*piocInterruptHooks[i])();
		}
	}
}
  403be4:	3708      	adds	r7, #8
  403be6:	46bd      	mov	sp, r7
  403be8:	bd80      	pop	{r7, pc}
  403bea:	bf00      	nop
  403bec:	400e1200 	.word	0x400e1200
  403bf0:	2000c2cc 	.word	0x2000c2cc

00403bf4 <PIOD_Handler>:

void PIOD_Handler()
{
  403bf4:	b580      	push	{r7, lr}
  403bf6:	b082      	sub	sp, #8
  403bf8:	af00      	add	r7, sp, #0
	uint32_t interruptMask = PIOD->PIO_ISR & PIOD->PIO_IMR;
  403bfa:	4b10      	ldr	r3, [pc, #64]	; (403c3c <PIOD_Handler+0x48>)
  403bfc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  403bfe:	4b0f      	ldr	r3, [pc, #60]	; (403c3c <PIOD_Handler+0x48>)
  403c00:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  403c02:	4013      	ands	r3, r2
  403c04:	603b      	str	r3, [r7, #0]
	
	for(int i = 0; i < 32; i++){
  403c06:	2300      	movs	r3, #0
  403c08:	607b      	str	r3, [r7, #4]
  403c0a:	e010      	b.n	403c2e <PIOD_Handler+0x3a>
		if(interruptMask & (1<<i)){
  403c0c:	2201      	movs	r2, #1
  403c0e:	687b      	ldr	r3, [r7, #4]
  403c10:	fa02 f303 	lsl.w	r3, r2, r3
  403c14:	461a      	mov	r2, r3
  403c16:	683b      	ldr	r3, [r7, #0]
  403c18:	4013      	ands	r3, r2
  403c1a:	2b00      	cmp	r3, #0
  403c1c:	d004      	beq.n	403c28 <PIOD_Handler+0x34>
			(*piodInterruptHooks[i])();
  403c1e:	4b08      	ldr	r3, [pc, #32]	; (403c40 <PIOD_Handler+0x4c>)
  403c20:	687a      	ldr	r2, [r7, #4]
  403c22:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  403c26:	4798      	blx	r3

void PIOD_Handler()
{
	uint32_t interruptMask = PIOD->PIO_ISR & PIOD->PIO_IMR;
	
	for(int i = 0; i < 32; i++){
  403c28:	687b      	ldr	r3, [r7, #4]
  403c2a:	3301      	adds	r3, #1
  403c2c:	607b      	str	r3, [r7, #4]
  403c2e:	687b      	ldr	r3, [r7, #4]
  403c30:	2b1f      	cmp	r3, #31
  403c32:	ddeb      	ble.n	403c0c <PIOD_Handler+0x18>
		if(interruptMask & (1<<i)){
			(*piodInterruptHooks[i])();
		}
	}
}
  403c34:	3708      	adds	r7, #8
  403c36:	46bd      	mov	sp, r7
  403c38:	bd80      	pop	{r7, pc}
  403c3a:	bf00      	nop
  403c3c:	400e1400 	.word	0x400e1400
  403c40:	2000c34c 	.word	0x2000c34c

00403c44 <PIOE_Handler>:

void PIOE_Handler()
{
  403c44:	b580      	push	{r7, lr}
  403c46:	b082      	sub	sp, #8
  403c48:	af00      	add	r7, sp, #0
	uint32_t interruptMask = PIOE->PIO_ISR & PIOE->PIO_IMR;
  403c4a:	4b10      	ldr	r3, [pc, #64]	; (403c8c <PIOE_Handler+0x48>)
  403c4c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  403c4e:	4b0f      	ldr	r3, [pc, #60]	; (403c8c <PIOE_Handler+0x48>)
  403c50:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  403c52:	4013      	ands	r3, r2
  403c54:	603b      	str	r3, [r7, #0]
	
	for(int i = 0; i < 32; i++){
  403c56:	2300      	movs	r3, #0
  403c58:	607b      	str	r3, [r7, #4]
  403c5a:	e010      	b.n	403c7e <PIOE_Handler+0x3a>
		if(interruptMask & (1<<i)){
  403c5c:	2201      	movs	r2, #1
  403c5e:	687b      	ldr	r3, [r7, #4]
  403c60:	fa02 f303 	lsl.w	r3, r2, r3
  403c64:	461a      	mov	r2, r3
  403c66:	683b      	ldr	r3, [r7, #0]
  403c68:	4013      	ands	r3, r2
  403c6a:	2b00      	cmp	r3, #0
  403c6c:	d004      	beq.n	403c78 <PIOE_Handler+0x34>
			(*pioeInterruptHooks[i])();
  403c6e:	4b08      	ldr	r3, [pc, #32]	; (403c90 <PIOE_Handler+0x4c>)
  403c70:	687a      	ldr	r2, [r7, #4]
  403c72:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  403c76:	4798      	blx	r3

void PIOE_Handler()
{
	uint32_t interruptMask = PIOE->PIO_ISR & PIOE->PIO_IMR;
	
	for(int i = 0; i < 32; i++){
  403c78:	687b      	ldr	r3, [r7, #4]
  403c7a:	3301      	adds	r3, #1
  403c7c:	607b      	str	r3, [r7, #4]
  403c7e:	687b      	ldr	r3, [r7, #4]
  403c80:	2b1f      	cmp	r3, #31
  403c82:	ddeb      	ble.n	403c5c <PIOE_Handler+0x18>
		if(interruptMask & (1<<i)){
			(*pioeInterruptHooks[i])();
		}
	}
  403c84:	3708      	adds	r7, #8
  403c86:	46bd      	mov	sp, r7
  403c88:	bd80      	pop	{r7, pc}
  403c8a:	bf00      	nop
  403c8c:	400e1600 	.word	0x400e1600
  403c90:	2000c3cc 	.word	0x2000c3cc

00403c94 <pmc_enable_writeprotect>:
extern "C" {
#endif


void pmc_enable_writeprotect(void)
{
  403c94:	b480      	push	{r7}
  403c96:	af00      	add	r7, sp, #0
	PMC->PMC_WPMR = PMC_WPMR_WPKEY_PASSWD | PMC_WPMR_WPEN;
  403c98:	4b03      	ldr	r3, [pc, #12]	; (403ca8 <pmc_enable_writeprotect+0x14>)
  403c9a:	4a04      	ldr	r2, [pc, #16]	; (403cac <pmc_enable_writeprotect+0x18>)
  403c9c:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
}
  403ca0:	46bd      	mov	sp, r7
  403ca2:	f85d 7b04 	ldr.w	r7, [sp], #4
  403ca6:	4770      	bx	lr
  403ca8:	400e0400 	.word	0x400e0400
  403cac:	504d4301 	.word	0x504d4301

00403cb0 <pmc_disable_writeprotect>:

void pmc_disable_writeprotect(void)
{
  403cb0:	b480      	push	{r7}
  403cb2:	af00      	add	r7, sp, #0
	PMC->PMC_WPMR = PMC_WPMR_WPKEY_PASSWD;
  403cb4:	4b03      	ldr	r3, [pc, #12]	; (403cc4 <pmc_disable_writeprotect+0x14>)
  403cb6:	4a04      	ldr	r2, [pc, #16]	; (403cc8 <pmc_disable_writeprotect+0x18>)
  403cb8:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
}
  403cbc:	46bd      	mov	sp, r7
  403cbe:	f85d 7b04 	ldr.w	r7, [sp], #4
  403cc2:	4770      	bx	lr
  403cc4:	400e0400 	.word	0x400e0400
  403cc8:	504d4300 	.word	0x504d4300

00403ccc <pmc_mck_set_prescaler>:

void pmc_mck_set_prescaler(uint32_t pres)
{
  403ccc:	b480      	push	{r7}
  403cce:	b083      	sub	sp, #12
  403cd0:	af00      	add	r7, sp, #0
  403cd2:	6078      	str	r0, [r7, #4]
	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | pres;
  403cd4:	4b09      	ldr	r3, [pc, #36]	; (403cfc <pmc_mck_set_prescaler+0x30>)
  403cd6:	4a09      	ldr	r2, [pc, #36]	; (403cfc <pmc_mck_set_prescaler+0x30>)
  403cd8:	6b12      	ldr	r2, [r2, #48]	; 0x30
  403cda:	f022 0170 	bic.w	r1, r2, #112	; 0x70
  403cde:	687a      	ldr	r2, [r7, #4]
  403ce0:	430a      	orrs	r2, r1
  403ce2:	631a      	str	r2, [r3, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
  403ce4:	bf00      	nop
  403ce6:	4b05      	ldr	r3, [pc, #20]	; (403cfc <pmc_mck_set_prescaler+0x30>)
  403ce8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  403cea:	f003 0308 	and.w	r3, r3, #8
  403cee:	2b00      	cmp	r3, #0
  403cf0:	d0f9      	beq.n	403ce6 <pmc_mck_set_prescaler+0x1a>
}
  403cf2:	370c      	adds	r7, #12
  403cf4:	46bd      	mov	sp, r7
  403cf6:	f85d 7b04 	ldr.w	r7, [sp], #4
  403cfa:	4770      	bx	lr
  403cfc:	400e0400 	.word	0x400e0400

00403d00 <pmc_mck_set_source>:


void pmc_mck_set_source(uint32_t css)
{
  403d00:	b480      	push	{r7}
  403d02:	b083      	sub	sp, #12
  403d04:	af00      	add	r7, sp, #0
  403d06:	6078      	str	r0, [r7, #4]
	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) | css;
  403d08:	4b09      	ldr	r3, [pc, #36]	; (403d30 <pmc_mck_set_source+0x30>)
  403d0a:	4a09      	ldr	r2, [pc, #36]	; (403d30 <pmc_mck_set_source+0x30>)
  403d0c:	6b12      	ldr	r2, [r2, #48]	; 0x30
  403d0e:	f022 0103 	bic.w	r1, r2, #3
  403d12:	687a      	ldr	r2, [r7, #4]
  403d14:	430a      	orrs	r2, r1
  403d16:	631a      	str	r2, [r3, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
  403d18:	bf00      	nop
  403d1a:	4b05      	ldr	r3, [pc, #20]	; (403d30 <pmc_mck_set_source+0x30>)
  403d1c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  403d1e:	f003 0308 	and.w	r3, r3, #8
  403d22:	2b00      	cmp	r3, #0
  403d24:	d0f9      	beq.n	403d1a <pmc_mck_set_source+0x1a>
}
  403d26:	370c      	adds	r7, #12
  403d28:	46bd      	mov	sp, r7
  403d2a:	f85d 7b04 	ldr.w	r7, [sp], #4
  403d2e:	4770      	bx	lr
  403d30:	400e0400 	.word	0x400e0400

00403d34 <pmc_switch_mainck_to_fastrc>:


void pmc_switch_mainck_to_fastrc(void)
{
  403d34:	b480      	push	{r7}
  403d36:	af00      	add	r7, sp, #0
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCSEL) | CKGR_MOR_KEY_PASSWD;
  403d38:	4a06      	ldr	r2, [pc, #24]	; (403d54 <pmc_switch_mainck_to_fastrc+0x20>)
  403d3a:	4b06      	ldr	r3, [pc, #24]	; (403d54 <pmc_switch_mainck_to_fastrc+0x20>)
  403d3c:	6a1b      	ldr	r3, [r3, #32]
  403d3e:	f023 739b 	bic.w	r3, r3, #20316160	; 0x1360000
  403d42:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  403d46:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  403d4a:	6213      	str	r3, [r2, #32]
}
  403d4c:	46bd      	mov	sp, r7
  403d4e:	f85d 7b04 	ldr.w	r7, [sp], #4
  403d52:	4770      	bx	lr
  403d54:	400e0400 	.word	0x400e0400

00403d58 <pmc_enable_fastrc>:

void pmc_enable_fastrc(void)
{
  403d58:	b480      	push	{r7}
  403d5a:	af00      	add	r7, sp, #0
	PMC->CKGR_MOR |= (CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCRCEN);
  403d5c:	4a09      	ldr	r2, [pc, #36]	; (403d84 <pmc_enable_fastrc+0x2c>)
  403d5e:	4b09      	ldr	r3, [pc, #36]	; (403d84 <pmc_enable_fastrc+0x2c>)
  403d60:	6a1b      	ldr	r3, [r3, #32]
  403d62:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  403d66:	f043 0308 	orr.w	r3, r3, #8
  403d6a:	6213      	str	r3, [r2, #32]
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS)); 	/* Wait the Fast RC to stabilize */
  403d6c:	bf00      	nop
  403d6e:	4b05      	ldr	r3, [pc, #20]	; (403d84 <pmc_enable_fastrc+0x2c>)
  403d70:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  403d72:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  403d76:	2b00      	cmp	r3, #0
  403d78:	d0f9      	beq.n	403d6e <pmc_enable_fastrc+0x16>
}
  403d7a:	46bd      	mov	sp, r7
  403d7c:	f85d 7b04 	ldr.w	r7, [sp], #4
  403d80:	4770      	bx	lr
  403d82:	bf00      	nop
  403d84:	400e0400 	.word	0x400e0400

00403d88 <pmc_set_fastrc_frequency>:

void pmc_set_fastrc_frequency(uint32_t moscrcf)
{
  403d88:	b480      	push	{r7}
  403d8a:	b083      	sub	sp, #12
  403d8c:	af00      	add	r7, sp, #0
  403d8e:	6078      	str	r0, [r7, #4]
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) | CKGR_MOR_KEY_PASSWD | moscrcf;
  403d90:	4a0b      	ldr	r2, [pc, #44]	; (403dc0 <pmc_set_fastrc_frequency+0x38>)
  403d92:	4b0b      	ldr	r3, [pc, #44]	; (403dc0 <pmc_set_fastrc_frequency+0x38>)
  403d94:	6a1b      	ldr	r3, [r3, #32]
  403d96:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  403d9a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  403d9e:	6879      	ldr	r1, [r7, #4]
  403da0:	430b      	orrs	r3, r1
  403da2:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  403da6:	6213      	str	r3, [r2, #32]
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS)); /* Wait the Fast RC to stabilize */
  403da8:	bf00      	nop
  403daa:	4b05      	ldr	r3, [pc, #20]	; (403dc0 <pmc_set_fastrc_frequency+0x38>)
  403dac:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  403dae:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  403db2:	2b00      	cmp	r3, #0
  403db4:	d0f9      	beq.n	403daa <pmc_set_fastrc_frequency+0x22>
}
  403db6:	370c      	adds	r7, #12
  403db8:	46bd      	mov	sp, r7
  403dba:	f85d 7b04 	ldr.w	r7, [sp], #4
  403dbe:	4770      	bx	lr
  403dc0:	400e0400 	.word	0x400e0400

00403dc4 <pmc_disable_fastrc>:

void pmc_disable_fastrc(void)
{
  403dc4:	b480      	push	{r7}
  403dc6:	af00      	add	r7, sp, #0
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCEN & ~CKGR_MOR_MOSCRCF_Msk) | CKGR_MOR_KEY_PASSWD;
  403dc8:	4a06      	ldr	r2, [pc, #24]	; (403de4 <pmc_disable_fastrc+0x20>)
  403dca:	4b06      	ldr	r3, [pc, #24]	; (403de4 <pmc_disable_fastrc+0x20>)
  403dcc:	6a1b      	ldr	r3, [r3, #32]
  403dce:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  403dd2:	f023 0378 	bic.w	r3, r3, #120	; 0x78
  403dd6:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  403dda:	6213      	str	r3, [r2, #32]
}
  403ddc:	46bd      	mov	sp, r7
  403dde:	f85d 7b04 	ldr.w	r7, [sp], #4
  403de2:	4770      	bx	lr
  403de4:	400e0400 	.word	0x400e0400

00403de8 <pmc_xtal_ready>:
{
	return (PMC->PMC_SR & PMC_SR_MOSCRCS);
}

uint32_t pmc_xtal_ready(void)
{
  403de8:	b480      	push	{r7}
  403dea:	af00      	add	r7, sp, #0
	return (PMC->PMC_SR & PMC_SR_MOSCXTS);
  403dec:	4b04      	ldr	r3, [pc, #16]	; (403e00 <pmc_xtal_ready+0x18>)
  403dee:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  403df0:	f003 0301 	and.w	r3, r3, #1
}
  403df4:	4618      	mov	r0, r3
  403df6:	46bd      	mov	sp, r7
  403df8:	f85d 7b04 	ldr.w	r7, [sp], #4
  403dfc:	4770      	bx	lr
  403dfe:	bf00      	nop
  403e00:	400e0400 	.word	0x400e0400

00403e04 <pmc_enable_main_xtal>:

void pmc_enable_main_xtal(uint32_t xtalStartupTime)
{
  403e04:	b580      	push	{r7, lr}
  403e06:	b084      	sub	sp, #16
  403e08:	af00      	add	r7, sp, #0
  403e0a:	6078      	str	r0, [r7, #4]
	uint32_t mor = PMC->CKGR_MOR;
  403e0c:	4b0e      	ldr	r3, [pc, #56]	; (403e48 <pmc_enable_main_xtal+0x44>)
  403e0e:	6a1b      	ldr	r3, [r3, #32]
  403e10:	60fb      	str	r3, [r7, #12]
	mor &= ~(CKGR_MOR_MOSCXTBY|CKGR_MOR_MOSCXTEN);
  403e12:	68fb      	ldr	r3, [r7, #12]
  403e14:	f023 0303 	bic.w	r3, r3, #3
  403e18:	60fb      	str	r3, [r7, #12]
	mor |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
			CKGR_MOR_MOSCXTST(xtalStartupTime);
  403e1a:	687b      	ldr	r3, [r7, #4]
  403e1c:	021b      	lsls	r3, r3, #8
  403e1e:	b29a      	uxth	r2, r3

void pmc_enable_main_xtal(uint32_t xtalStartupTime)
{
	uint32_t mor = PMC->CKGR_MOR;
	mor &= ~(CKGR_MOR_MOSCXTBY|CKGR_MOR_MOSCXTEN);
	mor |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  403e20:	68fb      	ldr	r3, [r7, #12]
  403e22:	4313      	orrs	r3, r2
  403e24:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  403e28:	f043 0301 	orr.w	r3, r3, #1
  403e2c:	60fb      	str	r3, [r7, #12]
			CKGR_MOR_MOSCXTST(xtalStartupTime);
	PMC->CKGR_MOR = mor;
  403e2e:	4b06      	ldr	r3, [pc, #24]	; (403e48 <pmc_enable_main_xtal+0x44>)
  403e30:	68fa      	ldr	r2, [r7, #12]
  403e32:	621a      	str	r2, [r3, #32]
	/* Wait the main Xtal to stabilize */
	while (!pmc_xtal_ready());
  403e34:	bf00      	nop
  403e36:	4b05      	ldr	r3, [pc, #20]	; (403e4c <pmc_enable_main_xtal+0x48>)
  403e38:	4798      	blx	r3
  403e3a:	4603      	mov	r3, r0
  403e3c:	2b00      	cmp	r3, #0
  403e3e:	d0fa      	beq.n	403e36 <pmc_enable_main_xtal+0x32>
}
  403e40:	3710      	adds	r7, #16
  403e42:	46bd      	mov	sp, r7
  403e44:	bd80      	pop	{r7, pc}
  403e46:	bf00      	nop
  403e48:	400e0400 	.word	0x400e0400
  403e4c:	00403de9 	.word	0x00403de9

00403e50 <pmc_switch_mainck_to_xtal>:

void pmc_switch_mainck_to_xtal(void)
{
  403e50:	b580      	push	{r7, lr}
  403e52:	af00      	add	r7, sp, #0
	PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
  403e54:	4a07      	ldr	r2, [pc, #28]	; (403e74 <pmc_switch_mainck_to_xtal+0x24>)
  403e56:	4b07      	ldr	r3, [pc, #28]	; (403e74 <pmc_switch_mainck_to_xtal+0x24>)
  403e58:	6a1b      	ldr	r3, [r3, #32]
  403e5a:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
  403e5e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  403e62:	6213      	str	r3, [r2, #32]
	while(!pmc_xtal_ready());
  403e64:	bf00      	nop
  403e66:	4b04      	ldr	r3, [pc, #16]	; (403e78 <pmc_switch_mainck_to_xtal+0x28>)
  403e68:	4798      	blx	r3
  403e6a:	4603      	mov	r3, r0
  403e6c:	2b00      	cmp	r3, #0
  403e6e:	d0fa      	beq.n	403e66 <pmc_switch_mainck_to_xtal+0x16>
}
  403e70:	bd80      	pop	{r7, pc}
  403e72:	bf00      	nop
  403e74:	400e0400 	.word	0x400e0400
  403e78:	00403de9 	.word	0x00403de9

00403e7c <pmc_disable_pllack>:
{
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
}

void pmc_disable_pllack(void)
{
  403e7c:	b480      	push	{r7}
  403e7e:	af00      	add	r7, sp, #0
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  403e80:	4b03      	ldr	r3, [pc, #12]	; (403e90 <pmc_disable_pllack+0x14>)
  403e82:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  403e86:	629a      	str	r2, [r3, #40]	; 0x28
}
  403e88:	46bd      	mov	sp, r7
  403e8a:	f85d 7b04 	ldr.w	r7, [sp], #4
  403e8e:	4770      	bx	lr
  403e90:	400e0400 	.word	0x400e0400

00403e94 <pmc_plla_is_locked>:

uint32_t pmc_plla_is_locked(void)
{
  403e94:	b480      	push	{r7}
  403e96:	af00      	add	r7, sp, #0
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  403e98:	4b04      	ldr	r3, [pc, #16]	; (403eac <pmc_plla_is_locked+0x18>)
  403e9a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  403e9c:	f003 0302 	and.w	r3, r3, #2
}
  403ea0:	4618      	mov	r0, r3
  403ea2:	46bd      	mov	sp, r7
  403ea4:	f85d 7b04 	ldr.w	r7, [sp], #4
  403ea8:	4770      	bx	lr
  403eaa:	bf00      	nop
  403eac:	400e0400 	.word	0x400e0400

00403eb0 <pmc_enable_pllack>:

void pmc_enable_pllack(uint32_t mula, uint32_t pllacount, uint32_t diva)
{
  403eb0:	b580      	push	{r7, lr}
  403eb2:	b084      	sub	sp, #16
  403eb4:	af00      	add	r7, sp, #0
  403eb6:	60f8      	str	r0, [r7, #12]
  403eb8:	60b9      	str	r1, [r7, #8]
  403eba:	607a      	str	r2, [r7, #4]
	/* first disable the PLL to unlock the lock */
	pmc_disable_pllack();
  403ebc:	4b10      	ldr	r3, [pc, #64]	; (403f00 <pmc_enable_pllack+0x50>)
  403ebe:	4798      	blx	r3

	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_DIVA(diva) | CKGR_PLLAR_PLLACOUNT(pllacount) | CKGR_PLLAR_MULA(mula);
  403ec0:	4a10      	ldr	r2, [pc, #64]	; (403f04 <pmc_enable_pllack+0x54>)
  403ec2:	687b      	ldr	r3, [r7, #4]
  403ec4:	b2d9      	uxtb	r1, r3
  403ec6:	68bb      	ldr	r3, [r7, #8]
  403ec8:	021b      	lsls	r3, r3, #8
  403eca:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
  403ece:	4319      	orrs	r1, r3
  403ed0:	68fb      	ldr	r3, [r7, #12]
  403ed2:	0418      	lsls	r0, r3, #16
  403ed4:	4b0c      	ldr	r3, [pc, #48]	; (403f08 <pmc_enable_pllack+0x58>)
  403ed6:	4003      	ands	r3, r0
  403ed8:	430b      	orrs	r3, r1
  403eda:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  403ede:	6293      	str	r3, [r2, #40]	; 0x28
	if(diva == 0 || mula == 0)
  403ee0:	687b      	ldr	r3, [r7, #4]
  403ee2:	2b00      	cmp	r3, #0
  403ee4:	d002      	beq.n	403eec <pmc_enable_pllack+0x3c>
  403ee6:	68fb      	ldr	r3, [r7, #12]
  403ee8:	2b00      	cmp	r3, #0
  403eea:	d100      	bne.n	403eee <pmc_enable_pllack+0x3e>
		return;
  403eec:	e005      	b.n	403efa <pmc_enable_pllack+0x4a>

	while (!pmc_plla_is_locked());
  403eee:	bf00      	nop
  403ef0:	4b06      	ldr	r3, [pc, #24]	; (403f0c <pmc_enable_pllack+0x5c>)
  403ef2:	4798      	blx	r3
  403ef4:	4603      	mov	r3, r0
  403ef6:	2b00      	cmp	r3, #0
  403ef8:	d0fa      	beq.n	403ef0 <pmc_enable_pllack+0x40>
}
  403efa:	3710      	adds	r7, #16
  403efc:	46bd      	mov	sp, r7
  403efe:	bd80      	pop	{r7, pc}
  403f00:	00403e7d 	.word	0x00403e7d
  403f04:	400e0400 	.word	0x400e0400
  403f08:	07ff0000 	.word	0x07ff0000
  403f0c:	00403e95 	.word	0x00403e95

00403f10 <pmc_select_main_clock>:
{
	PMC->CKGR_MOR = (PMC->CKGR_MOR & (~CKGR_MOR_CFDEN)) | CKGR_MOR_KEY_PASSWD;
}

void pmc_select_main_clock(MainClockFrequency freq)
{
  403f10:	b580      	push	{r7, lr}
  403f12:	b082      	sub	sp, #8
  403f14:	af00      	add	r7, sp, #0
  403f16:	4603      	mov	r3, r0
  403f18:	71fb      	strb	r3, [r7, #7]
	switch(freq){
  403f1a:	79fb      	ldrb	r3, [r7, #7]
  403f1c:	2b21      	cmp	r3, #33	; 0x21
  403f1e:	d858      	bhi.n	403fd2 <pmc_select_main_clock+0xc2>
  403f20:	a201      	add	r2, pc, #4	; (adr r2, 403f28 <pmc_select_main_clock+0x18>)
  403f22:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  403f26:	bf00      	nop
  403f28:	00403fb1 	.word	0x00403fb1
  403f2c:	00403fd3 	.word	0x00403fd3
  403f30:	00403fd3 	.word	0x00403fd3
  403f34:	00403fd3 	.word	0x00403fd3
  403f38:	00403fd3 	.word	0x00403fd3
  403f3c:	00403fd3 	.word	0x00403fd3
  403f40:	00403fd3 	.word	0x00403fd3
  403f44:	00403fd3 	.word	0x00403fd3
  403f48:	00403fd3 	.word	0x00403fd3
  403f4c:	00403fd3 	.word	0x00403fd3
  403f50:	00403fd3 	.word	0x00403fd3
  403f54:	00403fd3 	.word	0x00403fd3
  403f58:	00403fd3 	.word	0x00403fd3
  403f5c:	00403fd3 	.word	0x00403fd3
  403f60:	00403fd3 	.word	0x00403fd3
  403f64:	00403fd3 	.word	0x00403fd3
  403f68:	00403fb1 	.word	0x00403fb1
  403f6c:	00403fd3 	.word	0x00403fd3
  403f70:	00403fd3 	.word	0x00403fd3
  403f74:	00403fd3 	.word	0x00403fd3
  403f78:	00403fd3 	.word	0x00403fd3
  403f7c:	00403fd3 	.word	0x00403fd3
  403f80:	00403fd3 	.word	0x00403fd3
  403f84:	00403fd3 	.word	0x00403fd3
  403f88:	00403fd3 	.word	0x00403fd3
  403f8c:	00403fd3 	.word	0x00403fd3
  403f90:	00403fd3 	.word	0x00403fd3
  403f94:	00403fd3 	.word	0x00403fd3
  403f98:	00403fd3 	.word	0x00403fd3
  403f9c:	00403fd3 	.word	0x00403fd3
  403fa0:	00403fd3 	.word	0x00403fd3
  403fa4:	00403fd3 	.word	0x00403fd3
  403fa8:	00403fb1 	.word	0x00403fb1
  403fac:	00403fc3 	.word	0x00403fc3
		case INTERNAL_4MHZ:
		case INTERNAL_8MHZ:
		case INTERNAL_12MHZ:
		
		pmc_enable_fastrc();
  403fb0:	4b09      	ldr	r3, [pc, #36]	; (403fd8 <pmc_select_main_clock+0xc8>)
  403fb2:	4798      	blx	r3
		pmc_set_fastrc_frequency(freq);
  403fb4:	79fb      	ldrb	r3, [r7, #7]
  403fb6:	4618      	mov	r0, r3
  403fb8:	4b08      	ldr	r3, [pc, #32]	; (403fdc <pmc_select_main_clock+0xcc>)
  403fba:	4798      	blx	r3
		pmc_switch_mainck_to_fastrc();
  403fbc:	4b08      	ldr	r3, [pc, #32]	; (403fe0 <pmc_select_main_clock+0xd0>)
  403fbe:	4798      	blx	r3
		
		break;
  403fc0:	e007      	b.n	403fd2 <pmc_select_main_clock+0xc2>
		
		case EXTERNAL:
		pmc_enable_main_xtal(0xff);
  403fc2:	20ff      	movs	r0, #255	; 0xff
  403fc4:	4b07      	ldr	r3, [pc, #28]	; (403fe4 <pmc_select_main_clock+0xd4>)
  403fc6:	4798      	blx	r3
		pmc_switch_mainck_to_xtal();
  403fc8:	4b07      	ldr	r3, [pc, #28]	; (403fe8 <pmc_select_main_clock+0xd8>)
  403fca:	4798      	blx	r3
		pmc_disable_fastrc();
  403fcc:	4b07      	ldr	r3, [pc, #28]	; (403fec <pmc_select_main_clock+0xdc>)
  403fce:	4798      	blx	r3
		
		break;
  403fd0:	bf00      	nop
	}
}
  403fd2:	3708      	adds	r7, #8
  403fd4:	46bd      	mov	sp, r7
  403fd6:	bd80      	pop	{r7, pc}
  403fd8:	00403d59 	.word	0x00403d59
  403fdc:	00403d89 	.word	0x00403d89
  403fe0:	00403d35 	.word	0x00403d35
  403fe4:	00403e05 	.word	0x00403e05
  403fe8:	00403e51 	.word	0x00403e51
  403fec:	00403dc5 	.word	0x00403dc5

00403ff0 <pmc_select_master_clock>:

void pmc_select_master_clock(MasterClockSource css, ProcessorClockPrescaler pres)
{
  403ff0:	b580      	push	{r7, lr}
  403ff2:	b082      	sub	sp, #8
  403ff4:	af00      	add	r7, sp, #0
  403ff6:	4602      	mov	r2, r0
  403ff8:	460b      	mov	r3, r1
  403ffa:	71fa      	strb	r2, [r7, #7]
  403ffc:	71bb      	strb	r3, [r7, #6]
	if(css == PLLA_CLOCK){
  403ffe:	79fb      	ldrb	r3, [r7, #7]
  404000:	2b02      	cmp	r3, #2
  404002:	d108      	bne.n	404016 <pmc_select_master_clock+0x26>
		pmc_mck_set_prescaler(pres);
  404004:	79bb      	ldrb	r3, [r7, #6]
  404006:	4618      	mov	r0, r3
  404008:	4b08      	ldr	r3, [pc, #32]	; (40402c <pmc_select_master_clock+0x3c>)
  40400a:	4798      	blx	r3
		pmc_mck_set_source(css);
  40400c:	79fb      	ldrb	r3, [r7, #7]
  40400e:	4618      	mov	r0, r3
  404010:	4b07      	ldr	r3, [pc, #28]	; (404030 <pmc_select_master_clock+0x40>)
  404012:	4798      	blx	r3
  404014:	e007      	b.n	404026 <pmc_select_master_clock+0x36>
		} else {
		pmc_mck_set_source(css);
  404016:	79fb      	ldrb	r3, [r7, #7]
  404018:	4618      	mov	r0, r3
  40401a:	4b05      	ldr	r3, [pc, #20]	; (404030 <pmc_select_master_clock+0x40>)
  40401c:	4798      	blx	r3
		pmc_mck_set_prescaler(pres);
  40401e:	79bb      	ldrb	r3, [r7, #6]
  404020:	4618      	mov	r0, r3
  404022:	4b02      	ldr	r3, [pc, #8]	; (40402c <pmc_select_master_clock+0x3c>)
  404024:	4798      	blx	r3
	}
}
  404026:	3708      	adds	r7, #8
  404028:	46bd      	mov	sp, r7
  40402a:	bd80      	pop	{r7, pc}
  40402c:	00403ccd 	.word	0x00403ccd
  404030:	00403d01 	.word	0x00403d01

00404034 <pmc_enable_periph_clk>:
	pmc_enable_writeprotect();
}


uint32_t pmc_enable_periph_clk(uint32_t irqnNumber)
{
  404034:	b580      	push	{r7, lr}
  404036:	b082      	sub	sp, #8
  404038:	af00      	add	r7, sp, #0
  40403a:	6078      	str	r0, [r7, #4]
	if (irqnNumber > MAX_PERIPH_ID)
  40403c:	687b      	ldr	r3, [r7, #4]
  40403e:	2b2f      	cmp	r3, #47	; 0x2f
  404040:	d901      	bls.n	404046 <pmc_enable_periph_clk+0x12>
	return 1;
  404042:	2301      	movs	r3, #1
  404044:	e033      	b.n	4040ae <pmc_enable_periph_clk+0x7a>

	pmc_disable_writeprotect();
  404046:	4b1c      	ldr	r3, [pc, #112]	; (4040b8 <pmc_enable_periph_clk+0x84>)
  404048:	4798      	blx	r3
	if (irqnNumber < 32) {
  40404a:	687b      	ldr	r3, [r7, #4]
  40404c:	2b1f      	cmp	r3, #31
  40404e:	d813      	bhi.n	404078 <pmc_enable_periph_clk+0x44>
		if ((PMC->PMC_PCSR0 & (1 << irqnNumber)) != (1 << irqnNumber))
  404050:	4b1a      	ldr	r3, [pc, #104]	; (4040bc <pmc_enable_periph_clk+0x88>)
  404052:	699a      	ldr	r2, [r3, #24]
  404054:	687b      	ldr	r3, [r7, #4]
  404056:	2101      	movs	r1, #1
  404058:	fa01 f303 	lsl.w	r3, r1, r3
  40405c:	401a      	ands	r2, r3
  40405e:	687b      	ldr	r3, [r7, #4]
  404060:	2101      	movs	r1, #1
  404062:	fa01 f303 	lsl.w	r3, r1, r3
  404066:	429a      	cmp	r2, r3
  404068:	d01e      	beq.n	4040a8 <pmc_enable_periph_clk+0x74>
		PMC->PMC_PCER0 = (1 << irqnNumber);
  40406a:	4b14      	ldr	r3, [pc, #80]	; (4040bc <pmc_enable_periph_clk+0x88>)
  40406c:	687a      	ldr	r2, [r7, #4]
  40406e:	2101      	movs	r1, #1
  404070:	fa01 f202 	lsl.w	r2, r1, r2
  404074:	611a      	str	r2, [r3, #16]
  404076:	e017      	b.n	4040a8 <pmc_enable_periph_clk+0x74>
		} else {
		irqnNumber -= 32;
  404078:	687b      	ldr	r3, [r7, #4]
  40407a:	3b20      	subs	r3, #32
  40407c:	607b      	str	r3, [r7, #4]
		if ((PMC->PMC_PCSR1 & (1 << irqnNumber)) != (1 << irqnNumber))
  40407e:	4b0f      	ldr	r3, [pc, #60]	; (4040bc <pmc_enable_periph_clk+0x88>)
  404080:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  404084:	687b      	ldr	r3, [r7, #4]
  404086:	2101      	movs	r1, #1
  404088:	fa01 f303 	lsl.w	r3, r1, r3
  40408c:	401a      	ands	r2, r3
  40408e:	687b      	ldr	r3, [r7, #4]
  404090:	2101      	movs	r1, #1
  404092:	fa01 f303 	lsl.w	r3, r1, r3
  404096:	429a      	cmp	r2, r3
  404098:	d006      	beq.n	4040a8 <pmc_enable_periph_clk+0x74>
		PMC->PMC_PCER1 = (1 << irqnNumber);
  40409a:	4b08      	ldr	r3, [pc, #32]	; (4040bc <pmc_enable_periph_clk+0x88>)
  40409c:	687a      	ldr	r2, [r7, #4]
  40409e:	2101      	movs	r1, #1
  4040a0:	fa01 f202 	lsl.w	r2, r1, r2
  4040a4:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	}
	pmc_enable_writeprotect();
  4040a8:	4b05      	ldr	r3, [pc, #20]	; (4040c0 <pmc_enable_periph_clk+0x8c>)
  4040aa:	4798      	blx	r3

	return 0;
  4040ac:	2300      	movs	r3, #0
}
  4040ae:	4618      	mov	r0, r3
  4040b0:	3708      	adds	r7, #8
  4040b2:	46bd      	mov	sp, r7
  4040b4:	bd80      	pop	{r7, pc}
  4040b6:	bf00      	nop
  4040b8:	00403cb1 	.word	0x00403cb1
  4040bc:	400e0400 	.word	0x400e0400
  4040c0:	00403c95 	.word	0x00403c95

004040c4 <pmc_init>:

uint32_t pmc_init(struct PmcInit pmc_init_struct)
{
  4040c4:	b580      	push	{r7, lr}
  4040c6:	b082      	sub	sp, #8
  4040c8:	af00      	add	r7, sp, #0
  4040ca:	463b      	mov	r3, r7
  4040cc:	e883 0003 	stmia.w	r3, {r0, r1}
	pmc_disable_writeprotect();
  4040d0:	4b0d      	ldr	r3, [pc, #52]	; (404108 <pmc_init+0x44>)
  4040d2:	4798      	blx	r3
	pmc_select_main_clock(pmc_init_struct.freq);
  4040d4:	783b      	ldrb	r3, [r7, #0]
  4040d6:	4618      	mov	r0, r3
  4040d8:	4b0c      	ldr	r3, [pc, #48]	; (40410c <pmc_init+0x48>)
  4040da:	4798      	blx	r3
	pmc_enable_pllack(pmc_init_struct.multiply, 0x3f, pmc_init_struct.divide);
  4040dc:	793b      	ldrb	r3, [r7, #4]
  4040de:	461a      	mov	r2, r3
  4040e0:	78fb      	ldrb	r3, [r7, #3]
  4040e2:	4610      	mov	r0, r2
  4040e4:	213f      	movs	r1, #63	; 0x3f
  4040e6:	461a      	mov	r2, r3
  4040e8:	4b09      	ldr	r3, [pc, #36]	; (404110 <pmc_init+0x4c>)
  4040ea:	4798      	blx	r3
	pmc_select_master_clock(pmc_init_struct.css, pmc_init_struct.pres);
  4040ec:	787a      	ldrb	r2, [r7, #1]
  4040ee:	78bb      	ldrb	r3, [r7, #2]
  4040f0:	4610      	mov	r0, r2
  4040f2:	4619      	mov	r1, r3
  4040f4:	4b07      	ldr	r3, [pc, #28]	; (404114 <pmc_init+0x50>)
  4040f6:	4798      	blx	r3
	pmc_enable_writeprotect();
  4040f8:	4b07      	ldr	r3, [pc, #28]	; (404118 <pmc_init+0x54>)
  4040fa:	4798      	blx	r3

	return 0;
  4040fc:	2300      	movs	r3, #0
}
  4040fe:	4618      	mov	r0, r3
  404100:	3708      	adds	r7, #8
  404102:	46bd      	mov	sp, r7
  404104:	bd80      	pop	{r7, pc}
  404106:	bf00      	nop
  404108:	00403cb1 	.word	0x00403cb1
  40410c:	00403f11 	.word	0x00403f11
  404110:	00403eb1 	.word	0x00403eb1
  404114:	00403ff1 	.word	0x00403ff1
  404118:	00403c95 	.word	0x00403c95

0040411c <SPI_Handler>:
	vTaskDelay(5);
	// Release spi resource
	xSemaphoreGive(spi_mutex);
}

void SPI_Handler(void) {
  40411c:	b580      	push	{r7, lr}
  40411e:	b082      	sub	sp, #8
  404120:	af00      	add	r7, sp, #0
	long lHigherPriorityTaskWoken = pdFALSE;
  404122:	2300      	movs	r3, #0
  404124:	607b      	str	r3, [r7, #4]
	SPI->SPI_SR; // MUST READ SR TO CLEAR NSSR
  404126:	4b11      	ldr	r3, [pc, #68]	; (40416c <SPI_Handler+0x50>)
  404128:	691b      	ldr	r3, [r3, #16]
	if (callBackFunctionPointer != NULL) {
  40412a:	4b11      	ldr	r3, [pc, #68]	; (404170 <SPI_Handler+0x54>)
  40412c:	681b      	ldr	r3, [r3, #0]
  40412e:	2b00      	cmp	r3, #0
  404130:	d002      	beq.n	404138 <SPI_Handler+0x1c>
		callBackFunctionPointer();
  404132:	4b0f      	ldr	r3, [pc, #60]	; (404170 <SPI_Handler+0x54>)
  404134:	681b      	ldr	r3, [r3, #0]
  404136:	4798      	blx	r3
	}
	if (spi_handlerIsDoneSempahore != NULL) {
  404138:	4b0e      	ldr	r3, [pc, #56]	; (404174 <SPI_Handler+0x58>)
  40413a:	681b      	ldr	r3, [r3, #0]
  40413c:	2b00      	cmp	r3, #0
  40413e:	d006      	beq.n	40414e <SPI_Handler+0x32>
		xSemaphoreGiveFromISR(spi_handlerIsDoneSempahore,&lHigherPriorityTaskWoken);
  404140:	4b0c      	ldr	r3, [pc, #48]	; (404174 <SPI_Handler+0x58>)
  404142:	681a      	ldr	r2, [r3, #0]
  404144:	1d3b      	adds	r3, r7, #4
  404146:	4610      	mov	r0, r2
  404148:	4619      	mov	r1, r3
  40414a:	4b0b      	ldr	r3, [pc, #44]	; (404178 <SPI_Handler+0x5c>)
  40414c:	4798      	blx	r3
	}
	portEND_SWITCHING_ISR(lHigherPriorityTaskWoken);
  40414e:	687b      	ldr	r3, [r7, #4]
  404150:	2b00      	cmp	r3, #0
  404152:	d007      	beq.n	404164 <SPI_Handler+0x48>
  404154:	4b09      	ldr	r3, [pc, #36]	; (40417c <SPI_Handler+0x60>)
  404156:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  40415a:	601a      	str	r2, [r3, #0]
  40415c:	f3bf 8f4f 	dsb	sy
  404160:	f3bf 8f6f 	isb	sy
}
  404164:	3708      	adds	r7, #8
  404166:	46bd      	mov	sp, r7
  404168:	bd80      	pop	{r7, pc}
  40416a:	bf00      	nop
  40416c:	40088000 	.word	0x40088000
  404170:	2000c44c 	.word	0x2000c44c
  404174:	2000c490 	.word	0x2000c490
  404178:	0040152d 	.word	0x0040152d
  40417c:	e000ed04 	.word	0xe000ed04

00404180 <__libc_init_array>:
  404180:	b570      	push	{r4, r5, r6, lr}
  404182:	4e0f      	ldr	r6, [pc, #60]	; (4041c0 <__libc_init_array+0x40>)
  404184:	4d0f      	ldr	r5, [pc, #60]	; (4041c4 <__libc_init_array+0x44>)
  404186:	1b76      	subs	r6, r6, r5
  404188:	10b6      	asrs	r6, r6, #2
  40418a:	d007      	beq.n	40419c <__libc_init_array+0x1c>
  40418c:	3d04      	subs	r5, #4
  40418e:	2400      	movs	r4, #0
  404190:	3401      	adds	r4, #1
  404192:	f855 3f04 	ldr.w	r3, [r5, #4]!
  404196:	4798      	blx	r3
  404198:	42a6      	cmp	r6, r4
  40419a:	d1f9      	bne.n	404190 <__libc_init_array+0x10>
  40419c:	4e0a      	ldr	r6, [pc, #40]	; (4041c8 <__libc_init_array+0x48>)
  40419e:	4d0b      	ldr	r5, [pc, #44]	; (4041cc <__libc_init_array+0x4c>)
  4041a0:	1b76      	subs	r6, r6, r5
  4041a2:	f000 fac3 	bl	40472c <_init>
  4041a6:	10b6      	asrs	r6, r6, #2
  4041a8:	d008      	beq.n	4041bc <__libc_init_array+0x3c>
  4041aa:	3d04      	subs	r5, #4
  4041ac:	2400      	movs	r4, #0
  4041ae:	3401      	adds	r4, #1
  4041b0:	f855 3f04 	ldr.w	r3, [r5, #4]!
  4041b4:	4798      	blx	r3
  4041b6:	42a6      	cmp	r6, r4
  4041b8:	d1f9      	bne.n	4041ae <__libc_init_array+0x2e>
  4041ba:	bd70      	pop	{r4, r5, r6, pc}
  4041bc:	bd70      	pop	{r4, r5, r6, pc}
  4041be:	bf00      	nop
  4041c0:	00404738 	.word	0x00404738
  4041c4:	00404738 	.word	0x00404738
  4041c8:	00404740 	.word	0x00404740
  4041cc:	00404738 	.word	0x00404738

004041d0 <memcmp>:
  4041d0:	2a03      	cmp	r2, #3
  4041d2:	b470      	push	{r4, r5, r6}
  4041d4:	d928      	bls.n	404228 <memcmp+0x58>
  4041d6:	ea40 0301 	orr.w	r3, r0, r1
  4041da:	079b      	lsls	r3, r3, #30
  4041dc:	d013      	beq.n	404206 <memcmp+0x36>
  4041de:	7805      	ldrb	r5, [r0, #0]
  4041e0:	780c      	ldrb	r4, [r1, #0]
  4041e2:	42a5      	cmp	r5, r4
  4041e4:	d124      	bne.n	404230 <memcmp+0x60>
  4041e6:	3a01      	subs	r2, #1
  4041e8:	2300      	movs	r3, #0
  4041ea:	e005      	b.n	4041f8 <memcmp+0x28>
  4041ec:	f810 5f01 	ldrb.w	r5, [r0, #1]!
  4041f0:	f811 4f01 	ldrb.w	r4, [r1, #1]!
  4041f4:	42a5      	cmp	r5, r4
  4041f6:	d11b      	bne.n	404230 <memcmp+0x60>
  4041f8:	4293      	cmp	r3, r2
  4041fa:	f103 0301 	add.w	r3, r3, #1
  4041fe:	d1f5      	bne.n	4041ec <memcmp+0x1c>
  404200:	2000      	movs	r0, #0
  404202:	bc70      	pop	{r4, r5, r6}
  404204:	4770      	bx	lr
  404206:	460c      	mov	r4, r1
  404208:	4603      	mov	r3, r0
  40420a:	6825      	ldr	r5, [r4, #0]
  40420c:	681e      	ldr	r6, [r3, #0]
  40420e:	42ae      	cmp	r6, r5
  404210:	4621      	mov	r1, r4
  404212:	4618      	mov	r0, r3
  404214:	f104 0404 	add.w	r4, r4, #4
  404218:	f103 0304 	add.w	r3, r3, #4
  40421c:	d104      	bne.n	404228 <memcmp+0x58>
  40421e:	3a04      	subs	r2, #4
  404220:	2a03      	cmp	r2, #3
  404222:	4618      	mov	r0, r3
  404224:	4621      	mov	r1, r4
  404226:	d8f0      	bhi.n	40420a <memcmp+0x3a>
  404228:	2a00      	cmp	r2, #0
  40422a:	d1d8      	bne.n	4041de <memcmp+0xe>
  40422c:	4610      	mov	r0, r2
  40422e:	e7e8      	b.n	404202 <memcmp+0x32>
  404230:	1b28      	subs	r0, r5, r4
  404232:	bc70      	pop	{r4, r5, r6}
  404234:	4770      	bx	lr
  404236:	bf00      	nop

00404238 <memcpy>:
  404238:	4684      	mov	ip, r0
  40423a:	ea41 0300 	orr.w	r3, r1, r0
  40423e:	f013 0303 	ands.w	r3, r3, #3
  404242:	d16d      	bne.n	404320 <memcpy+0xe8>
  404244:	3a40      	subs	r2, #64	; 0x40
  404246:	d341      	bcc.n	4042cc <memcpy+0x94>
  404248:	f851 3b04 	ldr.w	r3, [r1], #4
  40424c:	f840 3b04 	str.w	r3, [r0], #4
  404250:	f851 3b04 	ldr.w	r3, [r1], #4
  404254:	f840 3b04 	str.w	r3, [r0], #4
  404258:	f851 3b04 	ldr.w	r3, [r1], #4
  40425c:	f840 3b04 	str.w	r3, [r0], #4
  404260:	f851 3b04 	ldr.w	r3, [r1], #4
  404264:	f840 3b04 	str.w	r3, [r0], #4
  404268:	f851 3b04 	ldr.w	r3, [r1], #4
  40426c:	f840 3b04 	str.w	r3, [r0], #4
  404270:	f851 3b04 	ldr.w	r3, [r1], #4
  404274:	f840 3b04 	str.w	r3, [r0], #4
  404278:	f851 3b04 	ldr.w	r3, [r1], #4
  40427c:	f840 3b04 	str.w	r3, [r0], #4
  404280:	f851 3b04 	ldr.w	r3, [r1], #4
  404284:	f840 3b04 	str.w	r3, [r0], #4
  404288:	f851 3b04 	ldr.w	r3, [r1], #4
  40428c:	f840 3b04 	str.w	r3, [r0], #4
  404290:	f851 3b04 	ldr.w	r3, [r1], #4
  404294:	f840 3b04 	str.w	r3, [r0], #4
  404298:	f851 3b04 	ldr.w	r3, [r1], #4
  40429c:	f840 3b04 	str.w	r3, [r0], #4
  4042a0:	f851 3b04 	ldr.w	r3, [r1], #4
  4042a4:	f840 3b04 	str.w	r3, [r0], #4
  4042a8:	f851 3b04 	ldr.w	r3, [r1], #4
  4042ac:	f840 3b04 	str.w	r3, [r0], #4
  4042b0:	f851 3b04 	ldr.w	r3, [r1], #4
  4042b4:	f840 3b04 	str.w	r3, [r0], #4
  4042b8:	f851 3b04 	ldr.w	r3, [r1], #4
  4042bc:	f840 3b04 	str.w	r3, [r0], #4
  4042c0:	f851 3b04 	ldr.w	r3, [r1], #4
  4042c4:	f840 3b04 	str.w	r3, [r0], #4
  4042c8:	3a40      	subs	r2, #64	; 0x40
  4042ca:	d2bd      	bcs.n	404248 <memcpy+0x10>
  4042cc:	3230      	adds	r2, #48	; 0x30
  4042ce:	d311      	bcc.n	4042f4 <memcpy+0xbc>
  4042d0:	f851 3b04 	ldr.w	r3, [r1], #4
  4042d4:	f840 3b04 	str.w	r3, [r0], #4
  4042d8:	f851 3b04 	ldr.w	r3, [r1], #4
  4042dc:	f840 3b04 	str.w	r3, [r0], #4
  4042e0:	f851 3b04 	ldr.w	r3, [r1], #4
  4042e4:	f840 3b04 	str.w	r3, [r0], #4
  4042e8:	f851 3b04 	ldr.w	r3, [r1], #4
  4042ec:	f840 3b04 	str.w	r3, [r0], #4
  4042f0:	3a10      	subs	r2, #16
  4042f2:	d2ed      	bcs.n	4042d0 <memcpy+0x98>
  4042f4:	320c      	adds	r2, #12
  4042f6:	d305      	bcc.n	404304 <memcpy+0xcc>
  4042f8:	f851 3b04 	ldr.w	r3, [r1], #4
  4042fc:	f840 3b04 	str.w	r3, [r0], #4
  404300:	3a04      	subs	r2, #4
  404302:	d2f9      	bcs.n	4042f8 <memcpy+0xc0>
  404304:	3204      	adds	r2, #4
  404306:	d008      	beq.n	40431a <memcpy+0xe2>
  404308:	07d2      	lsls	r2, r2, #31
  40430a:	bf1c      	itt	ne
  40430c:	f811 3b01 	ldrbne.w	r3, [r1], #1
  404310:	f800 3b01 	strbne.w	r3, [r0], #1
  404314:	d301      	bcc.n	40431a <memcpy+0xe2>
  404316:	880b      	ldrh	r3, [r1, #0]
  404318:	8003      	strh	r3, [r0, #0]
  40431a:	4660      	mov	r0, ip
  40431c:	4770      	bx	lr
  40431e:	bf00      	nop
  404320:	2a08      	cmp	r2, #8
  404322:	d313      	bcc.n	40434c <memcpy+0x114>
  404324:	078b      	lsls	r3, r1, #30
  404326:	d08d      	beq.n	404244 <memcpy+0xc>
  404328:	f010 0303 	ands.w	r3, r0, #3
  40432c:	d08a      	beq.n	404244 <memcpy+0xc>
  40432e:	f1c3 0304 	rsb	r3, r3, #4
  404332:	1ad2      	subs	r2, r2, r3
  404334:	07db      	lsls	r3, r3, #31
  404336:	bf1c      	itt	ne
  404338:	f811 3b01 	ldrbne.w	r3, [r1], #1
  40433c:	f800 3b01 	strbne.w	r3, [r0], #1
  404340:	d380      	bcc.n	404244 <memcpy+0xc>
  404342:	f831 3b02 	ldrh.w	r3, [r1], #2
  404346:	f820 3b02 	strh.w	r3, [r0], #2
  40434a:	e77b      	b.n	404244 <memcpy+0xc>
  40434c:	3a04      	subs	r2, #4
  40434e:	d3d9      	bcc.n	404304 <memcpy+0xcc>
  404350:	3a01      	subs	r2, #1
  404352:	f811 3b01 	ldrb.w	r3, [r1], #1
  404356:	f800 3b01 	strb.w	r3, [r0], #1
  40435a:	d2f9      	bcs.n	404350 <memcpy+0x118>
  40435c:	780b      	ldrb	r3, [r1, #0]
  40435e:	7003      	strb	r3, [r0, #0]
  404360:	784b      	ldrb	r3, [r1, #1]
  404362:	7043      	strb	r3, [r0, #1]
  404364:	788b      	ldrb	r3, [r1, #2]
  404366:	7083      	strb	r3, [r0, #2]
  404368:	4660      	mov	r0, ip
  40436a:	4770      	bx	lr

0040436c <memset>:
  40436c:	b4f0      	push	{r4, r5, r6, r7}
  40436e:	0784      	lsls	r4, r0, #30
  404370:	d043      	beq.n	4043fa <memset+0x8e>
  404372:	1e54      	subs	r4, r2, #1
  404374:	2a00      	cmp	r2, #0
  404376:	d03e      	beq.n	4043f6 <memset+0x8a>
  404378:	b2cd      	uxtb	r5, r1
  40437a:	4603      	mov	r3, r0
  40437c:	e003      	b.n	404386 <memset+0x1a>
  40437e:	1e62      	subs	r2, r4, #1
  404380:	2c00      	cmp	r4, #0
  404382:	d038      	beq.n	4043f6 <memset+0x8a>
  404384:	4614      	mov	r4, r2
  404386:	f803 5b01 	strb.w	r5, [r3], #1
  40438a:	079a      	lsls	r2, r3, #30
  40438c:	d1f7      	bne.n	40437e <memset+0x12>
  40438e:	2c03      	cmp	r4, #3
  404390:	d92a      	bls.n	4043e8 <memset+0x7c>
  404392:	b2cd      	uxtb	r5, r1
  404394:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
  404398:	2c0f      	cmp	r4, #15
  40439a:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
  40439e:	d915      	bls.n	4043cc <memset+0x60>
  4043a0:	f1a4 0710 	sub.w	r7, r4, #16
  4043a4:	093f      	lsrs	r7, r7, #4
  4043a6:	f103 0610 	add.w	r6, r3, #16
  4043aa:	eb06 1607 	add.w	r6, r6, r7, lsl #4
  4043ae:	461a      	mov	r2, r3
  4043b0:	6015      	str	r5, [r2, #0]
  4043b2:	6055      	str	r5, [r2, #4]
  4043b4:	6095      	str	r5, [r2, #8]
  4043b6:	60d5      	str	r5, [r2, #12]
  4043b8:	3210      	adds	r2, #16
  4043ba:	42b2      	cmp	r2, r6
  4043bc:	d1f8      	bne.n	4043b0 <memset+0x44>
  4043be:	f004 040f 	and.w	r4, r4, #15
  4043c2:	3701      	adds	r7, #1
  4043c4:	2c03      	cmp	r4, #3
  4043c6:	eb03 1307 	add.w	r3, r3, r7, lsl #4
  4043ca:	d90d      	bls.n	4043e8 <memset+0x7c>
  4043cc:	461e      	mov	r6, r3
  4043ce:	4622      	mov	r2, r4
  4043d0:	3a04      	subs	r2, #4
  4043d2:	2a03      	cmp	r2, #3
  4043d4:	f846 5b04 	str.w	r5, [r6], #4
  4043d8:	d8fa      	bhi.n	4043d0 <memset+0x64>
  4043da:	1f22      	subs	r2, r4, #4
  4043dc:	f022 0203 	bic.w	r2, r2, #3
  4043e0:	3204      	adds	r2, #4
  4043e2:	4413      	add	r3, r2
  4043e4:	f004 0403 	and.w	r4, r4, #3
  4043e8:	b12c      	cbz	r4, 4043f6 <memset+0x8a>
  4043ea:	b2c9      	uxtb	r1, r1
  4043ec:	441c      	add	r4, r3
  4043ee:	f803 1b01 	strb.w	r1, [r3], #1
  4043f2:	42a3      	cmp	r3, r4
  4043f4:	d1fb      	bne.n	4043ee <memset+0x82>
  4043f6:	bcf0      	pop	{r4, r5, r6, r7}
  4043f8:	4770      	bx	lr
  4043fa:	4614      	mov	r4, r2
  4043fc:	4603      	mov	r3, r0
  4043fe:	e7c6      	b.n	40438e <memset+0x22>

00404400 <register_fini>:
  404400:	4b02      	ldr	r3, [pc, #8]	; (40440c <register_fini+0xc>)
  404402:	b113      	cbz	r3, 40440a <register_fini+0xa>
  404404:	4802      	ldr	r0, [pc, #8]	; (404410 <register_fini+0x10>)
  404406:	f000 b805 	b.w	404414 <atexit>
  40440a:	4770      	bx	lr
  40440c:	00000000 	.word	0x00000000
  404410:	00404421 	.word	0x00404421

00404414 <atexit>:
  404414:	4601      	mov	r1, r0
  404416:	2000      	movs	r0, #0
  404418:	4602      	mov	r2, r0
  40441a:	4603      	mov	r3, r0
  40441c:	f000 b818 	b.w	404450 <__register_exitproc>

00404420 <__libc_fini_array>:
  404420:	b538      	push	{r3, r4, r5, lr}
  404422:	4d09      	ldr	r5, [pc, #36]	; (404448 <__libc_fini_array+0x28>)
  404424:	4c09      	ldr	r4, [pc, #36]	; (40444c <__libc_fini_array+0x2c>)
  404426:	1b64      	subs	r4, r4, r5
  404428:	10a4      	asrs	r4, r4, #2
  40442a:	bf18      	it	ne
  40442c:	eb05 0584 	addne.w	r5, r5, r4, lsl #2
  404430:	d005      	beq.n	40443e <__libc_fini_array+0x1e>
  404432:	3c01      	subs	r4, #1
  404434:	f855 3d04 	ldr.w	r3, [r5, #-4]!
  404438:	4798      	blx	r3
  40443a:	2c00      	cmp	r4, #0
  40443c:	d1f9      	bne.n	404432 <__libc_fini_array+0x12>
  40443e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  404442:	f000 b97d 	b.w	404740 <_fini>
  404446:	bf00      	nop
  404448:	0040474c 	.word	0x0040474c
  40444c:	00404750 	.word	0x00404750

00404450 <__register_exitproc>:
  404450:	b5f0      	push	{r4, r5, r6, r7, lr}
  404452:	4c27      	ldr	r4, [pc, #156]	; (4044f0 <__register_exitproc+0xa0>)
  404454:	6826      	ldr	r6, [r4, #0]
  404456:	f8d6 4148 	ldr.w	r4, [r6, #328]	; 0x148
  40445a:	b085      	sub	sp, #20
  40445c:	4607      	mov	r7, r0
  40445e:	2c00      	cmp	r4, #0
  404460:	d041      	beq.n	4044e6 <__register_exitproc+0x96>
  404462:	6865      	ldr	r5, [r4, #4]
  404464:	2d1f      	cmp	r5, #31
  404466:	dd1e      	ble.n	4044a6 <__register_exitproc+0x56>
  404468:	4822      	ldr	r0, [pc, #136]	; (4044f4 <__register_exitproc+0xa4>)
  40446a:	b918      	cbnz	r0, 404474 <__register_exitproc+0x24>
  40446c:	f04f 30ff 	mov.w	r0, #4294967295
  404470:	b005      	add	sp, #20
  404472:	bdf0      	pop	{r4, r5, r6, r7, pc}
  404474:	f44f 70c8 	mov.w	r0, #400	; 0x190
  404478:	9103      	str	r1, [sp, #12]
  40447a:	9202      	str	r2, [sp, #8]
  40447c:	9301      	str	r3, [sp, #4]
  40447e:	f3af 8000 	nop.w
  404482:	9903      	ldr	r1, [sp, #12]
  404484:	9a02      	ldr	r2, [sp, #8]
  404486:	9b01      	ldr	r3, [sp, #4]
  404488:	4604      	mov	r4, r0
  40448a:	2800      	cmp	r0, #0
  40448c:	d0ee      	beq.n	40446c <__register_exitproc+0x1c>
  40448e:	f8d6 5148 	ldr.w	r5, [r6, #328]	; 0x148
  404492:	6025      	str	r5, [r4, #0]
  404494:	2000      	movs	r0, #0
  404496:	6060      	str	r0, [r4, #4]
  404498:	4605      	mov	r5, r0
  40449a:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
  40449e:	f8c4 0188 	str.w	r0, [r4, #392]	; 0x188
  4044a2:	f8c4 018c 	str.w	r0, [r4, #396]	; 0x18c
  4044a6:	b93f      	cbnz	r7, 4044b8 <__register_exitproc+0x68>
  4044a8:	1cab      	adds	r3, r5, #2
  4044aa:	2000      	movs	r0, #0
  4044ac:	3501      	adds	r5, #1
  4044ae:	6065      	str	r5, [r4, #4]
  4044b0:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
  4044b4:	b005      	add	sp, #20
  4044b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4044b8:	eb04 0085 	add.w	r0, r4, r5, lsl #2
  4044bc:	f04f 0c01 	mov.w	ip, #1
  4044c0:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  4044c4:	f8d4 6188 	ldr.w	r6, [r4, #392]	; 0x188
  4044c8:	fa0c f205 	lsl.w	r2, ip, r5
  4044cc:	4316      	orrs	r6, r2
  4044ce:	2f02      	cmp	r7, #2
  4044d0:	f8c4 6188 	str.w	r6, [r4, #392]	; 0x188
  4044d4:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
  4044d8:	d1e6      	bne.n	4044a8 <__register_exitproc+0x58>
  4044da:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
  4044de:	431a      	orrs	r2, r3
  4044e0:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
  4044e4:	e7e0      	b.n	4044a8 <__register_exitproc+0x58>
  4044e6:	f506 74a6 	add.w	r4, r6, #332	; 0x14c
  4044ea:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
  4044ee:	e7b8      	b.n	404462 <__register_exitproc+0x12>
  4044f0:	00404728 	.word	0x00404728
  4044f4:	00000000 	.word	0x00000000
  4044f8:	0000000f 	.word	0x0000000f
  4044fc:	00000000 	.word	0x00000000
  404500:	00000001 	.word	0x00000001
  404504:	00000044 	.word	0x00000044
  404508:	6e696c62 	.word	0x6e696c62
  40450c:	6d61496b 	.word	0x6d61496b
  404510:	76696c41 	.word	0x76696c41
  404514:	73615465 	.word	0x73615465
  404518:	0000006b 	.word	0x0000006b
  40451c:	5f4e4143 	.word	0x5f4e4143
  404520:	5f524143 	.word	0x5f524143
  404524:	646e6573 	.word	0x646e6573
  404528:	6b736154 	.word	0x6b736154
  40452c:	00000000 	.word	0x00000000
  404530:	546e6163 	.word	0x546e6163
  404534:	54747365 	.word	0x54747365
  404538:	006b7361 	.word	0x006b7361
  40453c:	01100221 	.word	0x01100221
  404540:	0000000e 	.word	0x0000000e
  404544:	00000000 	.word	0x00000000
  404548:	00000002 	.word	0x00000002
  40454c:	00000000 	.word	0x00000000
  404550:	00000001 	.word	0x00000001
  404554:	00000044 	.word	0x00000044
  404558:	2e2f2e2e 	.word	0x2e2f2e2e
  40455c:	6d61732f 	.word	0x6d61732f
  404560:	622d6534 	.word	0x622d6534
  404564:	2e657361 	.word	0x2e657361
  404568:	00000063 	.word	0x00000063
  40456c:	00000000 	.word	0x00000000

00404570 <pcInterruptPriorityRegisters>:
  404570:	e000e3f0 732f2e2e 65346d61 7361625f     ....../sam4e_bas
  404580:	72462f65 54526565 532f534f 6372756f     e/FreeRTOS/Sourc
  404590:	6f702f65 62617472 472f656c 412f4343     e/portable/GCC/A
  4045a0:	435f4d52 2f46344d 74726f70 0000632e     RM_CM4F/port.c..

004045b0 <xHeapStructSize>:
  4045b0:	00000008 732f2e2e 65346d61 7361625f     ....../sam4e_bas
  4045c0:	72462f65 54526565 532f534f 6372756f     e/FreeRTOS/Sourc
  4045d0:	6f702f65 62617472 4d2f656c 614d6d65     e/portable/MemMa
  4045e0:	682f676e 5f706165 00632e34 732f2e2e     ng/heap_4.c.../s
  4045f0:	65346d61 7361625f 72462f65 54526565     am4e_base/FreeRT
  404600:	532f534f 6372756f 75712f65 2e657565     OS/Source/queue.
  404610:	00000063 732f2e2e 65346d61 7361625f     c...../sam4e_bas
  404620:	72462f65 54526565 532f534f 6372756f     e/FreeRTOS/Sourc
  404630:	61742f65 2e736b73 00000063 454c4449     e/tasks.c...IDLE
  404640:	00000000 09632509 25097525 75250975     .....%c.%u.%u.%u
  404650:	00000a0d 09752509 25752509 000a0d25     .....%u..%u%%...
  404660:	09752509 25313c09 000a0d25              .%u..<1%%...

0040466c <ucExpectedStackBytes.6096>:
  40466c:	a5a5a5a5 a5a5a5a5 a5a5a5a5 a5a5a5a5     ................
  40467c:	a5a5a5a5 20726d54 00637653 732f2e2e     ....Tmr Svc.../s
  40468c:	65346d61 7361625f 72462f65 54526565     am4e_base/FreeRT
  40469c:	532f534f 6372756f 69742f65 7372656d     OS/Source/timers
  4046ac:	0000632e 51726d54 00000000              .c..TmrQ....

004046b8 <can_bit_time>:
  4046b8:	02020308 02094b03 43020303 0303030a     .....K.....C....
  4046c8:	040b4603 48040303 0404030c 040d4304     .F.....H.....C..
  4046d8:	4d040404 0504040e 040f4004 43040505     ...M.....@.....C
  4046e8:	05050510 06114504 47040505 06060512     .....E.....G....
  4046f8:	06134304 44040606 06060714 08154604     .C.....D.....F..
  404708:	47040606 07070716 08174404 46040708     ...G.....D.....F
  404718:	08080718 08194304 44040808 00000043     .....C.....DC...

00404728 <_global_impure_ptr>:
  404728:	20000010                                ... 

0040472c <_init>:
  40472c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40472e:	bf00      	nop
  404730:	bcf8      	pop	{r3, r4, r5, r6, r7}
  404732:	bc08      	pop	{r3}
  404734:	469e      	mov	lr, r3
  404736:	4770      	bx	lr

00404738 <__init_array_start>:
  404738:	00404401 	.word	0x00404401

0040473c <__frame_dummy_init_array_entry>:
  40473c:	0040011d                                ..@.

00404740 <_fini>:
  404740:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  404742:	bf00      	nop
  404744:	bcf8      	pop	{r3, r4, r5, r6, r7}
  404746:	bc08      	pop	{r3}
  404748:	469e      	mov	lr, r3
  40474a:	4770      	bx	lr

0040474c <__fini_array_start>:
  40474c:	004000f9 	.word	0x004000f9
